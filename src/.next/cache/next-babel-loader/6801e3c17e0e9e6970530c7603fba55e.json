{"ast":null,"code":"import _compose from \"lodash/fp/compose\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport produce from 'immer';\n\n// Nhận vào trạng thái hiện tại của data structure\n// và operation tương ứng. Trả về trạng thái mới\nconst transformLinkedListModel = (currentModel, operation, payload) => {\n  switch (operation) {\n    case 'remove':\n      {\n        const [nodeKey] = payload;\n        return produce(currentModel, draft => {\n          const nodeToRemove = draft.find(({\n            key\n          }) => key === nodeKey);\n          if (nodeToRemove) nodeToRemove.visible = false;\n        });\n      }\n\n    case 'removeByValue':\n      {\n        const [nodeValue] = payload;\n        return produce(currentModel, draft => {\n          const nodeToRemove = draft.find(({\n            value\n          }) => value === nodeValue);\n          if (nodeToRemove) nodeToRemove.visible = false;\n        });\n      }\n\n    case 'insert':\n      {\n        const [nodeData, previousNodeKey] = payload;\n        return produce(currentModel, draft => {\n          const newNodeIndex = draft.findIndex(({\n            key\n          }) => key === previousNodeKey) + 1;\n          draft.splice(newNodeIndex, 0, nodeData); // shift right every node in the right of the new node\n\n          const shiftedNodes = draft.slice(newNodeIndex + 1).map(currentModel => _objectSpread({}, currentModel, {\n            x: currentModel.x + 160\n          }));\n          draft.splice(newNodeIndex + 1, shiftedNodes.length, ...shiftedNodes);\n        });\n      }\n\n    case 'visited':\n      {\n        const [index] = payload;\n        return produce(currentModel, draft => {\n          draft[index].visited = true;\n        });\n      }\n\n    case 'focus':\n      {\n        const [key, keepOtherNodeFocus] = payload;\n        return produce(currentModel, draft => {\n          if (!keepOtherNodeFocus) draft.forEach(item => item.focus = false); // Nếu index === null nghĩa là đang unfocus tất cả các node\n\n          if (key !== null) {\n            const nodeToFocus = draft.find(({\n              key: nodeKey\n            }) => nodeKey === key);\n            if (nodeToFocus) nodeToFocus.focus = true;\n          }\n        });\n      }\n\n    case 'label':\n      {\n        const [label, nodeKeyToLabel, removeThisLabelInOtherNode] = payload;\n        return produce(currentModel, draft => {\n          if (removeThisLabelInOtherNode) {\n            draft.forEach(node => {\n              const oldLabel = node.label;\n\n              if (oldLabel) {\n                //@ts-ignore\n                const newLabel = oldLabel.filter(item => item !== label);\n                node.label = newLabel;\n              }\n            });\n          }\n\n          const nodeToLabel = draft.find(({\n            key\n          }) => key === nodeKeyToLabel);\n\n          if (nodeToLabel) {\n            const oldLabel = nodeToLabel.label || []; //@ts-ignore\n\n            nodeToLabel.label = oldLabel.concat(label);\n          }\n        });\n      }\n\n    case 'changePointer':\n      {\n        const [pointFrom, pointTo] = payload;\n        return produce(currentModel, draft => {\n          const nodeHolderPointer = draft.find(({\n            key\n          }) => key === pointFrom);\n\n          if (nodeHolderPointer) {\n            nodeHolderPointer.pointer = pointTo;\n          }\n        });\n      }\n\n    case 'resetAll':\n      {\n        // Reset focus, visited and label\n        const listTransformation = ['resetFocus', 'resetVisited', 'resetLabel'].map(method => model => transformLinkedListModel(model, method, []));\n        return _compose(listTransformation)(currentModel);\n      }\n\n    case 'resetFocus':\n      {\n        return produce(currentModel, draft => {\n          draft.forEach(item => item.focus = false);\n        });\n      }\n\n    case 'resetVisited':\n      {\n        return produce(currentModel, draft => {\n          draft.forEach(item => item.visited = false);\n        });\n      }\n\n    case 'resetLabel':\n      {\n        return produce(currentModel, draft => {\n          draft.forEach(item => item.label = []);\n        });\n      }\n\n    default:\n      return currentModel;\n  }\n};\n\nexport default transformLinkedListModel;","map":null,"metadata":{},"sourceType":"module"}