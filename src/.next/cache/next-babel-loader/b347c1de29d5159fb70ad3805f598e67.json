{"ast":null,"code":"import _groupBy from \"lodash/groupBy\";\nimport _pick from \"lodash/pick\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { Component } from 'react';\nimport withDSCore from 'hocs/withDSCore';\nimport KeyList from \"./KeyList\";\nimport HashFunction from \"./HashFunction\";\nimport MemoryArray from \"./MemoryArray\";\nimport HashTableHTML from \"./HashTableHTML\";\nimport HashIndicationArrow from \"./HashIndicationArrow\";\nimport transformHashTableModel from 'transformers/HashTable';\nimport { caculateKeyHash, initLinearProbeHashTableData } from \"./helper\";\nimport { HASH_TABLE_UNIVERSAL_KEY_SIZE } from \"../../constants\";\nexport class HashTableDS extends Component {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"wrapperRef\", void 0);\n\n    _defineProperty(this, \"delete\", (model, [key]) => {\n      const {\n        keyAboutToBeDeleted\n      } = this.state;\n      const {\n        updateModel\n      } = this.props;\n      this.setState({\n        keyAboutToBeDeleted: keyAboutToBeDeleted.concat(key)\n      });\n      setTimeout(() => {\n        // wait for the animation to finish\n        updateModel(transformHashTableModel(model, 'delete', [key]));\n      }, 1000);\n      return model;\n    });\n\n    _defineProperty(this, \"handlePointerLinkAnimationEnd\", (_key, _animationName) => {// const { model } = this.props;\n      // if (animationName === 'appear') {\n      //   this.setState({\n      //     hashTableModel: transformHashTableModel(hashTableModel, 'toggleIsNew', [\n      //       key,\n      //     ]),\n      //   });\n      // }\n    });\n\n    _defineProperty(this, \"injectHTMLIntoCanvas\", () => {\n      const {\n        handleExecuteApi,\n        dropdownDisabled,\n        model\n      } = this.props;\n      setTimeout(() => {\n        HashTableHTML.renderToView({\n          model,\n          wrapperElement: this.wrapperRef.current,\n          coordinate: _pick(this.props, ['x', 'y']),\n          apiHandler: handleExecuteApi,\n          disabled: dropdownDisabled\n        });\n      }, 0);\n    });\n\n    this.state = {\n      keyAboutToBeAdded: [],\n      keyAboutToBeDeleted: []\n    };\n    this.wrapperRef = React.createRef(); // Register custom transformer\n\n    props.registerCustomTransformer({\n      delete: this.delete\n    }); // Register HTML injector\n\n    props.registerHTMLInjector(this.injectHTMLIntoCanvas);\n  }\n\n  static initHashTableModel(props) {\n    const {\n      initialData,\n      collisionResolution\n    } = props;\n\n    switch (collisionResolution) {\n      case 'chaining':\n        {\n          const keys = Object.entries(initialData).map(([key, value]) => ({\n            key,\n            value,\n            address: caculateKeyHash(key, HASH_TABLE_UNIVERSAL_KEY_SIZE)\n          }));\n          return {\n            keys,\n            memoryAddresses: HashTableDS.produceMemoryAddressesFromKeys(keys)\n          };\n        }\n\n      case 'linearProbe':\n        {\n          return initLinearProbeHashTableData(initialData);\n        }\n    }\n  }\n\n  static produceMemoryAddressesFromKeys(keys) {\n    let memoryAddresses = keys.map(({\n      key,\n      value\n    }) => ({\n      key: caculateKeyHash(key, HASH_TABLE_UNIVERSAL_KEY_SIZE),\n      value\n    }));\n    return Object.entries(_groupBy(memoryAddresses, ({\n      key\n    }) => key)).map(([address, values]) => ({\n      key: +address,\n      values: values.map(({\n        value\n      }) => value) // highlight: address === '7',\n\n    }));\n  }\n\n  render() {\n    const {\n      keyAboutToBeDeleted,\n      keyAboutToBeAdded\n    } = this.state;\n    const {\n      model\n    } = this.props;\n    const {\n      collisionResolution\n    } = this.props;\n    return __jsx(React.Fragment, null, __jsx(\"use\", _extends({\n      href: \"#hashTable\"\n    }, _pick(this.props, ['x', 'y']))), __jsx(\"defs\", null, __jsx(\"g\", {\n      id: \"hashTable\",\n      ref: this.wrapperRef\n    }, __jsx(KeyList, {\n      hashTableModel: model\n    }), __jsx(HashFunction, null), __jsx(MemoryArray, {\n      hashTableModel: model,\n      keyAboutToBeDeleted: keyAboutToBeDeleted,\n      collisionResolution: collisionResolution\n    }), __jsx(HashIndicationArrow, {\n      hashTableModel: model,\n      onAnimationEnd: this.handlePointerLinkAnimationEnd,\n      keyAboutToBeDeleted: keyAboutToBeDeleted,\n      keyAboutToBeAdded: keyAboutToBeAdded\n    }))));\n  }\n\n}\nexport default withDSCore({\n  initModel: HashTableDS.initHashTableModel,\n  dataTransformer: transformHashTableModel\n})(HashTableDS);","map":null,"metadata":{},"sourceType":"module"}