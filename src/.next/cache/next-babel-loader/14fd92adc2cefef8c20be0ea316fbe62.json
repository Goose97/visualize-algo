{"ast":null,"code":"import _Reflect$construct from \"@babel/runtime-corejs2/core-js/reflect/construct\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime-corejs2/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime-corejs2/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nvar __jsx = React.createElement;\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(_Reflect$construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from 'react';\nvar DEFAULT_ANIMATION_DURATION = 700;\nvar STEP_COUNT = 80; // if max percent is 100 then the circle will disappear because start and end point are the same\n\nvar MAX_PERCENT = 97;\nexport var HighlightCircle = /*#__PURE__*/function (_Component) {\n  _inherits(HighlightCircle, _Component);\n\n  var _super = _createSuper(HighlightCircle);\n\n  function HighlightCircle(props) {\n    var _this;\n\n    _classCallCheck(this, HighlightCircle);\n\n    _this = _super.call(this, props); // This state's purpose is to make circling animation\n\n    _defineProperty(_assertThisInitialized(_this), \"kickStartAnimationInterval\", function () {\n      var animationDuration = _this.props.animationDuration;\n      var completePercent = _this.state.completePercent;\n      var duration = animationDuration || DEFAULT_ANIMATION_DURATION;\n      var stepInterval = duration / STEP_COUNT;\n      var percentIncreaseAtEachStep = 100 / STEP_COUNT;\n      var newPercent = Math.min(MAX_PERCENT, completePercent + percentIncreaseAtEachStep);\n\n      _this.setState({\n        completePercent: newPercent\n      }, function () {\n        if (_this.state.completePercent === MAX_PERCENT) return;\n        setTimeout(_this.kickStartAnimationInterval, stepInterval);\n      });\n    });\n\n    _this.state = {\n      completePercent: 0,\n      isAnimating: true\n    };\n    return _this;\n  }\n\n  _createClass(HighlightCircle, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.kickStartAnimationInterval();\n    }\n  }, {\n    key: \"caculateArcEndPointAndFlag\",\n    value: function caculateArcEndPointAndFlag() {\n      // We will cover each section of the circle one by one\n      var completePercent = this.state.completePercent;\n      var radius = this.props.radius;\n      var deltaX;\n      var deltaY;\n\n      if (completePercent <= 25) {\n        var angle = completePercent / 25 * Math.PI / 2;\n        deltaX = Math.sin(angle) * radius;\n        deltaY = (1 - Math.cos(angle)) * radius;\n      } else if (completePercent <= 50) {\n        var _angle = (completePercent - 25) / 25 * Math.PI / 2;\n\n        deltaX = Math.cos(_angle) * radius;\n        deltaY = (1 + Math.sin(_angle)) * radius;\n      } else if (completePercent <= 75) {\n        var _angle2 = (completePercent - 50) / 25 * Math.PI / 2;\n\n        deltaX = -Math.sin(_angle2) * radius;\n        deltaY = (1 + Math.cos(_angle2)) * radius;\n      } else {\n        var _angle3 = (completePercent - 75) / 25 * Math.PI / 2;\n\n        deltaX = -Math.cos(_angle3) * radius;\n        deltaY = (1 - Math.sin(_angle3)) * radius;\n      }\n\n      return {\n        x: deltaX,\n        y: deltaY,\n        largeArcFlag: completePercent >= 50 ? 1 : 0\n      };\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          x = _this$props.x,\n          y = _this$props.y,\n          radius = _this$props.radius;\n\n      var _this$caculateArcEndP = this.caculateArcEndPointAndFlag(),\n          endX = _this$caculateArcEndP.x,\n          endY = _this$caculateArcEndP.y,\n          largeArcFlag = _this$caculateArcEndP.largeArcFlag;\n\n      return __jsx(\"path\", {\n        className: \"highlight-circle\",\n        d: \"M \".concat(x, \" \").concat(y - radius, \" a \").concat(radius, \" \").concat(radius, \" 0 \").concat(largeArcFlag, \" 1 \").concat(endX, \" \").concat(endY)\n      });\n    }\n  }]);\n\n  return HighlightCircle;\n}(Component);\nexport default HighlightCircle;","map":null,"metadata":{},"sourceType":"module"}