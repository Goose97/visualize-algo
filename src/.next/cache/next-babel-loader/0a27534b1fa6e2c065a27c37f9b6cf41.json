{"ast":null,"code":"import _isFunction from \"lodash/isFunction\";\nimport _omit from \"lodash/omit\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React, { Component } from 'react';\nimport withExtendClassName from 'hocs/withExtendClassName';\nimport { classNameHelper } from 'utils';\nexport class PointerLink extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      // We will use this offset to animate\n      transformList: this.produceInitialTransformList()\n    };\n  }\n\n  produceInitialTransformList() {\n    const {\n      transform\n    } = this.props;\n\n    if (transform) {\n      const regexMatch = transform.match(/(rotate|translate)\\(.+\\)/g);\n      return regexMatch ? regexMatch : [];\n    } else {\n      return [];\n    }\n  }\n\n  produceClassName() {\n    const {\n      visited,\n      highlight,\n      following,\n      className,\n      visible,\n      blur\n    } = this.props;\n    return classNameHelper({\n      base: [className, 'pointer-link has-transition'].filter(item => item).join(' '),\n      disappearing: visible === false,\n      visited: !!visited,\n      following: !!following,\n      highlight: !!highlight,\n      blur: !!blur\n    });\n  }\n\n  renderMainPointerLink() {\n    const {\n      path,\n      isNew,\n      animationDuration,\n      onAnimationEnd,\n      highlight\n    } = this.props;\n    const fullPathWithArrow = `${path} ${this.produceArrowPath()}`;\n    const className = classNameHelper({\n      base: 'pointer-link__line',\n      ['animated-path']: !!isNew,\n      highlight: !!highlight\n    });\n    return __jsx(\"path\", {\n      d: fullPathWithArrow,\n      className: className,\n      style: {\n        animationDuration\n      },\n      onAnimationEnd: () => _isFunction(onAnimationEnd) && onAnimationEnd('appear')\n    });\n  }\n\n  produceFullPathWithArrow() {\n    const {\n      path\n    } = this.props;\n    return `${path} ${this.produceArrowPath()}`;\n  }\n\n  produceArrowPath() {\n    const {\n      arrowDirection\n    } = this.props;\n\n    switch (arrowDirection) {\n      case 'right':\n        return 'l -2 2 l 8 -2 l -8 -2 l 2 2';\n\n      case 'left':\n        return 'l 2 2 l -8 -2 l 8 -2 l -2 2';\n\n      case 'up':\n        return 'l 2 2 l -2 -8 l -2 8 l 2 -2';\n\n      default:\n        return '';\n    }\n  }\n\n  produceStartPointMark() {\n    const {\n      path,\n      visited,\n      following\n    } = this.props;\n    const regex = /^M (\\d+) (\\d+)/;\n    const startPoint = path === null || path === void 0 ? void 0 : path.match(regex);\n\n    if (startPoint) {\n      const className = classNameHelper({\n        base: 'pointer-link__start-dot',\n        follow: !!following,\n        visited: !!visited\n      });\n      return __jsx(\"circle\", {\n        cx: startPoint[1],\n        cy: startPoint[2],\n        r: \"2\",\n        className: className\n      });\n    } else return null;\n  }\n\n  renderFocusMaskOnPointerLink() {\n    // Just a layer of pointer link of top of the original one\n    // Create a effect of highlight when focus\n    const {\n      isNew,\n      following\n    } = this.props;\n    const shouldRender = following && !isNew;\n    const compoundClassName = classNameHelper({\n      // base: [className, 'pointer-link__line'].filter(item => !item).join(' '),\n      base: 'pointer-link__line',\n      ['follow animated-path']: !!following\n    });\n    return shouldRender && __jsx(\"path\", {\n      d: this.produceFullPathWithArrow(),\n      className: compoundClassName\n    });\n  }\n\n  render() {\n    const propsToOmit = ['arrowDirection', 'following', 'visited', 'visible', 'isNew', 'animationDuration', 'onAnimationEnd', 'highlight', 'blur'];\n    return (//@ts-ignore\n      __jsx(\"g\", _extends({}, _omit(this.props, propsToOmit), {\n        className: this.produceClassName()\n      }), this.renderFocusMaskOnPointerLink(), this.renderMainPointerLink(), this.produceStartPointMark())\n    );\n  }\n\n}\nexport default withExtendClassName('')(PointerLink);","map":null,"metadata":{},"sourceType":"module"}