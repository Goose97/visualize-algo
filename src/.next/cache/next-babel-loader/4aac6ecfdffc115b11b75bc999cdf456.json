{"ast":null,"code":"var searchCode = \"function search(data) {\\n  let current = this.root;\\n  while (current !== null) {\\n    if (current.data === data) {\\n      // Found the element!\\n      return current;\\n    } else if (data < current.data) {\\n      // Go Left as data is smaller than parent\\n      current = current.left;\\n    } else {\\n      // Go right as data is greater than parent\\n      current = current.right;\\n    }\\n  }\\n\\n  // Not found the element\\n  return null;\\n}\";\nvar insertCode = \"function insert(value) {\\n  let newNode = new BinarySearchTreeNode(value); // { val: value, left: null, right: null }\\n  if (this.root === null) {\\n    this.root = newNode;\\n  } else {\\n    this.insertHelper(this.root, newNode);\\n  }\\n}\\n\\nfunction insertHelper(currentNode, newNode) {\\n  // If the value is less than the current node value move left of the tree\\n  if (newNode.data < currentNode.data) {\\n    // If left is null insert node here\\n    if (currentNode.left === null) currentNode.left = newNode;\\n    // If left is not null recurr until null is found\\n    else insertHelper(currentNode.left, newNode);\\n  }\\n  // If the value is greater than the current node value move right of the tree\\n  else {\\n    // if right is null insert node here\\n    if (currentNode.right === null) currentNode.right = newNode;\\n    // if right is not null recurr until null is found\\n    else insertHelper(currentNode.right, newNode);\\n  }\\n}\";\nvar deleteCode = \"function delete(value) {\\n  // Find node to delete\\n  let nodeToDelete = this.search(value);\\n\\n  // If can't find node to delete, return root\\n  if (!nodeToDelete) return this.root;\\n\\n  // If node has no child, just delete it\\n  // parent.left = null or parent.right = null\\n\\n  // If node has one children, copy value of child then delete the child\\n  let onlyChild = nodeToDelete.left || nodeToDelete.right;\\n  nodeToDelete.val = onlyChild.val;\\n  if (nodeToDelete.left) nodeToDelete.left = null;\\n  else nodeToDelete.right = null;\\n\\n  // If node has two children, find its predecessor (biggest node in the left subtree)\\n  // Copy its value then delete it\\n  let [predecessor, parentOfPredecessor] = this.findPredecessor(nodeToDelete);\\n  nodeToDelete.val = predecessor.delete;\\n  parentOfPredecessor.right = null;\\n}\";\nexport var code = {\n  search: searchCode,\n  insert: insertCode,\n  \"delete\": deleteCode,\n  preorder: '',\n  inorder: '',\n  postorder: ''\n};\nexport var explanation = {\n  search: ['Khởi tạo biến lưu node hiện tại với giá trị ban đầu là root của binary search tree', 'So sánh giá trị đang tìm kiếm với giá trị của node hiện tại', 'Nếu bằng thì trả về node hiện tại', 'Nếu nhỏ hơn thì đặt current = current.left (tiếp tục tìm kiếm ở bên trái)', 'Nếu lớn hơn thì đặt current = current.right (tiếp tục tìm kiếm ở bên phải)', 'Nếu kết thúc vòng loop mà vẫn chưa tìm thấy value thì trả về null'],\n  insert: ['Khởi tạo node mới và lưu vào biến newNode', 'Nếu root chưa tồn tại thì đặt root là node mới tạo', 'Nếu không thì đệ quy bắt đầu từ root để tìm vị trí insert', 'Nếu giá trị cần insert nhỏ hơn giá node hiện tại thì insert nếu còn chỗ (currentNode.left === null), nếu không tiếp tục đệ quy với node con bên trái', 'Nếu giá trị cần insert lớn hơn giá node hiện tại thì insert nếu còn chỗ (currentNode.right === null), nếu không tiếp tục đệ quy với node con bên phải'],\n  \"delete\": ['Tìm kiếm node cần xoá', 'Nếu node cần xoá không có children (là leaf node) thì chỉ cần xoá node đó đi', 'Nếu node cần xoá có 1 children sao chép giá trị của child sang node cần xoá rồi xoá child đi', 'Nếu node cần xoá có 2 children thì tìm node lớn nhất ở nhánh trái hoặc node nhỏ nhất của nhánh phải, sao chép giá trị sang node cần xoá rồi xoá node ấy']\n};","map":null,"metadata":{},"sourceType":"module"}