{"ast":null,"code":"import _pick from \"lodash/pick\";\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport BezierEasing from 'bezier-easing';\nimport { GRAPH_NODE_RADIUS } from \"../constants\";\nexport const classNameHelper = object => {\n  let baseClassName = object.base || '';\n  Object.entries(object).forEach(([key, value]) => {\n    if (key === 'base') return;\n    if (!!value) baseClassName += ` ${key}`;\n  });\n  return baseClassName;\n};\nexport const produceFullState = (stepDescription, stateProperties) => {\n  let result = [];\n\n  for (let i = 0; i < stepDescription.length; i++) {\n    let currentState = _pick(stepDescription[i], stateProperties);\n\n    if (i !== 0) currentState = Object.assign({}, result[i - 1], currentState);\n    result.push(currentState);\n  }\n\n  return result;\n};\nexport function promiseSetState(newState) {\n  //@ts-ignore\n  return new Promise(resolve => this.setState(newState, () => resolve()));\n}\nexport const compactObject = object => {\n  for (let property in object) {\n    if (object.hasOwnProperty(property)) {\n      if (object[property] === undefined || object[property] === null) delete object[property];\n    }\n  }\n\n  return object;\n};\nexport const getProgressDirection = (currentStep, previousStep, totalStep, switchingApi) => {\n  if (switchingApi) return 'switch';\n  if (previousStep === undefined) return 'forward';\n  if (currentStep === previousStep) return 'stay';\n\n  if (currentStep > previousStep) {\n    if (currentStep - previousStep === 1) return 'forward';else if (currentStep === totalStep) return 'fastForward';\n  } else {\n    if (previousStep - currentStep === 1) return 'backward';else if (currentStep === 0) return 'fastBackward';\n  }\n};\nexport const upcaseFirstLetterAndSplit = string => {\n  const regex = /[A-Z]/g;\n  let result = string.replace(regex, value => ` ${value}`);\n  return result[0].toUpperCase() + result.slice(1);\n};\nexport const keyExist = (object, keys) => {\n  return keys.every(key => key in object);\n};\nexport const extractInstructionFromDescription = (description, dsName) => {\n  return description.map(({\n    actions\n  }) => {\n    if (!actions) return [];\n    if (!actions[dsName]) return [];\n    return actions[dsName];\n  });\n};\nexport const caculatePointerPathFromTwoNodeCenter = (nodeACenter, nodeBCenter, radius, noArrow) => {\n  const angle = caculateAngleOfLine(nodeACenter, nodeBCenter);\n  const contactPointWithA = {\n    x: nodeACenter.x + Math.cos(angle) * radius,\n    y: nodeACenter.y + Math.sin(angle) * radius\n  };\n  const length = caculateLength(nodeACenter, nodeBCenter) - 2 * GRAPH_NODE_RADIUS;\n  const offsetForArrow = noArrow ? 0 : 6;\n  const path = `M ${contactPointWithA.x} ${contactPointWithA.y} h ${length - offsetForArrow}`;\n  const transform = `rotate(${angle / Math.PI * 180} ${contactPointWithA.x} ${contactPointWithA.y})`;\n  return {\n    path,\n    transform\n  };\n};\n\nconst caculateLength = (pointA, pointB) => {\n  return Math.sqrt((pointA.x - pointB.x) ** 2 + (pointA.y - pointB.y) ** 2);\n};\n\nconst caculateAngleOfLine = (start, finish) => {\n  const deltaX = finish.x - start.x;\n  const deltaY = finish.y - start.y;\n  let tan = deltaY / deltaX;\n\n  if (finish.x >= start.x) {\n    return Math.atan(tan);\n  } else {\n    return Math.atan(tan) > 0 ? Math.atan(tan) - Math.PI : Math.atan(tan) + Math.PI;\n  }\n};\n\nexport const caculateDistanceToALine = (pointA, pointB, pointC) => {\n  // Distance from A to BC\n  const ab = caculateLength(pointA, pointB);\n  const bc = caculateLength(pointB, pointC);\n  const ca = caculateLength(pointC, pointA); // Caculate triangle area use Heron's formula\n\n  const s = (ab + bc + ca) / 2;\n  const area = Math.sqrt(s * (s - ab) * (s - bc) * (s - ca));\n  return area * 2 / bc;\n};\nexport const performAnimation = params => {\n  const {\n    duration,\n    callback,\n    endValue,\n    startValue\n  } = params;\n  const cubicBezierFunction = params.cubicBezierFunction || BezierEasing(0.25, 0.1, 0.25, 1);\n  const originTime = performance.now();\n\n  const updateValueThroughFrame = () => {\n    window.requestAnimationFrame(currentTime => {\n      const timeProgress = (currentTime - originTime) / duration;\n      const animationProgess = timeProgress > 1 ? 1 : cubicBezierFunction(timeProgress);\n      if (animationProgess >= 1) callback(endValue);else {\n        const currentValue = animationProgess * (endValue - startValue) + startValue;\n        callback(currentValue);\n        updateValueThroughFrame();\n      }\n    });\n  };\n\n  updateValueThroughFrame();\n};\nexport const getCanvasScaleFactor = () => {\n  try {\n    const canvasContainer = document.querySelector('.canvas-container'); //@ts-ignore\n\n    return parseFloat((canvasContainer === null || canvasContainer === void 0 ? void 0 : canvasContainer.getAttribute('scale-factor')) || 1);\n  } catch (e) {\n    console.log(e);\n    return 1;\n  }\n};\nexport class AnimationTaskQueue {\n  constructor(initObject) {\n    _defineProperty(this, \"taskQueue\", void 0);\n\n    _defineProperty(this, \"isRunning\", void 0);\n\n    _defineProperty(this, \"callback\", void 0);\n\n    _defineProperty(this, \"isAdditive\", void 0);\n\n    _defineProperty(this, \"taskQueueMax\", void 0);\n\n    _defineProperty(this, \"combineTaskCallback\", void 0);\n\n    const {\n      callback,\n      isAdditiveTask,\n      combineTaskCallback,\n      taskQueueMax\n    } = initObject;\n    this.taskQueue = [];\n    this.isRunning = false;\n    this.callback = callback;\n    this.isAdditive = isAdditiveTask;\n    this.combineTaskCallback = combineTaskCallback;\n    this.taskQueueMax = taskQueueMax || 2;\n  }\n\n  enqueue(task) {\n    this.taskQueue.push(task);\n\n    if (!this.isRunning) {\n      this.isRunning = true;\n      this.dequeue();\n    }\n  } // Drop some tasks if tasks fill up too fast\n  // If task is additive (meaning drop task will alter result), we must combine many task into one\n\n\n  dequeue() {\n    if (this.taskQueue.length > this.taskQueueMax) this.discardTasks();\n    const nextTask = this.taskQueue.shift();\n\n    if (!nextTask) {\n      this.isRunning = false;\n      return;\n    }\n\n    window.requestAnimationFrame(() => {\n      this.callback(nextTask);\n      this.dequeue();\n    });\n  }\n\n  discardTasks() {\n    // if task is additive, must combine them\n    // otherwise just drop them\n    if (this.isAdditive) {\n      const discardTasks = this.taskQueue.splice(0, this.taskQueueMax);\n      const combinedTask = this.combineTaskCallback(discardTasks);\n      this.taskQueue.unshift(combinedTask);\n    } else {\n      this.taskQueue.splice(0, this.taskQueueMax);\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}