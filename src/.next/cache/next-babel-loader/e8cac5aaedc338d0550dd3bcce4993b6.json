{"ast":null,"code":"import _isEqual from \"lodash/isEqual\";\nvar __jsx = React.createElement;\nimport React, { Component } from 'react';\nimport { produce } from 'immer';\nimport { MemoryBlock, LinkedListDS, PointerLink } from 'components';\nimport { caculateKeyHash } from \"./helper\";\nimport { HASH_TABLE_UNIVERSAL_KEY_SIZE, ARRAY_BLOCK_WIDTH, ARRAY_BLOCK_HEIGHT, HASH_TABLE_ARRAY_X } from \"../../constants\";\nexport class MemoryArray extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      linkedListInstructionAndStep: {}\n    };\n  }\n\n  componentDidUpdate(prevProps) {\n    const {\n      keyAboutToBeDeleted\n    } = this.props;\n\n    if (!_isEqual(keyAboutToBeDeleted, prevProps.keyAboutToBeDeleted)) {\n      this.checkKeyToDelete(prevProps.keyAboutToBeDeleted, keyAboutToBeDeleted);\n    }\n  }\n\n  checkKeyToDelete(prevKeyToDelete, currentKeyToDelete) {\n    const {\n      linkedListInstructionAndStep\n    } = this.state;\n    const keyToDelete = currentKeyToDelete.find(key => !prevKeyToDelete.includes(key));\n\n    if (keyToDelete !== undefined) {\n      const hashValue = caculateKeyHash(keyToDelete, HASH_TABLE_UNIVERSAL_KEY_SIZE);\n      const newState = produce(linkedListInstructionAndStep, draft => {\n        const oldInstructions = draft[hashValue] && draft[hashValue].instructions || [];\n        const newInstructions = [...oldInstructions, [{\n          name: 'removeByValue',\n          params: [this.getValueOfKey(keyToDelete)]\n        }]];\n        const oldCurrentStep = draft[hashValue] && draft[hashValue].currentStep;\n        const newCurrentStep = oldCurrentStep !== undefined ? oldCurrentStep + 1 : 0;\n        draft[hashValue] = {\n          instructions: newInstructions,\n          currentStep: newCurrentStep\n        };\n      });\n      this.setState({\n        linkedListInstructionAndStep: newState\n      });\n    }\n  }\n\n  getValueOfKey(keyToFind) {\n    const {\n      hashTableModel\n    } = this.props;\n    return hashTableModel.keys.find(({\n      key\n    }) => key === keyToFind).value;\n  }\n\n  renderListMemoryBlock() {\n    const {\n      collisionResolution\n    } = this.props;\n    return __jsx(\"g\", {\n      className: \"hash-table__memory-blocks\"\n    }, Array(HASH_TABLE_UNIVERSAL_KEY_SIZE).fill(0).map((_, index) => {\n      const blur = this.shouldThisAddressBlur(index);\n      return __jsx(\"g\", {\n        className: `hash-table__memory-block${blur ? ' blur' : ''}`,\n        key: index\n      }, __jsx(MemoryBlock, {\n        width: ARRAY_BLOCK_WIDTH,\n        height: ARRAY_BLOCK_HEIGHT,\n        x: HASH_TABLE_ARRAY_X,\n        y: index * ARRAY_BLOCK_HEIGHT,\n        value: collisionResolution === 'linearProbe' ? this.getValueAtAddress(index) : null,\n        visible: true,\n        type: \"rectangle\",\n        labelDirection: \"left\",\n        label: [index.toString()]\n      }), collisionResolution === 'chaining' && this.renderLinkedListAtAddress(index));\n    }));\n  }\n\n  getValueAtAddress(address) {\n    var _hashTableModel$memor;\n\n    const {\n      hashTableModel\n    } = this.props;\n    return ((_hashTableModel$memor = hashTableModel.memoryAddresses.find(({\n      key\n    }) => key === address)) === null || _hashTableModel$memor === void 0 ? void 0 : _hashTableModel$memor.values[0]) || null;\n  }\n\n  shouldThisAddressBlur(address) {\n    const {\n      hashTableModel\n    } = this.props;\n    const hasAddressNeedHighlight = hashTableModel.memoryAddresses.some(({\n      highlight\n    }) => highlight);\n    if (!hasAddressNeedHighlight) return false;\n    const currentAddress = hashTableModel.memoryAddresses.find(({\n      key\n    }) => key === address);\n    return !(currentAddress === null || currentAddress === void 0 ? void 0 : currentAddress.highlight);\n  }\n\n  getLabelAndValueProps(value, address) {\n    const {\n      collisionResolution\n    } = this.props;\n\n    switch (collisionResolution) {\n      case 'chaining':\n        {\n          return {\n            labelDirection: 'left',\n            label: [address.toString()],\n            value: null\n          };\n        }\n\n      case 'linearProbe':\n        {\n          return {\n            label: [{\n              value: address.toString(),\n              direction: 'left'\n            }, {\n              value: address.toString(),\n              direction: 'right'\n            }],\n            value\n          };\n        }\n    }\n  }\n\n  renderLinkedListAtAddress(address) {\n    const {\n      hashTableModel\n    } = this.props;\n    const memoryAddress = hashTableModel.memoryAddresses.find(({\n      key\n    }) => key == address);\n    if (!memoryAddress) return null;\n    if (!memoryAddress.values.length) return null;\n    return __jsx(React.Fragment, null, this.renderPointerLinkToLinkedList(+address), __jsx(LinkedListDS, {\n      key: address,\n      x: HASH_TABLE_ARRAY_X + ARRAY_BLOCK_WIDTH + 50,\n      y: +address * ARRAY_BLOCK_HEIGHT + 5,\n      instructions: [],\n      data: memoryAddress.values,\n      controlled: true // {...linkedListInstructionAndStep[address]}\n      ,\n      totalStep: 10\n    }));\n  }\n\n  renderPointerLinkToLinkedList(address) {\n    return __jsx(PointerLink, {\n      path: `M ${HASH_TABLE_ARRAY_X + ARRAY_BLOCK_WIDTH / 2} ${+address * ARRAY_BLOCK_HEIGHT + ARRAY_BLOCK_HEIGHT / 2} H ${HASH_TABLE_ARRAY_X + ARRAY_BLOCK_WIDTH + 50 - 6}`,\n      arrowDirection: \"right\"\n    });\n  }\n\n  render() {\n    return this.renderListMemoryBlock();\n  }\n\n}\nexport default MemoryArray;","map":null,"metadata":{},"sourceType":"module"}