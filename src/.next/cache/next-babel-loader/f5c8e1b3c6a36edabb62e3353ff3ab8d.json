{"ast":null,"code":"import _Reflect$construct from \"@babel/runtime-corejs2/core-js/reflect/construct\";\nimport _Object$entries from \"@babel/runtime-corejs2/core-js/object/entries\";\nimport _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime-corejs2/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime-corejs2/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport _groupBy from \"lodash/groupBy\";\nimport _pick from \"lodash/pick\";\nvar __jsx = React.createElement;\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(_Reflect$construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from 'react';\nimport withDSCore from 'hocs/withDSCore';\nimport KeyList from \"./KeyList\";\nimport HashFunction from \"./HashFunction\";\nimport MemoryArray from \"./MemoryArray\";\nimport HashTableHTML from \"./HashTableHTML\";\nimport HashIndicationArrow from \"./HashIndicationArrow\";\nimport transformHashTableModel from 'transformers/HashTable';\nimport { caculateKeyHash, initLinearProbeHashTableData } from \"./helper\";\nimport { HASH_TABLE_UNIVERSAL_KEY_SIZE } from \"../../constants\";\nexport var HashTableDS = /*#__PURE__*/function (_Component) {\n  _inherits(HashTableDS, _Component);\n\n  var _super = _createSuper(HashTableDS);\n\n  function HashTableDS(props) {\n    var _this;\n\n    _classCallCheck(this, HashTableDS);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"wrapperRef\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"delete\", function (model, _ref) {\n      var _ref2 = _slicedToArray(_ref, 1),\n          key = _ref2[0];\n\n      var keyAboutToBeDeleted = _this.state.keyAboutToBeDeleted;\n      var updateModel = _this.props.updateModel;\n\n      _this.setState({\n        keyAboutToBeDeleted: keyAboutToBeDeleted.concat(key)\n      });\n\n      setTimeout(function () {\n        // wait for the animation to finish\n        updateModel(transformHashTableModel(model, 'delete', [key]));\n      }, 1000);\n      return model;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handlePointerLinkAnimationEnd\", function (_key, _animationName) {// const { model } = this.props;\n      // if (animationName === 'appear') {\n      //   this.setState({\n      //     hashTableModel: transformHashTableModel(hashTableModel, 'toggleIsNew', [\n      //       key,\n      //     ]),\n      //   });\n      // }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"injectHTMLIntoCanvas\", function () {\n      var _this$props = _this.props,\n          handleExecuteApi = _this$props.handleExecuteApi,\n          dropdownDisabled = _this$props.dropdownDisabled,\n          model = _this$props.model;\n      setTimeout(function () {\n        HashTableHTML.renderToView({\n          model: model,\n          wrapperElement: _this.wrapperRef.current,\n          coordinate: _pick(_this.props, ['x', 'y']),\n          apiHandler: handleExecuteApi,\n          disabled: dropdownDisabled\n        });\n      }, 0);\n    });\n\n    _this.state = {\n      keyAboutToBeAdded: [],\n      keyAboutToBeDeleted: []\n    };\n    _this.wrapperRef = React.createRef(); // Register custom transformer\n\n    props.registerCustomTransformer({\n      \"delete\": _this[\"delete\"]\n    }); // Register HTML injector\n\n    props.registerHTMLInjector(_this.injectHTMLIntoCanvas);\n    return _this;\n  }\n\n  _createClass(HashTableDS, [{\n    key: \"render\",\n    value: function render() {\n      var _this$state = this.state,\n          keyAboutToBeDeleted = _this$state.keyAboutToBeDeleted,\n          keyAboutToBeAdded = _this$state.keyAboutToBeAdded;\n      var model = this.props.model;\n      var collisionResolution = this.props.collisionResolution;\n      return __jsx(React.Fragment, null, __jsx(\"use\", _extends({\n        href: \"#hashTable\"\n      }, _pick(this.props, ['x', 'y']))), __jsx(\"defs\", null, __jsx(\"g\", {\n        id: \"hashTable\",\n        ref: this.wrapperRef\n      }, __jsx(KeyList, {\n        hashTableModel: model\n      }), __jsx(HashFunction, null), __jsx(MemoryArray, {\n        hashTableModel: model,\n        keyAboutToBeDeleted: keyAboutToBeDeleted,\n        collisionResolution: collisionResolution\n      }), __jsx(HashIndicationArrow, {\n        hashTableModel: model,\n        onAnimationEnd: this.handlePointerLinkAnimationEnd,\n        keyAboutToBeDeleted: keyAboutToBeDeleted,\n        keyAboutToBeAdded: keyAboutToBeAdded\n      }))));\n    }\n  }], [{\n    key: \"initHashTableModel\",\n    value: function initHashTableModel(props) {\n      var initialData = props.initialData,\n          collisionResolution = props.collisionResolution;\n\n      switch (collisionResolution) {\n        case 'chaining':\n          {\n            var keys = _Object$entries(initialData).map(function (_ref3) {\n              var _ref4 = _slicedToArray(_ref3, 2),\n                  key = _ref4[0],\n                  value = _ref4[1];\n\n              return {\n                key: key,\n                value: value,\n                address: caculateKeyHash(key, HASH_TABLE_UNIVERSAL_KEY_SIZE)\n              };\n            });\n\n            return {\n              keys: keys,\n              memoryAddresses: HashTableDS.produceMemoryAddressesFromKeys(keys)\n            };\n          }\n\n        case 'linearProbe':\n          {\n            return initLinearProbeHashTableData(initialData);\n          }\n      }\n    }\n  }, {\n    key: \"produceMemoryAddressesFromKeys\",\n    value: function produceMemoryAddressesFromKeys(keys) {\n      var memoryAddresses = keys.map(function (_ref5) {\n        var key = _ref5.key,\n            value = _ref5.value;\n        return {\n          key: caculateKeyHash(key, HASH_TABLE_UNIVERSAL_KEY_SIZE),\n          value: value\n        };\n      });\n      return _Object$entries(_groupBy(memoryAddresses, function (_ref6) {\n        var key = _ref6.key;\n        return key;\n      })).map(function (_ref7) {\n        var _ref8 = _slicedToArray(_ref7, 2),\n            address = _ref8[0],\n            values = _ref8[1];\n\n        return {\n          key: +address,\n          values: values.map(function (_ref9) {\n            var value = _ref9.value;\n            return value;\n          }) // highlight: address === '7',\n\n        };\n      });\n    }\n  }]);\n\n  return HashTableDS;\n}(Component);\nexport default withDSCore({\n  initModel: HashTableDS.initHashTableModel,\n  dataTransformer: transformHashTableModel\n})(HashTableDS);","map":null,"metadata":{},"sourceType":"module"}