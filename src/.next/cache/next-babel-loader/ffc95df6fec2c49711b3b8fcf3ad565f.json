{"ast":null,"code":"import _pick from \"lodash/pick\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { Component } from 'react';\nimport { MemoryBlock, AutoTransformGroup } from 'components';\nimport { ARRAY_BLOCK_WIDTH, ARRAY_BLOCK_HEIGHT, ARRAY_COLUMN_GAP, ARRAY_COLUMN_HEIGHT, ARRAY_COLUMN_HEIGHT_BASE, LINE_HEIGHT } from \"../../constants\";\n\nclass ArrayMemoryBlock extends Component {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"initialCoordinate\", void 0);\n\n    this.initialCoordinate = this.calculatePosition();\n  }\n\n  calculatePosition() {\n    const {\n      index,\n      blockType,\n      value,\n      isInsertionSorting\n    } = this.props;\n    const {\n      height\n    } = this.calculateSizeBlock(blockType, this.parseValueToNumber(value));\n    let xPosition = 0;\n    let yPosition = isInsertionSorting ? 100 : 0;\n\n    switch (blockType) {\n      case 'block':\n        xPosition = ARRAY_BLOCK_WIDTH * index;\n        break;\n\n      case 'column':\n        xPosition = (ARRAY_BLOCK_WIDTH + ARRAY_COLUMN_GAP) * index;\n        yPosition = -height;\n        break;\n    }\n\n    return {\n      x: xPosition,\n      y: yPosition\n    };\n  }\n\n  parseValueToNumber(value) {\n    if (!value) return 0;\n    if (typeof value === 'string') return parseInt(value);\n    return value;\n  }\n\n  calculateLine() {\n    const {\n      index\n    } = this.props;\n    let x1, y1, x2, y2;\n    x1 = ARRAY_BLOCK_WIDTH * (index + 1);\n    y1 = ARRAY_BLOCK_HEIGHT + LINE_HEIGHT;\n    x2 = x1;\n    y2 = -LINE_HEIGHT;\n    return {\n      x1: x1,\n      y1: y1,\n      x2: x2,\n      y2: y2\n    };\n  }\n\n  calculateSizeBlock(blockType, value) {\n    let height = 0;\n\n    switch (blockType) {\n      case 'block':\n        height = ARRAY_BLOCK_HEIGHT;\n        break;\n\n      case 'column':\n        height = ARRAY_COLUMN_HEIGHT * value + ARRAY_COLUMN_HEIGHT_BASE;\n        break;\n    }\n\n    return {\n      width: ARRAY_BLOCK_WIDTH,\n      height\n    };\n  }\n\n  render() {\n    const {\n      value,\n      visible,\n      blockType\n    } = this.props;\n    const propsToPass = ['focus', 'visited', 'label', 'className', 'highlight', 'blur', 'transform', 'labelDirection'];\n    return __jsx(AutoTransformGroup, {\n      origin: this.calculatePosition()\n    }, __jsx(MemoryBlock, _extends({}, this.initialCoordinate, this.calculateSizeBlock(blockType, this.parseValueToNumber(value)), {\n      type: \"rectangle\"\n    }, _pick(this.props, propsToPass), {\n      visible: !!visible,\n      value: value\n    })));\n  }\n\n}\n\nexport default ArrayMemoryBlock;","map":null,"metadata":{},"sourceType":"module"}