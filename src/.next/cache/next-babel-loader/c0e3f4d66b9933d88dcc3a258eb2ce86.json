{"ast":null,"code":"import _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nvar DEFAULT_DURATION = 1500;\nexport var Instructions = /*#__PURE__*/function () {\n  function Instructions() {\n    _classCallCheck(this, Instructions);\n\n    _defineProperty(this, \"instructions\", void 0);\n\n    this.instructions = [];\n  }\n\n  _createClass(Instructions, [{\n    key: \"push\",\n    value: function push(instruction) {\n      var newInstruction = _Object$assign({\n        duration: DEFAULT_DURATION\n      }, instruction);\n\n      this.instructions.push(newInstruction);\n    }\n  }, {\n    key: \"get\",\n    value: function get() {\n      return this.instructions;\n    }\n  }]);\n\n  return Instructions;\n}();\nexport var BinarySearchTree = /*#__PURE__*/function () {\n  function BinarySearchTree() {\n    _classCallCheck(this, BinarySearchTree);\n\n    _defineProperty(this, \"root\", void 0);\n\n    _defineProperty(this, \"key\", void 0);\n\n    this.root = null;\n    this.key = 0;\n  } // Insert a value as a node in the BST\n\n\n  _createClass(BinarySearchTree, [{\n    key: \"insert\",\n    value: function insert(value) {\n      var newNode = new BinaryTreeNode(value, this.key++); // If root empty, set new node as the root\n\n      if (!this.root) {\n        this.root = newNode;\n      } else {\n        this.insertNode(this.root, newNode);\n      }\n    } // helper function\n\n  }, {\n    key: \"insertNode\",\n    value: function insertNode(root, newNode) {\n      if (newNode.val < root.val) {\n        // If no left child, then just insesrt to the left\n        if (!root.left) {\n          root.left = newNode;\n        } else {\n          this.insertNode(root.left, newNode);\n        }\n      } else {\n        // If no right child, then just insesrt to the right\n        if (!root.right) {\n          root.right = newNode;\n        } else {\n          this.insertNode(root.right, newNode);\n        }\n      }\n    } // Remove a node with the value passed\n\n  }, {\n    key: \"remove\",\n    value: function remove(value) {\n      if (!this.root) {\n        return 'Tree is empty!';\n      } else {\n        this.removeNode(this.root, value);\n      }\n    } // helper function\n\n  }, {\n    key: \"removeNode\",\n    value: function removeNode(root, value) {\n      if (!root) {\n        return null;\n      } // If value is less than root value, go to the left subtree\n\n\n      if (value < root.val) {\n        root.left = this.removeNode(root.left, value);\n        return root; // If value is greater than root value, go to the right subtree\n      } else if (value > root.val) {\n        root.right = this.removeNode(root.right, value);\n        return root; // If we found the value, remove the node\n      } else {\n        // If no child nodes, just remove the node\n        if (!root.left && !root.right) {\n          root = null;\n          return root;\n        } // If one child (left)\n\n\n        if (root.left) {\n          root = root.left;\n          return root; // If one child (right)\n        } else if (root.right) {\n          root = root.right;\n          return root;\n        } // If two child nodes (both)\n        // Get the minimum of the right subtree to ensure we have valid replacement\n\n\n        var minRight = this.findMinNode(root.right);\n        root.val = minRight.val; // Make sure we remove the node that we replaced the deleted node\n\n        root.right = this.removeNode(root.right, minRight.val);\n        return root;\n      }\n    }\n  }, {\n    key: \"findMinNode\",\n    value: function findMinNode(root) {\n      if (!root || !root.left) {\n        return root;\n      } else {\n        return this.findMinNode(root.left);\n      }\n    } // Return boolean value depending on the existence of the value in the tree\n\n  }, {\n    key: \"search\",\n    value: function search(value) {\n      if (!this.root) {\n        return 'Tree is empty';\n      } else {\n        return Boolean(this.searchNode(this.root, value));\n      }\n    }\n  }, {\n    key: \"searchNode\",\n    value: function searchNode(root, value) {\n      if (!root) {\n        return null;\n      }\n\n      if (value < root.val) {\n        return this.searchNode(root.left, value);\n      } else if (value > root.val) {\n        return this.searchNode(root.right, value);\n      }\n\n      return root;\n    } //-----3----\n    //----------\n    //--1----4--  ------->>>> [3, 1, 4, 0, 2, null, 6]\n    //----------\n    //0--2-----6\n\n  }, {\n    key: \"getLayerRepresentation\",\n    value: function getLayerRepresentation() {\n      // Do a level traversal\n      var queue = [this.root];\n      var result = [];\n\n      while (queue.length) {\n        var currentNode = queue.shift();\n        result.push(currentNode ? currentNode.val : currentNode);\n\n        if (currentNode) {\n          queue.push(currentNode.left);\n          queue.push(currentNode.right);\n        }\n      } // Trim the trailing nulls\n\n\n      var lastValueIndex;\n\n      for (var i = result.length - 1; i >= 0; i--) {\n        if (result[i] !== null) {\n          lastValueIndex = i;\n          break;\n        }\n      }\n\n      return lastValueIndex !== undefined ? result.slice(0, lastValueIndex + 1) : [];\n    }\n  }]);\n\n  return BinarySearchTree;\n}();\nexport var BinaryTreeNode = function BinaryTreeNode(val, key) {\n  _classCallCheck(this, BinaryTreeNode);\n\n  _defineProperty(this, \"val\", void 0);\n\n  _defineProperty(this, \"key\", void 0);\n\n  _defineProperty(this, \"left\", void 0);\n\n  _defineProperty(this, \"right\", void 0);\n\n  this.val = val;\n  this.key = key;\n  this.left = null;\n  this.right = null;\n};\nexport function initBinaryTree(array) {\n  var head = null;\n  var queue = [];\n  var counter = 0;\n  var key = 0;\n  if (!array.length) return null;\n\n  for (var i = 0; i < array.length; i++) {\n    var val = array[i];\n    var newNode = val !== null ? new BinaryTreeNode(val, key++) : null;\n\n    if (head) {\n      var parentNode = queue[0];\n\n      if (counter === 0) {\n        // this node is left of parent node\n        parentNode.left = newNode;\n        counter++;\n      } else {\n        // this node is right of parent node\n        parentNode.right = newNode;\n        counter = 0;\n        queue.shift();\n      }\n    } else {\n      head = newNode;\n    }\n\n    queue.push(newNode);\n  }\n\n  return head;\n}\nexport var findPredecessorOfNode = function findPredecessorOfNode(node) {\n  // The biggest node in the left sub-tree\n  if (!node.left) return node;\n  var currentNode = node.left;\n\n  while (currentNode.right) {\n    currentNode = currentNode.right;\n  }\n\n  return currentNode;\n};\nexport var validateBinaryTree = function validateBinaryTree(input) {\n  function helper(bst) {\n    if (bst === null) return [null, null, true];\n\n    var _helper = helper(bst.left),\n        _helper2 = _slicedToArray(_helper, 3),\n        minLeft = _helper2[0],\n        maxLeft = _helper2[1],\n        isLeftValid = _helper2[2];\n\n    var _helper3 = helper(bst.right),\n        _helper4 = _slicedToArray(_helper3, 3),\n        minRight = _helper4[0],\n        maxRight = _helper4[1],\n        isRightValid = _helper4[2];\n\n    if (!isLeftValid || !isRightValid) return [null, null, false];\n    var isBiggerThanLeftSubtree = maxLeft === null || bst.val > maxLeft;\n    var isSmallerThanRightSubtree = minRight === null || bst.val < minRight;\n    var isValid = isBiggerThanLeftSubtree && isSmallerThanRightSubtree;\n    var minOfThisSubTree = minLeft === null ? bst.val : minLeft;\n    var maxOfThisSubTree = maxRight === null ? bst.val : maxRight;\n    return [minOfThisSubTree, maxOfThisSubTree, isValid];\n  }\n\n  var bst = initBinaryTree(input);\n  return helper(bst)[2];\n}; // Insert one by one\n\nexport var initBSTbySequentiallyInsert = function initBSTbySequentiallyInsert(array) {\n  var bst = new BinarySearchTree();\n  array.filter(function (item) {\n    return item;\n  }).forEach(function (item) {\n    return bst.insert(item);\n  });\n  return bst;\n};","map":null,"metadata":{},"sourceType":"module"}