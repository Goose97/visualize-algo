{"ast":null,"code":"import _pick from \"lodash/pick\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { Component } from 'react';\nimport QueueItem from \"./QueueItem\";\nimport { QUEUE_BLOCK_WIDTH, QUEUE_BLOCK_HEIGHT, QUEUE_BLOCK_GAP } from \"../../constants\";\nimport withReverseStep from 'hocs/withReverseStep';\nimport transformQueueModel from 'transformers/Queue';\nimport { getProgressDirection } from 'utils';\nexport class QueueDS extends Component {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"handleReverse\", stateOfPreviousStep => {\n      this.setState({\n        queueModel: stateOfPreviousStep\n      });\n    });\n\n    this.state = {\n      queueModel: this.initQueueModel()\n    };\n  }\n\n  initQueueModel() {\n    const {\n      initialData\n    } = this.props;\n    return initialData.map((value, index) => ({\n      value,\n      visible: true,\n      key: initialData.length - 1 - index,\n      offsetFromFront: initialData.length - 1 - index\n    }));\n  }\n\n  componentDidUpdate(prevProps) {\n    const {\n      currentStep,\n      reverseToStep,\n      totalStep\n    } = this.props;\n    if (!currentStep || !prevProps.currentStep || !totalStep) return;\n\n    switch (getProgressDirection(currentStep, prevProps.currentStep, totalStep)) {\n      case 'forward':\n        this.saveModelSnapshotAtCurrentStep();\n        this.handleForward();\n        break;\n\n      case 'backward':\n        reverseToStep(currentStep);\n        break;\n      // case 'fastForward':\n      //   console.log('fastForward');\n      //   this.handleFastForward();\n      //   break;\n      // case 'fastBackward':\n      //   console.log('fastBackward');\n      //   this.handleFastBackward();\n      //   break;\n    }\n  }\n\n  saveModelSnapshotAtCurrentStep() {\n    const {\n      currentStep,\n      saveStepSnapshots\n    } = this.props;\n    const {\n      queueModel\n    } = this.state;\n    if (typeof currentStep === 'number') saveStepSnapshots(queueModel, currentStep);\n  }\n\n  handleForward() {\n    // Treat each action as a transformation function which take a linkedListModel\n    // and return a new one. Consuming multiple actions is merely chaining those\n    // transformations together\n    // linkedListModel ---- action1 ----> linkedListModel1 ---- action2 ----> linkedListMode2 ---- action3 ----> linkedListModel3\n    const {\n      queueModel\n    } = this.state;\n    const {\n      currentStep,\n      instructions\n    } = this.props;\n    const actionsToMakeAtThisStep = instructions[currentStep];\n    if (!actionsToMakeAtThisStep || !actionsToMakeAtThisStep.length) return; // This consume pipeline have many side effect in each step. Each\n    // method handle each action has their own side effect\n\n    const newQueueModel = this.consumeMultipleActions(actionsToMakeAtThisStep, queueModel);\n    this.setState({\n      queueModel: newQueueModel\n    });\n  }\n\n  consumeMultipleActions(actionList, currentModel, onlyTranformData) {\n    // Treat each action as a transformation function which take a linkedListModel\n    // and return a new one. Consuming multiple actions is merely chaining those\n    // transformations together\n    // linkedListModel ---- action1 ----> linkedListModel1 ---- action2 ----> linkedListMode2 ---- action3 ----> linkedListModel3\n    return actionList.reduce((finalModel, action) => {\n      // the main function of a handler is doing side effect before transform model\n      // a handler must also return a new model\n      // if no handler is specify, just transform model right away\n      const {\n        name,\n        params\n      } = action; //@ts-ignore\n\n      const customHandler = this[name];\n\n      if (typeof customHandler === 'function') {\n        return customHandler(finalModel, params, onlyTranformData);\n      } else {\n        return transformQueueModel(finalModel, name, params);\n      }\n    }, currentModel);\n  }\n\n  enqueue(currentModel, params) {\n    const firstItem = currentModel[0];\n    const firstVisibleItem = currentModel.filter(({\n      visible\n    }) => !!visible)[0];\n    const queueItemToEnqueue = {\n      value: params[0],\n      visible: true,\n      offsetFromFront: firstVisibleItem ? firstVisibleItem.offsetFromFront + 1 : 0,\n      key: firstItem ? firstItem.key + 1 : 0,\n      isNew: true\n    };\n    const newModel = transformQueueModel(currentModel, 'enqueue', [queueItemToEnqueue]);\n    return newModel;\n  }\n\n  renderQueueBoundary() {\n    const queueWidth = this.caculateWidthOfQueue();\n\n    const upperBound = __jsx(\"path\", {\n      className: \"default-stroke has-transition\",\n      d: `M ${QUEUE_BLOCK_WIDTH} ${-20} l -2 2 l 8 -2 l -8 -2 l 2 2 h ${-queueWidth}`\n    });\n\n    const lowerBound = __jsx(\"path\", {\n      className: \"default-stroke has-transition\",\n      d: `M ${QUEUE_BLOCK_WIDTH} ${QUEUE_BLOCK_HEIGHT + 20} l -2 2 l 8 -2 l -8 -2 l 2 2 h ${-queueWidth}`\n    });\n\n    return __jsx(React.Fragment, null, upperBound, lowerBound);\n  }\n\n  caculateWidthOfQueue() {\n    const {\n      queueModel\n    } = this.state;\n    const numberOfQueueItem = queueModel.filter(({\n      visible\n    }) => !!visible).length;\n    return numberOfQueueItem * (QUEUE_BLOCK_WIDTH + QUEUE_BLOCK_GAP) - QUEUE_BLOCK_GAP;\n  }\n\n  render() {\n    const {\n      queueModel\n    } = this.state;\n    const listQueueItem = queueModel.map(item => __jsx(QueueItem, item));\n    return __jsx(React.Fragment, null, __jsx(\"use\", _extends({\n      href: \"#queue\"\n    }, _pick(this.props, ['x', 'y']))), __jsx(\"defs\", null, __jsx(\"g\", {\n      id: \"queue\",\n      className: \"queue__wrapper\"\n    }, listQueueItem, this.renderQueueBoundary())));\n  }\n\n}\nexport default withReverseStep(QueueDS);","map":null,"metadata":{},"sourceType":"module"}