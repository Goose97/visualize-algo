{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _toConsumableArray from \"@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _compose from \"lodash/fp/compose\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport produce from 'immer';\n\n// Nhận vào trạng thái hiện tại của data structure\n// và operation tương ứng. Trả về trạng thái mới\nvar transformLinkedListModel = function transformLinkedListModel(currentModel, operation, payload) {\n  switch (operation) {\n    case 'remove':\n      {\n        var _payload = _slicedToArray(payload, 1),\n            nodeKey = _payload[0];\n\n        return produce(currentModel, function (draft) {\n          var nodeToRemove = draft.find(function (_ref) {\n            var key = _ref.key;\n            return key === nodeKey;\n          });\n          if (nodeToRemove) nodeToRemove.visible = false;\n        });\n      }\n\n    case 'removeByValue':\n      {\n        var _payload2 = _slicedToArray(payload, 1),\n            nodeValue = _payload2[0];\n\n        return produce(currentModel, function (draft) {\n          var nodeToRemove = draft.find(function (_ref2) {\n            var value = _ref2.value;\n            return value === nodeValue;\n          });\n          if (nodeToRemove) nodeToRemove.visible = false;\n        });\n      }\n\n    case 'insert':\n      {\n        var _payload3 = _slicedToArray(payload, 2),\n            nodeData = _payload3[0],\n            previousNodeKey = _payload3[1];\n\n        return produce(currentModel, function (draft) {\n          var newNodeIndex = draft.findIndex(function (_ref3) {\n            var key = _ref3.key;\n            return key === previousNodeKey;\n          }) + 1;\n          draft.splice(newNodeIndex, 0, nodeData); // shift right every node in the right of the new node\n\n          var shiftedNodes = draft.slice(newNodeIndex + 1).map(function (currentModel) {\n            return _objectSpread({}, currentModel, {\n              x: currentModel.x + 160\n            });\n          });\n          draft.splice.apply(draft, [newNodeIndex + 1, shiftedNodes.length].concat(_toConsumableArray(shiftedNodes)));\n        });\n      }\n\n    case 'visited':\n      {\n        var _payload4 = _slicedToArray(payload, 1),\n            index = _payload4[0];\n\n        return produce(currentModel, function (draft) {\n          draft[index].visited = true;\n        });\n      }\n\n    case 'focus':\n      {\n        var _payload5 = _slicedToArray(payload, 2),\n            key = _payload5[0],\n            keepOtherNodeFocus = _payload5[1];\n\n        return produce(currentModel, function (draft) {\n          if (!keepOtherNodeFocus) draft.forEach(function (item) {\n            return item.focus = false;\n          }); // Nếu index === null nghĩa là đang unfocus tất cả các node\n\n          if (key !== null) {\n            var nodeToFocus = draft.find(function (_ref4) {\n              var nodeKey = _ref4.key;\n              return nodeKey === key;\n            });\n            if (nodeToFocus) nodeToFocus.focus = true;\n          }\n        });\n      }\n\n    case 'label':\n      {\n        var _payload6 = _slicedToArray(payload, 3),\n            label = _payload6[0],\n            nodeKeyToLabel = _payload6[1],\n            removeThisLabelInOtherNode = _payload6[2];\n\n        return produce(currentModel, function (draft) {\n          if (removeThisLabelInOtherNode) {\n            draft.forEach(function (node) {\n              var oldLabel = node.label;\n\n              if (oldLabel) {\n                //@ts-ignore\n                var newLabel = oldLabel.filter(function (item) {\n                  return item !== label;\n                });\n                node.label = newLabel;\n              }\n            });\n          }\n\n          var nodeToLabel = draft.find(function (_ref5) {\n            var key = _ref5.key;\n            return key === nodeKeyToLabel;\n          });\n\n          if (nodeToLabel) {\n            var oldLabel = nodeToLabel.label || []; //@ts-ignore\n\n            nodeToLabel.label = oldLabel.concat(label);\n          }\n        });\n      }\n\n    case 'changePointer':\n      {\n        var _payload7 = _slicedToArray(payload, 2),\n            pointFrom = _payload7[0],\n            pointTo = _payload7[1];\n\n        return produce(currentModel, function (draft) {\n          var nodeHolderPointer = draft.find(function (_ref6) {\n            var key = _ref6.key;\n            return key === pointFrom;\n          });\n\n          if (nodeHolderPointer) {\n            nodeHolderPointer.pointer = pointTo;\n          }\n        });\n      }\n\n    case 'resetAll':\n      {\n        // Reset focus, visited and label\n        var listTransformation = ['resetFocus', 'resetVisited', 'resetLabel'].map(function (method) {\n          return function (model) {\n            return transformLinkedListModel(model, method, []);\n          };\n        });\n        return _compose(listTransformation)(currentModel);\n      }\n\n    case 'resetFocus':\n      {\n        return produce(currentModel, function (draft) {\n          draft.forEach(function (item) {\n            return item.focus = false;\n          });\n        });\n      }\n\n    case 'resetVisited':\n      {\n        return produce(currentModel, function (draft) {\n          draft.forEach(function (item) {\n            return item.visited = false;\n          });\n        });\n      }\n\n    case 'resetLabel':\n      {\n        return produce(currentModel, function (draft) {\n          draft.forEach(function (item) {\n            return item.label = [];\n          });\n        });\n      }\n\n    default:\n      return currentModel;\n  }\n};\n\nexport default transformLinkedListModel;","map":null,"metadata":{},"sourceType":"module"}