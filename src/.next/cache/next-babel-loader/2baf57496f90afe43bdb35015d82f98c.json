{"ast":null,"code":"import _compose from \"lodash/fp/compose\";\nimport _uniq from \"lodash/uniq\";\nimport produce from 'immer';\n\nconst swapObjectProperty = (objectA, objectB, property) => {\n  const tmp = objectA[property];\n  objectA[property] = objectB[property];\n  objectB[property] = tmp;\n}; // Nhận vào trạng thái hiện tại của data structure\n// và operation tương ứng. Trả về trạng thái mới\n\n\nconst transformArrayModel = (currentModel, operation, payload) => {\n  switch (operation) {\n    case 'swap':\n      {\n        const [from, to] = payload;\n        return produce(currentModel, draft => {\n          const fromNode = draft.find(({\n            key\n          }) => key === from);\n          const toNode = draft.find(({\n            key\n          }) => key === to);\n\n          if (fromNode && toNode) {\n            swapObjectProperty(fromNode, toNode, 'index');\n          }\n        });\n      }\n\n    case 'focus':\n      {\n        const [keyToFocus] = payload;\n        return produce(currentModel, draft => {\n          const nodeToFocus = draft.find(({\n            key\n          }) => key === keyToFocus);\n\n          if (nodeToFocus) {\n            nodeToFocus.focus = true;\n          }\n        });\n      }\n\n    case 'resetFocus':\n      {\n        const [keyToResetFocus] = payload;\n        return produce(currentModel, draft => {\n          const nodeToResetFocus = draft.find(({\n            key\n          }) => key === keyToResetFocus);\n\n          if (nodeToResetFocus) {\n            nodeToResetFocus.focus = false;\n          }\n        });\n      }\n\n    case 'resetFocusAll':\n      {\n        return produce(currentModel, draft => {\n          draft.forEach(node => {\n            node.focus = false;\n          });\n        });\n      }\n\n    case 'complete':\n      {\n        const [keyToComplete] = payload;\n        return produce(currentModel, draft => {\n          const nodeToComplete = draft.find(({\n            key\n          }) => key === keyToComplete);\n\n          if (nodeToComplete) {\n            nodeToComplete.visited = true;\n          }\n        });\n      }\n\n    case 'label':\n      {\n        const [nodeKeyToLabel, label, removeThisLabelInOtherNode] = payload;\n        return produce(currentModel, draft => {\n          if (removeThisLabelInOtherNode) {\n            draft.forEach(node => {\n              const oldLabel = node.label;\n\n              if (oldLabel) {\n                //@ts-ignore\n                const newLabel = oldLabel.filter(item => item !== label);\n                node.label = newLabel;\n              }\n            });\n          }\n\n          const nodeToLabel = draft.find(({\n            key\n          }) => key === nodeKeyToLabel);\n\n          if (nodeToLabel) {\n            const oldLabel = nodeToLabel.label || []; //@ts-ignore\n\n            nodeToLabel.label = _uniq(oldLabel.concat(label));\n          }\n        });\n      }\n\n    case 'unlabel':\n      {\n        const [keyToUnlabel] = payload;\n        return produce(currentModel, draft => {\n          const nodeToUnlabel = draft.find(({\n            key\n          }) => key === keyToUnlabel);\n\n          if (nodeToUnlabel) {\n            nodeToUnlabel.label = undefined;\n          }\n        });\n      }\n\n    case 'unlabelAll':\n      {\n        return produce(currentModel, draft => {\n          draft.forEach(item => item.label = undefined);\n        });\n      }\n\n    case 'setValue':\n      {\n        const [keyToSetValue, value] = payload;\n        return produce(currentModel, draft => {\n          const nodeToResetValue = draft.find(({\n            key\n          }) => key === keyToSetValue);\n          if (nodeToResetValue) nodeToResetValue.value = value;\n        });\n      }\n\n    case 'setIndex':\n      {\n        const [keyToSetIndex, index] = payload;\n        return produce(currentModel, draft => {\n          const nodeToResetValue = draft.find(({\n            key\n          }) => key === keyToSetIndex);\n          if (nodeToResetValue) nodeToResetValue.index = index;\n        });\n      }\n\n    case 'push':\n      {\n        const [newArrayNode] = payload;\n        return produce(currentModel, draft => {\n          draft.push(newArrayNode);\n        });\n      }\n    // Highlight target key and blur every other key\n\n    case 'highlight':\n      {\n        const [keyToHighlight] = payload;\n        return produce(currentModel, draft => {\n          const arrayNode = draft.find(({\n            key\n          }) => key === keyToHighlight);\n          if (arrayNode) arrayNode.highlight = true;\n          draft.forEach(item => {\n            item.blur = !item.highlight;\n          });\n        });\n      }\n\n    case 'dehighlight':\n      {\n        const [keyToDehighlight] = payload;\n        return produce(currentModel, draft => {\n          const arrayNode = draft.find(({\n            key\n          }) => key === keyToDehighlight);\n          if (arrayNode) arrayNode.highlight = false;\n        });\n      }\n\n    case 'dehighlightAll':\n      {\n        return produce(currentModel, draft => {\n          draft.forEach(item => {\n            item.highlight = false;\n            item.blur = false;\n          });\n        });\n      }\n\n    case 'resetAll':\n      {\n        // Reset focus, visited and label\n        const listTransformation = ['resetFocusAll', 'dehighlightAll', 'unlabelAll'].map(method => model => transformArrayModel(model, method, []));\n        return _compose(listTransformation)(currentModel);\n      }\n\n    default:\n      return currentModel;\n  }\n};\n\nexport default transformArrayModel;","map":null,"metadata":{},"sourceType":"module"}