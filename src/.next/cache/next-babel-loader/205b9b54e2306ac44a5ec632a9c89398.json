{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _Reflect$construct from \"@babel/runtime-corejs2/core-js/reflect/construct\";\nimport _Object$values from \"@babel/runtime-corejs2/core-js/object/values\";\nimport _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _toConsumableArray from \"@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _Set from \"@babel/runtime-corejs2/core-js/set\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime-corejs2/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime-corejs2/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport _pick from \"lodash/pick\";\nimport _flatMap from \"lodash/flatMap\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(_Reflect$construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from 'react';\nimport { GraphMemoryBlock, GraphLikeEdges } from 'components';\nimport BinarySearchTreeHTML from \"./BinarySearchTreeHTML\";\nimport withDSCore from 'hocs/withDSCore';\nimport transformBSTModel from 'transformers/BST';\nimport { caculateTreeHeight, caculateChildCoordinate, isNodeCoordinateCollideWithOtherNode, produceInitialBSTData } from \"./helper\";\nexport var BinarySearchTreeDS = /*#__PURE__*/function (_Component) {\n  _inherits(BinarySearchTreeDS, _Component);\n\n  var _super = _createSuper(BinarySearchTreeDS);\n\n  function BinarySearchTreeDS(props) {\n    var _this;\n\n    _classCallCheck(this, BinarySearchTreeDS);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"wrapperRef\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"visit\", function (currentModel, params) {\n      var _params = _slicedToArray(params, 2),\n          nodeKeyToStart = _params[0],\n          nodeKeyToVisit = _params[1];\n\n      _this.addNodeToVisitingList(nodeKeyToVisit);\n\n      setTimeout(function () {\n        _this.handleAfterVisitAnimationFinish(currentModel, nodeKeyToStart, nodeKeyToVisit);\n      }, 800);\n      return currentModel;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"insert\", function (currentModel, params) {\n      var _params2 = _slicedToArray(params, 2),\n          parentKey = _params2[0],\n          valueToInsert = _params2[1];\n\n      var parentNode = currentModel.find(function (_ref) {\n        var key = _ref.key;\n        return key === parentKey;\n      });\n      if (parentNode == null) return currentModel;\n\n      var parentCoordinate = _pick(parentNode, ['x', 'y']);\n\n      var treeHeight = caculateTreeHeight(currentModel);\n      var childOrientation = //@ts-ignore\n      valueToInsert > parentNode.value ? 'right' : 'left';\n      var childCoordinate = caculateChildCoordinate(parentCoordinate, treeHeight, treeHeight, childOrientation); // If the new child coordinate collide with existing node in key\n      // we must recaculate all coordinate of the tree\n\n      if (isNodeCoordinateCollideWithOtherNode(childCoordinate, currentModel)) {\n        var allocatedBSTModel = _this.reallocateAllTreeNode(currentModel);\n\n        return _this.insert(allocatedBSTModel, params);\n      }\n\n      var newChildNode = _this.constructNewChildNode(valueToInsert, _this.getBiggestKey(currentModel) + 1, childCoordinate);\n\n      var modelAfterInsert = transformBSTModel(currentModel, 'insert', [parentKey, newChildNode]);\n      if (_this.isTreeOutOfView(modelAfterInsert)) return _this.shiftTreeToView(modelAfterInsert);\n      return modelAfterInsert;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"injectHTMLIntoCanvas\", function () {\n      var _this$props = _this.props,\n          handleExecuteApi = _this$props.handleExecuteApi,\n          dropdownDisabled = _this$props.dropdownDisabled,\n          model = _this$props.model;\n      setTimeout(function () {\n        BinarySearchTreeHTML.renderToView({\n          model: model,\n          wrapperElement: _this.wrapperRef.current,\n          coordinate: _pick(_this.props, ['x', 'y']),\n          apiHandler: handleExecuteApi,\n          disabled: dropdownDisabled\n        });\n      }, 0);\n    });\n\n    _this.state = {\n      nodeAboutToVisit: new _Set([])\n    };\n    _this.wrapperRef = React.createRef(); // Register custom transformer\n\n    props.registerCustomTransformer({\n      visit: _this.visit,\n      insert: _this.insert\n    }); // Register HTML injector\n\n    props.registerHTMLInjector(_this.injectHTMLIntoCanvas);\n    return _this;\n  }\n\n  _createClass(BinarySearchTreeDS, [{\n    key: \"consumeMultipleActions\",\n    value: function consumeMultipleActions(actionList, currentModel, onlyTranformData) {\n      var _this2 = this;\n\n      // Treat each action as a transformation function which take a linkedListModel\n      // and return a new one. Consuming multiple actions is merely chaining those\n      // transformations together\n      // linkedListModel ---- action1 ----> linkedListModel1 ---- action2 ----> linkedListMode2 ---- action3 ----> linkedListModel3\n      return actionList.reduce(function (finalModel, action) {\n        // the main function of a handler is doing side effect before transform model\n        // a handler must also return a new model\n        // if no handler is specify, just transform model right away\n        var name = action.name,\n            params = action.params; //@ts-ignore\n\n        var customHandler = _this2[name];\n\n        if (typeof customHandler === 'function') {\n          return customHandler(finalModel, params, onlyTranformData);\n        } else {\n          return transformBSTModel(finalModel, name, params);\n        }\n      }, currentModel);\n    }\n  }, {\n    key: \"addNodeToVisitingList\",\n    value: function addNodeToVisitingList(nodeKey) {\n      var nodeAboutToVisit = this.state.nodeAboutToVisit;\n      var clonedState = new _Set(nodeAboutToVisit);\n      clonedState.add(nodeKey);\n      this.setState({\n        nodeAboutToVisit: clonedState\n      });\n    }\n  }, {\n    key: \"handleAfterVisitAnimationFinish\",\n    value: function handleAfterVisitAnimationFinish(currentModel, startNodeKey, nodeKeyToVisit) {\n      var nodeAboutToVisit = this.state.nodeAboutToVisit;\n      var updateModel = this.props.updateModel;\n      var clonedState = new _Set(nodeAboutToVisit);\n      clonedState[\"delete\"](nodeKeyToVisit); // Mark the start node as visited and focus to the node which is just visited\n\n      var visitAction = {\n        name: 'visited',\n        params: [startNodeKey]\n      };\n      var focusAction = {\n        name: 'focus',\n        params: [nodeKeyToVisit]\n      };\n      var newModel = this.consumeMultipleActions([visitAction, focusAction], currentModel, true);\n      this.setState({\n        nodeAboutToVisit: clonedState\n      });\n      updateModel(newModel);\n    } // params: [parentKey, valueToInsert]\n\n  }, {\n    key: \"isTreeOutOfView\",\n    value: function isTreeOutOfView(bstModel) {\n      return bstModel.some(function (_ref2) {\n        var x = _ref2.x;\n        return x < 0;\n      });\n    } // Sometimes node in bst will have negative x value\n    // so we have to shift the whole tree to right some amount to make\n    // the whole tree visible\n\n  }, {\n    key: \"shiftTreeToView\",\n    value: function shiftTreeToView(bstModel) {\n      var amountToShiftRight = Math.min.apply(Math, _toConsumableArray(bstModel.map(function (_ref3) {\n        var x = _ref3.x;\n        return x;\n      })));\n      if (amountToShiftRight > 0) return bstModel;\n      return bstModel.map(function (item) {\n        return _objectSpread({}, item, {\n          x: item.x - amountToShiftRight\n        });\n      });\n    }\n  }, {\n    key: \"reallocateAllTreeNode\",\n    value: function reallocateAllTreeNode(currentModel) {\n      var nodeCoordinateByKey = BinarySearchTreeDS.getCoordinationsOfTreeNodes(currentModel, this.props);\n      return currentModel.map(function (node) {\n        return _objectSpread({}, node, {}, nodeCoordinateByKey[node.key]);\n      });\n    }\n  }, {\n    key: \"getBiggestKey\",\n    value: function getBiggestKey(currentModel) {\n      return Math.max.apply(Math, _toConsumableArray(currentModel.map(function (_ref4) {\n        var key = _ref4.key;\n        return key;\n      })));\n    }\n  }, {\n    key: \"constructNewChildNode\",\n    value: function constructNewChildNode(value, key, coordinate) {\n      return _objectSpread({\n        value: value,\n        left: null,\n        right: null,\n        key: key,\n        visible: true,\n        isNew: true\n      }, coordinate);\n    } // handleFastForward() {\n    //   const { bstModel } = this.state;\n    //   const { instructions, saveStepSnapshots } = this.props;\n    //   if (!instructions) return;\n    //   let allActions: ActionWithStep<BST.Method>[] = [];\n    //   for (let i = 0; i < instructions.length; i++) {\n    //     // Replace visit action with vist + focus\n    //     // also add step attribute to each action\n    //     const replacedActions: ActionWithStep<BST.Method>[] = flatMap(\n    //       instructions[i],\n    //       action => {\n    //         const { name, params } = action;\n    //         return name === 'visit'\n    //           ? [\n    //               { name: 'visited', params: params.slice(0, 1), step: i },\n    //               { name: 'focus', params: params.slice(1), step: i },\n    //             ]\n    //           : { ...action, step: i };\n    //       },\n    //     );\n    //     allActions.push(...replacedActions);\n    //   }\n    //   const actionsGroupedByStep = groupBy(allActions, item => item.step);\n    //   // Loop through all the action one by one and keep updating the final model\n    //   let finalLinkedListModel = Object.entries(actionsGroupedByStep).reduce<\n    //     BST.Model\n    //   >((currentModel, [step, actionsToMakeAtThisStep]) => {\n    //     saveStepSnapshots(currentModel, +step);\n    //     return this.consumeMultipleActions(\n    //       actionsToMakeAtThisStep,\n    //       currentModel,\n    //       true,\n    //     );\n    //   }, bstModel);\n    //   this.updateWithoutAnimation(finalLinkedListModel);\n    // }\n\n  }, {\n    key: \"renderNodes\",\n    value: function renderNodes() {\n      var model = this.props.model;\n      return model.map(function (node) {\n        return __jsx(GraphMemoryBlock, node);\n      });\n    }\n  }, {\n    key: \"renderPointerLinks\",\n    value: function renderPointerLinks() {\n      var _this3 = this;\n\n      var model = this.props.model;\n      var nodeAboutToVisit = this.state.nodeAboutToVisit;\n      return _flatMap(model, function (node) {\n        var left = node.left,\n            right = node.right,\n            key = node.key,\n            visited = node.visited;\n\n        var fromNode = _this3.findNodeCoordinateByKey(model, key);\n\n        return [left, right].map(function (child) {\n          if (!child) return null;\n\n          var _BinarySearchTreeDS$f = BinarySearchTreeDS.findNodeInTreeByKey(model, child),\n              childVisited = _BinarySearchTreeDS$f.visited;\n\n          var toNode = _this3.findNodeCoordinateByKey(model, child);\n\n          return __jsx(GraphLikeEdges // {...pathAndRotation}\n          , {\n            from: _pick(fromNode, ['x', 'y']),\n            to: _pick(toNode, ['x', 'y']),\n            key: child,\n            visible: !!_this3.isNodeVisible(model, child),\n            visited: visited && childVisited,\n            following: nodeAboutToVisit.has(child),\n            arrowDirection: \"right\"\n          });\n        });\n      });\n    }\n  }, {\n    key: \"findNodeCoordinateByKey\",\n    value: function findNodeCoordinateByKey(currentModel, nodeKey) {\n      var treeNode = currentModel.find(function (_ref5) {\n        var key = _ref5.key;\n        return key === nodeKey;\n      });\n      return {\n        x: treeNode.x,\n        y: treeNode.y\n      };\n    }\n  }, {\n    key: \"isNodeVisible\",\n    value: function isNodeVisible(currentModel, nodeKey) {\n      var _currentModel$find;\n\n      return !!((_currentModel$find = currentModel.find(function (_ref6) {\n        var key = _ref6.key;\n        return key === nodeKey;\n      })) === null || _currentModel$find === void 0 ? void 0 : _currentModel$find.visible);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return __jsx(React.Fragment, null, __jsx(\"use\", _extends({\n        href: \"#binary-search-tree\"\n      }, _pick(this.props, ['x', 'y']), {\n        ref: this.wrapperRef\n      })), __jsx(\"defs\", null, __jsx(\"g\", {\n        id: \"binary-search-tree\",\n        x: \"0\",\n        y: \"0\"\n      }, this.renderPointerLinks(), this.renderNodes())));\n    }\n  }], [{\n    key: \"initBSTModel\",\n    value: function initBSTModel(props) {\n      var controlled = props.controlled,\n          data = props.data,\n          initialData = props.initialData;\n      var dataToInitBST = controlled ? data : initialData;\n      var bstModelWithoutCoordinate = produceInitialBSTData(dataToInitBST);\n      var nodeCoordinateByKey = BinarySearchTreeDS.getCoordinationsOfTreeNodes(bstModelWithoutCoordinate, props);\n      return bstModelWithoutCoordinate.map(function (item) {\n        return _objectSpread({}, item, {}, nodeCoordinateByKey[item.key], {\n          visible: true\n        });\n      });\n    }\n  }, {\n    key: \"getCoordinationsOfTreeNodes\",\n    value: function getCoordinationsOfTreeNodes(bstModelWithoutCoordinate, props) {\n      // Level order traversal tree and caculate\n      var treeHeight = caculateTreeHeight(bstModelWithoutCoordinate);\n      var result = {};\n\n      var root = _objectSpread({}, bstModelWithoutCoordinate[0], {}, _pick(props, ['x', 'y']), {\n        x: 0,\n        y: 0,\n        level: 1\n      });\n\n      var queue = [root];\n\n      while (queue.length) {\n        var _ref7 = queue.shift(),\n            key = _ref7.key,\n            x = _ref7.x,\n            y = _ref7.y,\n            left = _ref7.left,\n            right = _ref7.right,\n            level = _ref7.level;\n\n        result[key] = {\n          x: x,\n          y: y\n        };\n\n        if (left !== null) {\n          var leftChild = BinarySearchTreeDS.findNodeInTreeByKey(bstModelWithoutCoordinate, left);\n          queue.push(_objectSpread({}, leftChild, {}, caculateChildCoordinate({\n            x: x,\n            y: y\n          }, level + 1, treeHeight, 'left'), {\n            level: level + 1\n          }));\n        }\n\n        if (right !== null) {\n          var rightChild = BinarySearchTreeDS.findNodeInTreeByKey(bstModelWithoutCoordinate, right);\n          queue.push(_objectSpread({}, rightChild, {}, caculateChildCoordinate({\n            x: x,\n            y: y\n          }, level + 1, treeHeight, 'right'), {\n            level: level + 1\n          }));\n        }\n      } // Some coordination will have negative x value\n      // we have to shift all coordination to right to make sure they start at 0\n\n\n      var allXValue = _Object$values(result).map(function (_ref8) {\n        var x = _ref8.x;\n        return x;\n      });\n\n      var amountToShiftToRight = -Math.min.apply(Math, _toConsumableArray(allXValue).concat([0]));\n\n      _Object$values(result).forEach(function (coordinate) {\n        coordinate.x += amountToShiftToRight;\n      });\n\n      return result;\n    }\n  }, {\n    key: \"findNodeInTreeByKey\",\n    value: function findNodeInTreeByKey(currentModel, nodeKey) {\n      return currentModel.find(function (_ref9) {\n        var key = _ref9.key;\n        return key === nodeKey;\n      });\n    }\n  }]);\n\n  return BinarySearchTreeDS;\n}(Component);\nexport default withDSCore({\n  initModel: BinarySearchTreeDS.initBSTModel,\n  dataTransformer: transformBSTModel //@ts-ignore\n\n})(BinarySearchTreeDS);","map":null,"metadata":{},"sourceType":"module"}