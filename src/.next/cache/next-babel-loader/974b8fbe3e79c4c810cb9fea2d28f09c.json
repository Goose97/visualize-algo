{"ast":null,"code":"import _Reflect$construct from \"@babel/runtime-corejs2/core-js/reflect/construct\";\nimport _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime-corejs2/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _isFunction from \"lodash/isFunction\";\nimport _omit from \"lodash/omit\";\nvar __jsx = React.createElement;\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(_Reflect$construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from 'react';\nimport withExtendClassName from 'hocs/withExtendClassName';\nimport { classNameHelper } from 'utils';\nexport var PointerLink = /*#__PURE__*/function (_Component) {\n  _inherits(PointerLink, _Component);\n\n  var _super = _createSuper(PointerLink);\n\n  function PointerLink(props) {\n    var _this;\n\n    _classCallCheck(this, PointerLink);\n\n    _this = _super.call(this, props);\n    _this.state = {\n      // We will use this offset to animate\n      transformList: _this.produceInitialTransformList()\n    };\n    return _this;\n  }\n\n  _createClass(PointerLink, [{\n    key: \"produceInitialTransformList\",\n    value: function produceInitialTransformList() {\n      var transform = this.props.transform;\n\n      if (transform) {\n        var regexMatch = transform.match(/(rotate|translate)\\(.+\\)/g);\n        return regexMatch ? regexMatch : [];\n      } else {\n        return [];\n      }\n    }\n  }, {\n    key: \"produceClassName\",\n    value: function produceClassName() {\n      var _this$props = this.props,\n          visited = _this$props.visited,\n          highlight = _this$props.highlight,\n          following = _this$props.following,\n          className = _this$props.className,\n          visible = _this$props.visible,\n          blur = _this$props.blur;\n      return classNameHelper({\n        base: [className, 'pointer-link has-transition'].filter(function (item) {\n          return item;\n        }).join(' '),\n        disappearing: visible === false,\n        visited: !!visited,\n        following: !!following,\n        highlight: !!highlight,\n        blur: !!blur\n      });\n    }\n  }, {\n    key: \"renderMainPointerLink\",\n    value: function renderMainPointerLink() {\n      var _classNameHelper;\n\n      var _this$props2 = this.props,\n          path = _this$props2.path,\n          isNew = _this$props2.isNew,\n          animationDuration = _this$props2.animationDuration,\n          _onAnimationEnd = _this$props2.onAnimationEnd,\n          highlight = _this$props2.highlight;\n      var fullPathWithArrow = \"\".concat(path, \" \").concat(this.produceArrowPath());\n      var className = classNameHelper((_classNameHelper = {\n        base: 'pointer-link__line'\n      }, _defineProperty(_classNameHelper, 'animated-path', !!isNew), _defineProperty(_classNameHelper, \"highlight\", !!highlight), _classNameHelper));\n      return __jsx(\"path\", {\n        d: fullPathWithArrow,\n        className: className,\n        style: {\n          animationDuration: animationDuration\n        },\n        onAnimationEnd: function onAnimationEnd() {\n          return _isFunction(_onAnimationEnd) && _onAnimationEnd('appear');\n        }\n      });\n    }\n  }, {\n    key: \"produceFullPathWithArrow\",\n    value: function produceFullPathWithArrow() {\n      var path = this.props.path;\n      return \"\".concat(path, \" \").concat(this.produceArrowPath());\n    }\n  }, {\n    key: \"produceArrowPath\",\n    value: function produceArrowPath() {\n      var arrowDirection = this.props.arrowDirection;\n\n      switch (arrowDirection) {\n        case 'right':\n          return 'l -2 2 l 8 -2 l -8 -2 l 2 2';\n\n        case 'left':\n          return 'l 2 2 l -8 -2 l 8 -2 l -2 2';\n\n        case 'up':\n          return 'l 2 2 l -2 -8 l -2 8 l 2 -2';\n\n        default:\n          return '';\n      }\n    }\n  }, {\n    key: \"produceStartPointMark\",\n    value: function produceStartPointMark() {\n      var _this$props3 = this.props,\n          path = _this$props3.path,\n          visited = _this$props3.visited,\n          following = _this$props3.following;\n      var regex = /^M (\\d+) (\\d+)/;\n      var startPoint = path === null || path === void 0 ? void 0 : path.match(regex);\n\n      if (startPoint) {\n        var className = classNameHelper({\n          base: 'pointer-link__start-dot',\n          follow: !!following,\n          visited: !!visited\n        });\n        return __jsx(\"circle\", {\n          cx: startPoint[1],\n          cy: startPoint[2],\n          r: \"2\",\n          className: className\n        });\n      } else return null;\n    }\n  }, {\n    key: \"renderFocusMaskOnPointerLink\",\n    value: function renderFocusMaskOnPointerLink() {\n      // Just a layer of pointer link of top of the original one\n      // Create a effect of highlight when focus\n      var _this$props4 = this.props,\n          isNew = _this$props4.isNew,\n          following = _this$props4.following;\n      var shouldRender = following && !isNew;\n      var compoundClassName = classNameHelper(_defineProperty({\n        // base: [className, 'pointer-link__line'].filter(item => !item).join(' '),\n        base: 'pointer-link__line'\n      }, 'follow animated-path', !!following));\n      return shouldRender && __jsx(\"path\", {\n        d: this.produceFullPathWithArrow(),\n        className: compoundClassName\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var propsToOmit = ['arrowDirection', 'following', 'visited', 'visible', 'isNew', 'animationDuration', 'onAnimationEnd', 'highlight', 'blur'];\n      return (//@ts-ignore\n        __jsx(\"g\", _extends({}, _omit(this.props, propsToOmit), {\n          className: this.produceClassName()\n        }), this.renderFocusMaskOnPointerLink(), this.renderMainPointerLink(), this.produceStartPointMark())\n      );\n    }\n  }]);\n\n  return PointerLink;\n}(Component);\nexport default withExtendClassName('')(PointerLink);","map":null,"metadata":{},"sourceType":"module"}