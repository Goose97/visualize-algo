{"ast":null,"code":"import _isEqual from \"lodash/isEqual\";\nimport _isFunction from \"lodash/isFunction\";\nimport _groupBy from \"lodash/groupBy\";\nimport _flatMap from \"lodash/flatMap\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { Component } from 'react';\nimport { CanvasObserver } from 'components';\nimport { keyExist, getProgressDirection } from 'utils';\n\nfunction withDSCore(initObject) {\n  return Page => {\n    class WrapperComponent extends Component {\n      // DS core stuff\n      // Reverse related stuff\n      constructor(props) {\n        super(props);\n\n        _defineProperty(this, \"initialModel\", void 0);\n\n        _defineProperty(this, \"customTransformers\", void 0);\n\n        _defineProperty(this, \"htmlInjector\", void 0);\n\n        _defineProperty(this, \"reverseLogs\", void 0);\n\n        _defineProperty(this, \"stepSnapshots\", void 0);\n\n        _defineProperty(this, \"ref\", void 0);\n\n        _defineProperty(this, \"handleReverse\", stateOfPreviousStep => {\n          this.setState({\n            model: stateOfPreviousStep\n          });\n        });\n\n        _defineProperty(this, \"registerCustomTransformer\", callbackWithAction => {\n          //@ts-ignore\n          Object.assign(this.customTransformers, callbackWithAction);\n        });\n\n        _defineProperty(this, \"registerHTMLInjector\", injector => {\n          this.htmlInjector = injector;\n        });\n\n        _defineProperty(this, \"saveReverseLog\", (reverseActionName, params, step) => {\n          const action = {\n            name: reverseActionName,\n            params,\n            step\n          };\n          this.reverseLogs.push(action);\n          this.forceUpdate();\n        });\n\n        _defineProperty(this, \"saveStepSnapshots\", (snapshot, step) => {\n          this.stepSnapshots.push({\n            snapshot,\n            step\n          });\n        });\n\n        _defineProperty(this, \"reverseToStep\", async targetStep => {\n          const snapshotOfTargetStep = this.stepSnapshots.find(({\n            step\n          }) => step === targetStep);\n\n          if (snapshotOfTargetStep) {\n            //@ts-ignore\n            const handler = this.getRef().handleReverse;\n            handler(snapshotOfTargetStep.snapshot);\n          }\n        });\n\n        _defineProperty(this, \"updateModel\", newModel => {\n          this.setState({\n            model: newModel\n          });\n        });\n\n        this.state = {\n          model: initObject.initModel(this.getPassingProps()),\n          isVisible: true\n        };\n        this.initialModel = this.state.model;\n        this.customTransformers = {};\n        this.reverseLogs = [];\n        this.stepSnapshots = [];\n        this.ref = React.createRef();\n      }\n\n      componentDidMount() {\n        const {\n          interactive\n        } = this.props;\n\n        if (interactive && _isFunction(this.htmlInjector)) {\n          this.htmlInjector();\n          CanvasObserver.register(this.htmlInjector);\n        }\n      }\n\n      componentDidUpdate(prevProps) {\n        const {\n          currentStep,\n          totalStep,\n          executedApiCount,\n          dropdownDisabled,\n          interactive,\n          controlled,\n          data\n        } = this.props;\n        const {\n          model\n        } = this.state;\n\n        if (keyExist(this.props, ['currentStep', 'totalStep', 'instructions'])) {\n          switch (getProgressDirection(currentStep, prevProps.currentStep, totalStep, executedApiCount !== prevProps.executedApiCount && prevProps.executedApiCount !== 0)) {\n            case 'forward':\n              this.saveStepSnapshots(model, currentStep);\n              this.handleForward();\n              break;\n\n            case 'backward':\n              this.reverseToStep(currentStep);\n              break;\n\n            case 'fastForward':\n              this.handleFastForward();\n              break;\n\n            case 'fastBackward':\n              this.handleFastBackward();\n              break;\n\n            case 'switch':\n              this.handleSwitchApi();\n              break;\n          }\n        }\n\n        if (interactive && dropdownDisabled !== prevProps.dropdownDisabled && _isFunction(this.htmlInjector)) {\n          this.htmlInjector();\n        } // Update according to controlled data\n\n\n        if (controlled) {\n          if (!_isEqual(data, prevProps.data)) {\n            const newModel = initObject.initModel(this.getPassingProps());\n            this.updateModel(newModel);\n          }\n        }\n      }\n\n      handleForward() {\n        // Treat each action as a transformation function which take a linkedListModel\n        // and return a new one. Consuming multiple actions is merely chaining those\n        // transformations together\n        // linkedListModel ---- action1 ----> linkedListModel1 ---- action2 ----> linkedListMode2 ---- action3 ----> linkedListModel3\n        const {\n          model\n        } = this.state;\n        const {\n          currentStep,\n          instructions\n        } = this.props;\n        const actionsToMakeAtThisStep = instructions[currentStep];\n        if (!actionsToMakeAtThisStep || !actionsToMakeAtThisStep.length) return; // This consume pipeline have many side effect in each step. Each\n        // method handle each action has their own side effect\n\n        const newArrayModel = this.consumeMultipleActions(actionsToMakeAtThisStep, model);\n        this.setState({\n          model: newArrayModel\n        });\n      }\n\n      consumeMultipleActions(actionList, currentModel, onlyTranformData) {\n        // Treat each action as a transformation function which take a linkedListModel\n        // and return a new one. Consuming multiple actions is merely chaining those\n        // transformations together\n        // linkedListModel ---- action1 ----> linkedListModel1 ---- action2 ----> linkedListMode2 ---- action3 ----> linkedListModel3\n        return actionList.reduce((finalModel, action) => {\n          // the main function of a handler is doing side effect before transform model\n          // a handler must also return a new model\n          // if no handler is specify, just transform model right away\n          const {\n            name,\n            params\n          } = action; //@ts-ignore\n\n          const customHandler = this.customTransformers[name];\n\n          if (typeof customHandler === 'function') {\n            return customHandler(finalModel, params, onlyTranformData);\n          } else {\n            //@ts-ignore\n            return initObject.dataTransformer(finalModel, name, params);\n          }\n        }, currentModel);\n      }\n\n      handleFastForward() {\n        const {\n          model\n        } = this.state;\n        const {\n          instructions\n        } = this.props;\n\n        const allActions = _flatMap(instructions); //@ts-ignore\n\n\n        const actionsGroupedByStep = _groupBy(allActions, item => item.step); // Loop through all the action one by one and keep updating the final model\n\n\n        let finalArrayModel = Object.entries(actionsGroupedByStep).reduce((currentModel, [step, actionsToMakeAtThisStep]) => {\n          this.saveStepSnapshots(currentModel, +step);\n          return this.consumeMultipleActions(actionsToMakeAtThisStep, currentModel, true);\n        }, model);\n        this.updateWithoutAnimation(finalArrayModel);\n      }\n\n      handleFastBackward() {\n        this.updateWithoutAnimation(this.initialModel);\n      }\n\n      updateWithoutAnimation(newLinkedListModel) {\n        this.setState({\n          model: newLinkedListModel,\n          isVisible: false\n        }, () => this.setState({\n          isVisible: true\n        }));\n      }\n\n      handleSwitchApi() {\n        const {\n          keepStateWhenSwitchingApi\n        } = this.props;\n\n        if (!keepStateWhenSwitchingApi) {\n          this.handleFastBackward();\n        }\n      }\n\n      getLastStepToReverse() {\n        const length = this.reverseLogs.length;\n        return length ? this.reverseLogs[length - 1] : null;\n      }\n\n      getRef() {\n        const component = this.ref.current;\n        return component || {};\n      }\n\n      getPassingProps() {\n        return _objectSpread({}, this.props, {}, this.state, {\n          registerCustomTransformer: this.registerCustomTransformer,\n          registerHTMLInjector: this.registerHTMLInjector,\n          updateModel: this.updateModel\n        });\n      }\n\n      render() {\n        const {\n          isVisible\n        } = this.state; //@ts-ignore\n\n        return isVisible && __jsx(Page, _extends({}, this.getPassingProps(), {\n          ref: this.ref\n        }));\n      }\n\n    }\n\n    return WrapperComponent; // return React.forwardRef((props: P, ref) => (\n    //   //@ts-ignore\n    //   <WrapperComponent innerRef={ref} {...props} />\n    // ));\n  };\n}\n\nexport default withDSCore;","map":null,"metadata":{},"sourceType":"module"}