{"ast":null,"code":"import _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _Object$entries from \"@babel/runtime-corejs2/core-js/object/entries\";\nimport { HASH_TABLE_UNIVERSAL_KEY_SIZE } from \"../../constants\";\nexport var caculateKeyHash = function caculateKeyHash(key, universalKeySize) {\n  var sum = key.split('').reduce(function (acc, letter) {\n    return acc + letter.charCodeAt(0);\n  }, 0);\n  return sum % universalKeySize;\n};\nexport var initLinearProbeHashTableData = function initLinearProbeHashTableData(data) {\n  var keys = [];\n  var memoryAddresses = [];\n\n  var findAvailableSlot = function findAvailableSlot(key) {\n    var hashAddress = caculateKeyHash(key, HASH_TABLE_UNIVERSAL_KEY_SIZE);\n\n    while (true) {\n      var memoryAddress = memoryAddresses.find(function (_ref) {\n        var key = _ref.key;\n        return key === hashAddress;\n      });\n      if (!memoryAddress) return hashAddress;\n      hashAddress++;\n    }\n  };\n\n  var insertKey = function insertKey(key, value, address) {\n    keys.push({\n      key: key,\n      value: value,\n      address: address\n    });\n  };\n\n  var insertMemoryAddress = function insertMemoryAddress(value, address) {\n    memoryAddresses.push({\n      key: address,\n      values: [value]\n    });\n  };\n\n  _Object$entries(data).forEach(function (_ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n        key = _ref3[0],\n        value = _ref3[1];\n\n    var addressToFill = findAvailableSlot(key);\n    insertKey(key, value, addressToFill);\n    insertMemoryAddress(value, addressToFill);\n  });\n\n  return {\n    keys: keys,\n    memoryAddresses: memoryAddresses\n  };\n};","map":null,"metadata":{},"sourceType":"module"}