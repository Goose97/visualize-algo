{"ast":null,"code":"import _pick from \"lodash/pick\";\nimport { TREE_LIKE_LEVEL_GAP, BST_CHILD_DISTANCE_FROM_PARENT, GRAPH_NODE_RADIUS } from \"../../constants\";\nimport { BinaryTreeNode } from 'instructions/BST/helper';\n// Also included null node\nexport const caculateTreeHeight = bstModel => {\n  if (!bstModel.length) return 0;\n  let biggestLevel = 0;\n\n  const findNodeByKey = nodeKey => bstModel.find(({\n    key\n  }) => key === nodeKey);\n\n  let stack = [{\n    node: bstModel[0],\n    level: 1\n  }]; // Do DFS to find tree height\n\n  while (stack.length) {\n    const {\n      node: {\n        left,\n        right\n      },\n      level\n    } = stack.pop();\n    biggestLevel = Math.max(biggestLevel, level);\n    const leftChild = findNodeByKey(left);\n    const rightChild = findNodeByKey(right);\n    if (leftChild) stack.push({\n      node: leftChild,\n      level: level + 1\n    });\n    if (rightChild) stack.push({\n      node: rightChild,\n      level: level + 1\n    });\n  }\n\n  return biggestLevel;\n};\nexport const isNodeCoordinateCollideWithOtherNode = (nodeCoordinate, currentModel) => {\n  const isIntersect = (nodeCoordinateA, nodeCoordinateB) => {\n    // If distance from A to B smaller than 2 * node radius then they are intersect\n    const distance = Math.sqrt((nodeCoordinateA.x - nodeCoordinateB.x) ** 2 + (nodeCoordinateA.y - nodeCoordinateB.y) ** 2);\n    return distance < 2 * GRAPH_NODE_RADIUS;\n  };\n\n  return currentModel.some(node => isIntersect(nodeCoordinate, _pick(node, ['x', 'y'])));\n};\n\nconst caculateTreeWidthBasedOnHeight = treeHeight => {\n  if (treeHeight === 2) return BST_CHILD_DISTANCE_FROM_PARENT * 2;\n  return caculateTreeWidthBasedOnHeight(treeHeight - 1) * 2 + 100;\n};\n\nconst caculateChildDistanceFromParentBasedOnLevel = (level, treeHeight) => {\n  if (level === treeHeight) {\n    const subTreeWidth = caculateTreeWidthBasedOnHeight(2);\n    return subTreeWidth / 2;\n  } else {\n    const subTreeWidth = caculateTreeWidthBasedOnHeight(treeHeight - level + 1);\n    return subTreeWidth / 2 + 40;\n  }\n};\n\nexport const caculateChildCoordinate = (parentCoordinate, level, treeHeight, leftOrRight) => {\n  const {\n    x,\n    y\n  } = parentCoordinate;\n  const distanceFromParentBasedOnLevel = caculateChildDistanceFromParentBasedOnLevel(level, treeHeight);\n  return {\n    x: x + (leftOrRight === 'left' ? -1 : 1) * distanceFromParentBasedOnLevel,\n    y: y + TREE_LIKE_LEVEL_GAP\n  };\n};\nexport const produceInitialBSTData = array => {\n  if (!array.length) return [];\n  let queue = [];\n  let result = [];\n  let counter = 0;\n  let key = 0;\n\n  for (let i = 0; i < array.length; i++) {\n    let val = array[i];\n    let parentNode = queue[0];\n    const newNode = val !== null ? new BinaryTreeNode(val, key++) : null;\n\n    if (newNode) {\n      queue.push({\n        key: newNode.key,\n        value: newNode.val,\n        left: null,\n        right: null\n      });\n    } else {\n      queue.push(null);\n    }\n\n    if (parentNode === undefined) continue;\n\n    if (counter === 0) {\n      // this node is left of parent node\n      if (parentNode) parentNode.left = newNode ? newNode.key : null;\n      counter++;\n    } else {\n      // this node is right of parent node\n      if (parentNode) parentNode.right = newNode ? newNode.key : null;\n      counter = 0;\n      result.push(queue.shift());\n    }\n  } //@ts-ignore\n\n\n  result.push(...queue);\n  return result.filter(item => !!item);\n};","map":null,"metadata":{},"sourceType":"module"}