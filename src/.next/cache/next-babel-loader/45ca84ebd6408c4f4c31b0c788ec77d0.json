{"ast":null,"code":"import produce from 'immer';\nimport { caculateKeyHash } from 'components/HashTable/helper';\nimport { HASH_TABLE_UNIVERSAL_KEY_SIZE } from \"../constants\"; // Nhận vào trạng thái hiện tại của data structure\n// và operation tương ứng. Trả về trạng thái mới\n\nconst transformHashTableModel = (currentModel, operation, payload) => {\n  switch (operation) {\n    case 'insert':\n      {\n        const [key, value] = payload;\n        return produce(currentModel, draft => {\n          const address = caculateKeyHash(key, HASH_TABLE_UNIVERSAL_KEY_SIZE);\n          let addressInfo = draft.memoryAddresses.find(({\n            key\n          }) => key === address);\n\n          if (addressInfo) {\n            addressInfo.values.unshift(value);\n          } else {\n            addressInfo = {\n              key: address,\n              values: [value]\n            };\n          }\n\n          draft.keys.push({\n            key,\n            value,\n            isNew: true,\n            address\n          });\n        });\n      }\n\n    case 'insertKey':\n      {\n        const [key, value] = payload;\n        return produce(currentModel, draft => {\n          const address = caculateKeyHash(key, HASH_TABLE_UNIVERSAL_KEY_SIZE);\n          draft.keys.push({\n            key,\n            value,\n            isNew: true,\n            address\n          });\n        });\n      }\n\n    case 'updateKeyAddress':\n      {\n        const [key, address] = payload;\n        return produce(currentModel, draft => {\n          const keyToUpdate = draft.keys.find(({\n            key: itemKey\n          }) => key === itemKey);\n          if (keyToUpdate) keyToUpdate.address = address;\n        });\n      }\n\n    case 'insertValue':\n      {\n        const [value, address] = payload;\n        return produce(currentModel, draft => {\n          let addressInfo = draft.memoryAddresses.find(({\n            key\n          }) => key === address);\n\n          if (addressInfo) {\n            addressInfo.values.unshift(value);\n          } else {\n            draft.memoryAddresses.push({\n              key: address,\n              values: [value]\n            });\n          }\n        });\n      }\n\n    case 'delete':\n      {\n        const [key] = payload;\n        return produce(currentModel, draft => {\n          var _draft$keys$find;\n\n          // Delete value in memory address\n          const address = caculateKeyHash(key, HASH_TABLE_UNIVERSAL_KEY_SIZE);\n          const memoryAddress = draft.memoryAddresses.find(({\n            key\n          }) => key === address);\n          const valueOfKey = (_draft$keys$find = draft.keys.find(({\n            key: itemKey\n          }) => key === itemKey)) === null || _draft$keys$find === void 0 ? void 0 : _draft$keys$find.value;\n          memoryAddress.values = memoryAddress.values.filter(value => value !== valueOfKey); // Delete key\n\n          const keyToDelete = draft.keys.findIndex(({\n            key: itemKey\n          }) => key === itemKey);\n          draft.keys.splice(keyToDelete, 1);\n        });\n      }\n\n    case 'toggleIsNew':\n      {\n        const [key] = payload;\n        return produce(currentModel, draft => {\n          const keyToToggle = draft.keys.find(({\n            key: itemKey\n          }) => key === itemKey);\n\n          if (keyToToggle) {\n            const oldIsNew = !!keyToToggle.isNew;\n            keyToToggle.isNew = !oldIsNew;\n          }\n        });\n      }\n\n    case 'highlightKey':\n      {\n        const [key] = payload;\n        return produce(currentModel, draft => {\n          const keyToHighlight = draft.keys.find(({\n            key: itemKey\n          }) => key === itemKey);\n          if (keyToHighlight) keyToHighlight.highlight = true;\n        });\n      }\n\n    case 'highlightAddress':\n      {\n        // Sometimes the address we want to highlight is not exist yet in modal\n        // insert a empty one in\n        const [address] = payload;\n        return produce(currentModel, draft => {\n          const addressToHighlight = draft.memoryAddresses.find(({\n            key\n          }) => key === address);\n          if (addressToHighlight) addressToHighlight.highlight = true;else {\n            const emptyAddress = {\n              key: address,\n              values: [],\n              highlight: true\n            };\n            draft.memoryAddresses.push(emptyAddress);\n          }\n        });\n      }\n\n    case 'dehighlightAddress':\n      {\n        const [address] = payload;\n        return produce(currentModel, draft => {\n          const addressToHighlight = draft.memoryAddresses.find(({\n            key\n          }) => key === address);\n          if (addressToHighlight) addressToHighlight.highlight = false;\n        });\n      }\n\n    case 'deleteKey':\n      {\n        const [key] = payload;\n        return produce(currentModel, draft => {\n          draft.keys = draft.keys.filter(({\n            key: itemKey\n          }) => key !== itemKey);\n        });\n      }\n\n    case 'deleteValue':\n      {\n        const [value, address] = payload;\n        return produce(currentModel, draft => {\n          const addressToDelete = draft.memoryAddresses.find(({\n            key\n          }) => key === address);\n\n          if (addressToDelete) {\n            const valuesAfterDelete = addressToDelete.values.filter(item => item !== value);\n            if (valuesAfterDelete.length) addressToDelete.values = valuesAfterDelete;else {\n              draft.memoryAddresses = draft.memoryAddresses.filter(({\n                key\n              }) => key !== address);\n            }\n          }\n        });\n      }\n\n    case 'resetAll':\n      {\n        return produce(currentModel, draft => {\n          draft.keys.forEach(key => key.highlight = false);\n          draft.memoryAddresses.forEach(address => address.highlight = false);\n        });\n      }\n\n    default:\n      return currentModel;\n  }\n};\n\nexport default transformHashTableModel;","map":null,"metadata":{},"sourceType":"module"}