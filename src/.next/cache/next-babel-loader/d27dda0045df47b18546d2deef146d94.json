{"ast":null,"code":"import _Reflect$construct from \"@babel/runtime-corejs2/core-js/reflect/construct\";\nimport _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime-corejs2/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime-corejs2/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport _pick from \"lodash/pick\";\nvar __jsx = React.createElement;\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(_Reflect$construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from 'react';\nimport { HighlightCircle } from 'components';\nimport { classNameHelper } from 'utils';\nimport withExtendClassName from 'hocs/withExtendClassName';\nexport var MemoryBlock = /*#__PURE__*/function (_Component) {\n  _inherits(MemoryBlock, _Component);\n\n  var _super = _createSuper(MemoryBlock);\n\n  function MemoryBlock(props) {\n    var _this;\n\n    _classCallCheck(this, MemoryBlock);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"labelText\", void 0);\n\n    _this.state = {};\n    _this.labelText = React.createRef();\n    return _this;\n  }\n\n  _createClass(MemoryBlock, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var visible = this.props.visible;\n\n      if (visible !== prevProps.visible) {\n        visible ? this.show() : this.hide();\n      }\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      var _this2 = this;\n\n      this.setState({\n        isHiding: true\n      });\n      setTimeout(function () {\n        _this2.setState({\n          isHiding: false\n        });\n      }, 500);\n    }\n  }, {\n    key: \"show\",\n    value: function show() {\n      var _this3 = this;\n\n      this.setState({\n        isShowing: true\n      });\n      setTimeout(function () {\n        _this3.setState({\n          isShowing: false\n        });\n      }, 500);\n    }\n  }, {\n    key: \"produceClassName\",\n    value: function produceClassName() {\n      var _this$props = this.props,\n          visible = _this$props.visible,\n          visited = _this$props.visited,\n          focus = _this$props.focus,\n          className = _this$props.className,\n          isNew = _this$props.isNew,\n          blur = _this$props.blur;\n      var _this$state = this.state,\n          isHiding = _this$state.isHiding,\n          isShowing = _this$state.isShowing;\n      return classNameHelper({\n        base: className,\n        disappearing: !!isHiding,\n        appearing: !!(isShowing || isNew),\n        invisible: !visible,\n        visited: !!visited,\n        focus: !!focus,\n        blur: !!blur\n      });\n    }\n  }, {\n    key: \"renderMemoryBlockContainer\",\n    value: function renderMemoryBlockContainer() {\n      var _this$props2 = this.props,\n          type = _this$props2.type,\n          x = _this$props2.x,\n          y = _this$props2.y,\n          width = _this$props2.width,\n          height = _this$props2.height;\n\n      switch (type) {\n        case 'rectangle':\n          return __jsx(\"rect\", _extends({}, _pick(this.props, ['x', 'y', 'width', 'height']), {\n            className: \"memory-block__block\"\n          }));\n\n        case 'round':\n          var cx = x + width / 2;\n          var cy = y + height / 2;\n          return __jsx(\"circle\", {\n            cx: cx,\n            cy: cy,\n            r: width / 2,\n            className: \"memory-block__block\"\n          }) // <rect\n          //   {...pick(this.props, ['x', 'y', 'width', 'height'])}\n          //   className='memory-block__block'\n          // ></rect>\n          ;\n      }\n    }\n  }, {\n    key: \"renderLabelText\",\n    value: function renderLabelText() {\n      var label = this.props.label;\n      return label && label.length && __jsx(\"g\", null, this.renderBackgroundOverlayForText(), __jsx(\"text\", _extends({}, this.getLabelTextCoordinate(), {\n        dominantBaseline: \"middle\",\n        textAnchor: \"middle\",\n        className: \"memory-block__text italic\",\n        ref: this.labelText\n      }), label.join(' / ')));\n    }\n  }, {\n    key: \"renderBackgroundOverlayForText\",\n    value: function renderBackgroundOverlayForText() {\n      var textElement = this.labelText.current;\n      if (!textElement) return null;\n\n      var _textElement$getBound = textElement.getBoundingClientRect(),\n          textWidth = _textElement$getBound.width,\n          textHeight = _textElement$getBound.height;\n\n      return __jsx(\"rect\", _extends({}, this.getLabelTextCoordinate(), {\n        transform: \"translate(-\".concat(textWidth / 2, \", -\").concat(textHeight / 2, \")\"),\n        width: textWidth,\n        height: textHeight,\n        className: \"fill-background\"\n      }));\n    }\n  }, {\n    key: \"getLabelTextCoordinate\",\n    value: function getLabelTextCoordinate() {\n      var _this$props3 = this.props,\n          labelDirection = _this$props3.labelDirection,\n          width = _this$props3.width,\n          height = _this$props3.height,\n          x = _this$props3.x,\n          y = _this$props3.y;\n      var direction = labelDirection || 'top';\n\n      switch (direction) {\n        case 'top':\n          return {\n            x: x + width / 2,\n            y: y - 20\n          };\n\n        case 'bottom':\n          return {\n            x: x + width / 2,\n            y: y + height + 20\n          };\n\n        case 'left':\n          return {\n            x: x - 30,\n            y: y + height / 2\n          };\n\n        case 'right':\n          return {\n            x: x + 20,\n            y: y + height / 2\n          };\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props4 = this.props,\n          value = _this$props4.value,\n          width = _this$props4.width,\n          height = _this$props4.height,\n          children = _this$props4.children,\n          textOffset = _this$props4.textOffset,\n          circleAround = _this$props4.circleAround,\n          transform = _this$props4.transform,\n          x = _this$props4.x,\n          y = _this$props4.y;\n      var xOffsetText = textOffset ? textOffset.x : 0;\n\n      var valueText = __jsx(\"text\", {\n        x: x + (width - xOffsetText) / 2,\n        y: y + height / 2,\n        dominantBaseline: \"middle\",\n        textAnchor: \"middle\",\n        className: \"memory-block__text value-text\"\n      }, value);\n\n      var highlightCircle = circleAround && __jsx(HighlightCircle, {\n        x: x + width / 2,\n        y: y + height / 2,\n        radius: width / 2 + 15\n      });\n\n      return __jsx(\"g\", {\n        className: this.produceClassName(),\n        transform: transform\n      }, this.renderMemoryBlockContainer(), valueText, this.renderLabelText(), children, highlightCircle);\n    }\n  }]);\n\n  return MemoryBlock;\n}(Component);\nexport default withExtendClassName('memory-block__wrapper has-transition')(MemoryBlock);","map":null,"metadata":{},"sourceType":"module"}