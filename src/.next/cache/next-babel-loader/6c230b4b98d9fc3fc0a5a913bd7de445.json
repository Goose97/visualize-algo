{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { Instructions } from 'instructions';\nimport { caculateKeyHash } from 'components/HashTable/helper';\nimport { HASH_TABLE_UNIVERSAL_KEY_SIZE } from \"../../constants\";\nimport { initLinearProbeHashTableData } from 'components/HashTable/helper';\nexport const hashTableInstruction = (data, operation, parameters) => {\n  switch (operation) {\n    case 'insert':\n      return insertInstruction(data, parameters);\n\n    case 'delete':\n      return deleteInstruction(data, parameters);\n\n    default:\n      return [];\n  }\n};\n\nconst insertInstruction = (data, {\n  key,\n  value,\n  collisionResolution\n}) => {\n  let instructions = new Instructions();\n\n  switch (collisionResolution) {\n    case 'chaining':\n      {\n        const hashedAddress = caculateKeyHash(key, HASH_TABLE_UNIVERSAL_KEY_SIZE);\n        instructions.pushActionsAndEndStep('hashTable', [{\n          name: 'insertKey',\n          params: [key, value, hashedAddress]\n        }, {\n          name: 'highlightKey',\n          params: [key]\n        }]);\n        instructions.pushActionsAndEndStep('hashTable', [{\n          name: 'insertValue',\n          params: [value, hashedAddress]\n        }, {\n          name: 'highlightAddress',\n          params: [hashedAddress]\n        }]);\n        instructions.pushActionsAndEndStep('hashTable', [{\n          name: 'resetAll',\n          params: []\n        }]);\n        return instructions.get();\n      }\n\n    case 'linearProbe':\n      {\n        const {\n          memoryAddresses\n        } = initLinearProbeHashTableData(data);\n        const addressValuesMap = memoryAddresses.reduce((acc, {\n          key,\n          values\n        }) => _objectSpread({}, acc, {\n          [key]: values\n        }), {});\n        let hashedAddress = caculateKeyHash(key, HASH_TABLE_UNIVERSAL_KEY_SIZE);\n        let displacement = 0;\n        instructions.pushActionsAndEndStep('hashTable', [{\n          name: 'insertKey',\n          params: [key, value, hashedAddress]\n        }, {\n          name: 'highlightKey',\n          params: [key]\n        }]); // Try to store in initital hash address, if already occupied, advance one address.\n        // Keep repeat till we find the empty slot or out of slot to try\n\n        let addressAttemptToFillValue;\n\n        while (true) {\n          // We only have to perform at most key size attempt\n          if (displacement >= HASH_TABLE_UNIVERSAL_KEY_SIZE) break;\n          addressAttemptToFillValue = (hashedAddress + displacement) % HASH_TABLE_UNIVERSAL_KEY_SIZE;\n          instructions.pushActionsAndEndStep('hashTable', [{\n            name: 'updateKeyAddress',\n            params: [key, addressAttemptToFillValue]\n          }, {\n            name: 'highlightAddress',\n            params: [addressAttemptToFillValue]\n          }]);\n\n          if (addressValuesMap[addressAttemptToFillValue]) {\n            instructions.pushActions('hashTable', [{\n              name: 'dehighlightAddress',\n              params: [addressAttemptToFillValue]\n            }]);\n            displacement++;\n          } else break;\n        }\n\n        instructions.pushActionsAndEndStep('hashTable', [{\n          name: 'insertValue',\n          params: [value, addressAttemptToFillValue]\n        }, {\n          name: 'updateKeyAddress',\n          params: [key, addressAttemptToFillValue]\n        }]);\n        instructions.pushActionsAndEndStep('hashTable', [{\n          name: 'resetAll',\n          params: []\n        }]);\n      }\n  }\n\n  return instructions.get();\n};\n\nconst deleteInstruction = (data, {\n  key: keyToDelete,\n  collisionResolution\n}) => {\n  let instructions = new Instructions();\n\n  switch (collisionResolution) {\n    case 'chaining':\n      {\n        const hashedAddress = caculateKeyHash(keyToDelete, HASH_TABLE_UNIVERSAL_KEY_SIZE);\n        instructions.pushActionsAndEndStep('hashTable', [{\n          name: 'highlightKey',\n          params: [keyToDelete]\n        }, {\n          name: 'highlightAddress',\n          params: [hashedAddress]\n        }]);\n        instructions.pushActionsAndEndStep('hashTable', [{\n          name: 'deleteValue',\n          params: [data[keyToDelete], hashedAddress]\n        }]);\n        instructions.pushActionsAndEndStep('hashTable', [{\n          name: 'deleteKey',\n          params: [keyToDelete]\n        }]);\n        instructions.pushActionsAndEndStep('hashTable', [{\n          name: 'resetAll',\n          params: []\n        }]);\n        break;\n      }\n\n    case 'linearProbe':\n      {\n        const {\n          keys,\n          memoryAddresses\n        } = initLinearProbeHashTableData(data);\n        const initialHashedAddress = caculateKeyHash(keyToDelete, HASH_TABLE_UNIVERSAL_KEY_SIZE);\n        const keyToDeleteObject = keys.find(({\n          key\n        }) => key === keyToDelete);\n        const realHashedAddress = keyToDeleteObject === null || keyToDeleteObject === void 0 ? void 0 : keyToDeleteObject.address; // We will try to find from the initial position, move one down if we can't find\n        // at current position. Do at most HASH_TABLE_UNIVERSAL_KEY_SIZE attempt\n\n        let displacement = 0;\n        let found = false;\n\n        while (true) {\n          if (displacement >= HASH_TABLE_UNIVERSAL_KEY_SIZE) break;\n          const currentCheckingAddress = (initialHashedAddress + displacement) % HASH_TABLE_UNIVERSAL_KEY_SIZE;\n          instructions.pushActionsAndEndStep('hashTable', [{\n            name: 'highlightKey',\n            params: [keyToDelete]\n          }, {\n            name: 'highlightAddress',\n            params: [currentCheckingAddress]\n          }, {\n            name: 'updateKeyAddress',\n            params: [keyToDelete, currentCheckingAddress]\n          }]); // Reach a empty memory address\n\n          const currentAddressInfo = memoryAddresses.find(({\n            key\n          }) => key === currentCheckingAddress);\n          if (!currentAddressInfo || !currentAddressInfo.values.length) break;\n\n          if (currentCheckingAddress === realHashedAddress) {\n            found = true;\n            break;\n          } // Move to next one\n\n\n          displacement++;\n          instructions.pushActions('hashTable', [{\n            name: 'dehighlightAddress',\n            params: [currentCheckingAddress]\n          }]);\n        }\n\n        if (found) {\n          const valueToDelete = keyToDeleteObject === null || keyToDeleteObject === void 0 ? void 0 : keyToDeleteObject.value;\n          instructions.pushActionsAndEndStep('hashTable', [{\n            name: 'deleteValue',\n            params: [valueToDelete, realHashedAddress]\n          }, {\n            name: 'deleteKey',\n            params: [keyToDelete]\n          }]);\n        }\n\n        instructions.pushActionsAndEndStep('hashTable', [{\n          name: 'resetAll',\n          params: []\n        }]);\n        break;\n      }\n  }\n\n  return instructions.get();\n}; // const getCodeLine = (operation: HashTable.Api): ObjectType<string> => {\n//   switch (operation) {\n//     // case 'bubbleSort':\n//     //   return {\n//     //     init: '12-18',\n//     //     compare: '14',\n//     //     swap: '15',\n//     //     iteration: '12',\n//     //     step: '13',\n//     //   };\n//     // case 'selectionSort':\n//     //   return {\n//     //     init: '1',\n//     //     swap: '10-14',\n//     //     iteration: '3',\n//     //     findMin: '5',\n//     //     updateMin: '6-7',\n//     //     compare: '6',\n//     //   };\n//     // case 'insertionSort':\n//     //   return {\n//     //     init: '1',\n//     //     swap: '10-14',\n//     //     iteration: '3',\n//     //     findMin: '5',\n//     //     updateMin: '6-7',\n//     //     compare: '6',\n//     //   };\n//     default:\n//       return {};\n//   }\n// };","map":null,"metadata":{},"sourceType":"module"}