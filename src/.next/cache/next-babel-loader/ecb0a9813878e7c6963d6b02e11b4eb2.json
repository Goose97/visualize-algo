{"ast":null,"code":"import _last from \"lodash/last\";\nimport { Instructions } from 'instructions';\nexport const graphInstruction = (data, operation, parameters) => {\n  switch (operation) {\n    case 'dfs':\n      return dfsInstruction(data, parameters);\n\n    case 'bfs':\n      return bfsInstruction(data, parameters);\n\n    default:\n      return [];\n  }\n};\n\nconst dfsInstruction = (data, {\n  startAt\n}) => {\n  let instructions = new Instructions(); // const codeLines = getCodeLine('dfs');\n  // Start make instruction\n\n  let stack = [];\n  let visited = new Set([]);\n  stack.push(startAt);\n  instructions.pushActionsAndEndStep('stack', [{\n    name: 'push',\n    params: [startAt]\n  }]);\n\n  while (stack.length) {\n    // Check the node on top of the stack\n    const lastNodeKey = _last(stack);\n\n    instructions.pushActions('graph', [{\n      name: 'resetHighlight',\n      params: []\n    }]);\n    instructions.pushActions('graph', [{\n      name: 'focus',\n      params: [lastNodeKey]\n    }]); // Highlight all adjacent nodes\n\n    const adjacentNodes = data.find(({\n      key\n    }) => key === lastNodeKey).adjacentNodes;\n    adjacentNodes.forEach(nodeKey => {\n      instructions.pushActions('graph', [{\n        name: 'highlightEdge',\n        params: [lastNodeKey, nodeKey]\n      }]);\n      instructions.pushActions('graph', [{\n        name: 'highlight',\n        params: [nodeKey]\n      }]);\n    });\n    instructions.endStep(); // Filter out nodes which are already in stack or visited\n\n    const adjacentNodesWhichNotVisited = adjacentNodes.filter(key => !visited.has(key) && !stack.includes(key));\n\n    if (adjacentNodesWhichNotVisited.length) {\n      // Still has node to push to stack\n      adjacentNodesWhichNotVisited.forEach(key => {\n        stack.push(key);\n        instructions.pushActions('stack', [{\n          name: 'push',\n          params: [key]\n        }]);\n      });\n      instructions.endStep();\n    } else {\n      // Reach leaf node, pop it out\n      const nodeKeyToPop = stack.pop();\n      visited.add(nodeKeyToPop);\n      instructions.pushActions('stack', [{\n        name: 'pop',\n        params: []\n      }]);\n      instructions.pushActions('array', [{\n        name: 'push',\n        params: [nodeKeyToPop]\n      }]);\n      instructions.pushActionsAndEndStep('graph', [{\n        name: 'visited',\n        params: [nodeKeyToPop]\n      }]);\n    }\n  }\n\n  instructions.pushActionsAndEndStep('graph', [{\n    name: 'resetAll',\n    params: []\n  }]);\n  return instructions.get();\n};\n\nconst bfsInstruction = (data, {\n  startAt\n}) => {\n  let instructions = new Instructions(); // const codeLines = getCodeLine('bfs');\n  // Start make instruction\n\n  let queue = [];\n  let visited = new Set([]);\n  queue.push(startAt);\n  instructions.pushActionsAndEndStep('queue', [{\n    name: 'enqueue',\n    params: [startAt]\n  }]);\n\n  while (queue.length) {\n    // Highlight all adjacent nodes\n    const currentNodeKey = queue[0];\n    const currentNode = data.find(({\n      key\n    }) => key === currentNodeKey);\n    const adjacentNodes = currentNode ? currentNode.adjacentNodes : [];\n    instructions.pushActions('graph', [{\n      name: 'focus',\n      params: [currentNodeKey]\n    }]);\n    instructions.pushActions('graph', [{\n      name: 'resetHighlight',\n      params: []\n    }]);\n    adjacentNodes.forEach(nodeKey => {\n      instructions.pushActions('graph', [{\n        name: 'highlight',\n        params: [nodeKey]\n      }]);\n      instructions.pushActions('graph', [{\n        name: 'highlightEdge',\n        params: [currentNodeKey, nodeKey]\n      }]);\n    });\n    instructions.endStep(); // Push all adjacent nodes which are not visited or in queue to queue\n\n    const adjacentNodesWhichNotVisited = adjacentNodes.filter(key => !visited.has(key) && !queue.includes(key));\n    adjacentNodesWhichNotVisited.forEach(key => {\n      queue.push(key);\n      instructions.pushActions('queue', [{\n        name: 'enqueue',\n        params: [key]\n      }]);\n    });\n    if (adjacentNodesWhichNotVisited.length) instructions.endStep(); // Dequeue and mark the current node as visited, push current node to result array\n\n    queue.shift();\n    visited.add(currentNodeKey);\n    instructions.pushActions('queue', [{\n      name: 'dequeue',\n      params: []\n    }]);\n    instructions.pushActions('array', [{\n      name: 'push',\n      params: [currentNodeKey]\n    }]);\n    instructions.pushActionsAndEndStep('graph', [{\n      name: 'visited',\n      params: [currentNodeKey]\n    }]);\n  }\n\n  instructions.pushActionsAndEndStep('graph', [{\n    name: 'resetAll',\n    params: []\n  }]);\n  return instructions.get();\n}; // const getCodeLine = (operation: Graph.Api): ObjectType<string> => {\n//   switch (operation) {\n//     default:\n//       return {};\n//   }\n// };","map":null,"metadata":{},"sourceType":"module"}