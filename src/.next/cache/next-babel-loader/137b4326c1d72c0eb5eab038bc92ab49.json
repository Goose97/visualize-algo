{"ast":null,"code":"import _pick from \"lodash/pick\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { Component } from 'react';\nimport withDSCore from 'hocs/withDSCore';\nimport ArrayMemoryBlock from \"./ArrayMemoryBlock\";\nimport SortSeperationLine from \"./SortSeperationLine\";\nimport ArrayHTML from \"./ArrayHTML\";\nimport transformArrayModel from 'transformers/Array';\nimport { ARRAY_BLOCK_WIDTH } from \"../../constants\";\n\nclass ArrayDS extends Component {\n  // save initial X so we can perform animation\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"wrapperRef\", void 0);\n\n    _defineProperty(this, \"sortingLineInitialX\", void 0);\n\n    _defineProperty(this, \"injectHTMLIntoCanvas\", () => {\n      const {\n        handleExecuteApi,\n        dropdownDisabled,\n        model\n      } = this.props;\n      setTimeout(() => {\n        ArrayHTML.renderToView({\n          model,\n          wrapperElement: this.wrapperRef.current,\n          coordinate: _pick(this.props, ['x', 'y']),\n          apiHandler: handleExecuteApi,\n          disabled: dropdownDisabled\n        });\n      }, 0);\n    });\n\n    _defineProperty(this, \"setUnsortedLine\", (currentModel, [key]) => {\n      const {\n        sortingState\n      } = this.state;\n      const elementWithLine = currentModel.find(({\n        key: itemKey\n      }) => itemKey === key);\n      if (!elementWithLine) return currentModel;\n      this.setState({\n        sortingState: Object.assign({}, sortingState, {\n          currentSortingElementIndex: elementWithLine.index\n        })\n      });\n      return currentModel;\n    });\n\n    _defineProperty(this, \"setCurrentInsertionSortNode\", (currentModel, [key]) => {\n      const {\n        sortingState\n      } = this.state;\n      const currentSortingElement = currentModel.find(({\n        key: itemKey\n      }) => key === itemKey);\n      this.setState({\n        sortingState: Object.assign({}, sortingState, {\n          currentSortingElementKey: currentSortingElement === null || currentSortingElement === void 0 ? void 0 : currentSortingElement.key\n        })\n      });\n      return currentModel;\n    });\n\n    _defineProperty(this, \"unsetCurrentInsertionSortNode\", currentModel => {\n      const {\n        sortingState\n      } = this.state;\n      this.setState({\n        sortingState: Object.assign({}, sortingState, {\n          currentSortingElementKey: null\n        })\n      });\n      return currentModel;\n    });\n\n    _defineProperty(this, \"resetAll\", currentModel => {\n      this.setState({\n        sortingState: {}\n      });\n      return transformArrayModel(currentModel, 'resetAll', []);\n    });\n\n    _defineProperty(this, \"renderSeparationLine\", () => {\n      const {\n        sortingState: {\n          currentSortingElementIndex\n        }\n      } = this.state;\n      const {\n        currentApi\n      } = this.props;\n      if (currentSortingElementIndex == null) return null; // Because line could appear before or after the block, we need to plus one if needed\n\n      const getActualLineIndex = () => {\n        const {\n          sortingState: {\n            currentSortingElementIndex\n          }\n        } = this.state;\n        const {\n          currentApi\n        } = this.props;\n\n        switch (currentApi) {\n          case 'selectionSort':\n          case 'bubbleSort':\n            return currentSortingElementIndex;\n\n          case 'insertionSort':\n            return currentSortingElementIndex + 1;\n        }\n      };\n\n      const x = ARRAY_BLOCK_WIDTH * getActualLineIndex();\n      if (this.sortingLineInitialX === undefined) this.sortingLineInitialX = x;\n      return __jsx(SortSeperationLine, {\n        currentApi: currentApi,\n        initialX: this.sortingLineInitialX,\n        currentX: x\n      });\n    });\n\n    this.state = {\n      isVisible: true,\n      sortingState: {}\n    };\n    this.wrapperRef = React.createRef(); // Register custom transformer\n\n    props.registerCustomTransformer({\n      push: this.push,\n      setUnsortedLine: this.setUnsortedLine,\n      setCurrentInsertionSortNode: this.setCurrentInsertionSortNode,\n      unsetCurrentInsertionSortNode: this.unsetCurrentInsertionSortNode,\n      resetAll: this.resetAll\n    }); // Register HTML injector\n\n    props.registerHTMLInjector(this.injectHTMLIntoCanvas);\n  }\n\n  static initArrayModel(props) {\n    return props.initialData.map((value, index) => ({\n      value,\n      index,\n      visible: true,\n      visited: false,\n      key: index,\n      focus: false\n    }));\n  }\n\n  componentDidUpdate(prevProps) {\n    const {\n      currentApi\n    } = this.props;\n\n    if (currentApi !== prevProps.currentApi) {\n      this.setState({\n        sortingState: {}\n      });\n      this.sortingLineInitialX = undefined;\n    }\n  }\n\n  // Custom transformers\n  push(currentModel, params) {\n    const biggestKey = currentModel.length ? Math.max(...currentModel.map(({\n      key\n    }) => key)) : -1;\n    const newArrayNode = {\n      value: params[0],\n      key: biggestKey + 1,\n      index: currentModel.length,\n      visible: true\n    };\n    return transformArrayModel(currentModel, 'push', [newArrayNode]);\n  }\n\n  renderCurrentSortingItem() {\n    const {\n      sortingState: {\n        currentSortingElementIndex,\n        currentSortingElementKey\n      }\n    } = this.state;\n    const {\n      blockType\n    } = this.props;\n    if (currentSortingElementKey == undefined) return null;\n    const currentSortingNode = this.findArrayNodeByKey(currentSortingElementKey);\n    if (currentSortingElementIndex === undefined || currentSortingNode === undefined) return null;\n    return __jsx(ArrayMemoryBlock, {\n      visible: true,\n      value: null,\n      index: currentSortingElementIndex + 1,\n      blockType: blockType,\n      transform: \"translate(0, 100)\"\n    });\n  }\n\n  findArrayNodeByKey(key) {\n    const {\n      model\n    } = this.props;\n    return model.find(({\n      key: keyToFind\n    }) => key === keyToFind);\n  }\n\n  checkIndexState(index, stateProperty) {\n    const {\n      model\n    } = this.props;\n    const arrayItem = model.find(({\n      index: itemIndex\n    }) => index === itemIndex);\n    if (!arrayItem) return false;\n    return !!arrayItem[stateProperty];\n  }\n\n  render() {\n    const {\n      sortingState: {\n        currentSortingElementKey\n      }\n    } = this.state;\n    const {\n      blockType,\n      model\n    } = this.props;\n    const hollowArrayMemoryBlock = model.map(({\n      key\n    }, index) => __jsx(ArrayMemoryBlock, {\n      key: key,\n      visible: true,\n      value: null,\n      index: index,\n      blockType: blockType,\n      blur: this.checkIndexState(index, 'blur'),\n      focus: this.checkIndexState(index, 'focus')\n    }));\n    const arrayMemoryBlock = model.map(arrayNode => {\n      const {\n        key\n      } = arrayNode;\n      return __jsx(ArrayMemoryBlock, _extends({}, arrayNode, {\n        blockType: blockType,\n        className: \"array-memory-block--only-value\",\n        isInsertionSorting: currentSortingElementKey === key,\n        labelDirection: \"bottom\"\n      }));\n    });\n    return __jsx(React.Fragment, null, __jsx(\"use\", _extends({\n      href: \"#array\"\n    }, _pick(this.props, ['x', 'y']), {\n      ref: this.wrapperRef\n    })), __jsx(\"defs\", null, __jsx(\"g\", {\n      id: \"array\"\n    }, this.renderCurrentSortingItem(), hollowArrayMemoryBlock, arrayMemoryBlock, this.renderSeparationLine())));\n  }\n\n}\n\nexport default withDSCore({\n  initModel: ArrayDS.initArrayModel,\n  dataTransformer: transformArrayModel\n})(ArrayDS);","map":null,"metadata":{},"sourceType":"module"}