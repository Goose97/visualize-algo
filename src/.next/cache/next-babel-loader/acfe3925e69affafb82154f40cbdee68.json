{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _Reflect$construct from \"@babel/runtime-corejs2/core-js/reflect/construct\";\nimport _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _Object$entries from \"@babel/runtime-corejs2/core-js/object/entries\";\nimport _Promise from \"@babel/runtime-corejs2/core-js/promise\";\nimport _regeneratorRuntime from \"@babel/runtime-corejs2/regenerator\";\nimport _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime-corejs2/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime-corejs2/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport _isEqual from \"lodash/isEqual\";\nimport _isFunction from \"lodash/isFunction\";\nimport _groupBy from \"lodash/groupBy\";\nimport _flatMap from \"lodash/flatMap\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(_Reflect$construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from 'react';\nimport { CanvasObserver } from 'components';\nimport { keyExist, getProgressDirection } from 'utils';\n\nfunction withDSCore(initObject) {\n  return function (Page) {\n    var WrapperComponent = /*#__PURE__*/function (_Component) {\n      _inherits(WrapperComponent, _Component);\n\n      var _super = _createSuper(WrapperComponent);\n\n      // DS core stuff\n      // Reverse related stuff\n      function WrapperComponent(props) {\n        var _this;\n\n        _classCallCheck(this, WrapperComponent);\n\n        _this = _super.call(this, props);\n\n        _defineProperty(_assertThisInitialized(_this), \"initialModel\", void 0);\n\n        _defineProperty(_assertThisInitialized(_this), \"customTransformers\", void 0);\n\n        _defineProperty(_assertThisInitialized(_this), \"htmlInjector\", void 0);\n\n        _defineProperty(_assertThisInitialized(_this), \"reverseLogs\", void 0);\n\n        _defineProperty(_assertThisInitialized(_this), \"stepSnapshots\", void 0);\n\n        _defineProperty(_assertThisInitialized(_this), \"ref\", void 0);\n\n        _defineProperty(_assertThisInitialized(_this), \"handleReverse\", function (stateOfPreviousStep) {\n          _this.setState({\n            model: stateOfPreviousStep\n          });\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"registerCustomTransformer\", function (callbackWithAction) {\n          //@ts-ignore\n          _Object$assign(_this.customTransformers, callbackWithAction);\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"registerHTMLInjector\", function (injector) {\n          _this.htmlInjector = injector;\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"saveReverseLog\", function (reverseActionName, params, step) {\n          var action = {\n            name: reverseActionName,\n            params: params,\n            step: step\n          };\n\n          _this.reverseLogs.push(action);\n\n          _this.forceUpdate();\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"saveStepSnapshots\", function (snapshot, step) {\n          _this.stepSnapshots.push({\n            snapshot: snapshot,\n            step: step\n          });\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"reverseToStep\", function _callee(targetStep) {\n          var snapshotOfTargetStep, handler;\n          return _regeneratorRuntime.async(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  snapshotOfTargetStep = _this.stepSnapshots.find(function (_ref) {\n                    var step = _ref.step;\n                    return step === targetStep;\n                  });\n\n                  if (snapshotOfTargetStep) {\n                    //@ts-ignore\n                    handler = _this.getRef().handleReverse;\n                    handler(snapshotOfTargetStep.snapshot);\n                  }\n\n                case 2:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, null, null, null, _Promise);\n        });\n\n        _defineProperty(_assertThisInitialized(_this), \"updateModel\", function (newModel) {\n          _this.setState({\n            model: newModel\n          });\n        });\n\n        _this.state = {\n          model: initObject.initModel(_this.getPassingProps()),\n          isVisible: true\n        };\n        _this.initialModel = _this.state.model;\n        _this.customTransformers = {};\n        _this.reverseLogs = [];\n        _this.stepSnapshots = [];\n        _this.ref = React.createRef();\n        return _this;\n      }\n\n      _createClass(WrapperComponent, [{\n        key: \"componentDidMount\",\n        value: function componentDidMount() {\n          var interactive = this.props.interactive;\n\n          if (interactive && _isFunction(this.htmlInjector)) {\n            this.htmlInjector();\n            CanvasObserver.register(this.htmlInjector);\n          }\n        }\n      }, {\n        key: \"componentDidUpdate\",\n        value: function componentDidUpdate(prevProps) {\n          var _this$props = this.props,\n              currentStep = _this$props.currentStep,\n              totalStep = _this$props.totalStep,\n              executedApiCount = _this$props.executedApiCount,\n              dropdownDisabled = _this$props.dropdownDisabled,\n              interactive = _this$props.interactive,\n              controlled = _this$props.controlled,\n              data = _this$props.data;\n          var model = this.state.model;\n\n          if (keyExist(this.props, ['currentStep', 'totalStep', 'instructions'])) {\n            switch (getProgressDirection(currentStep, prevProps.currentStep, totalStep, executedApiCount !== prevProps.executedApiCount && prevProps.executedApiCount !== 0)) {\n              case 'forward':\n                this.saveStepSnapshots(model, currentStep);\n                this.handleForward();\n                break;\n\n              case 'backward':\n                this.reverseToStep(currentStep);\n                break;\n\n              case 'fastForward':\n                this.handleFastForward();\n                break;\n\n              case 'fastBackward':\n                this.handleFastBackward();\n                break;\n\n              case 'switch':\n                this.handleSwitchApi();\n                break;\n            }\n          }\n\n          if (interactive && dropdownDisabled !== prevProps.dropdownDisabled && _isFunction(this.htmlInjector)) {\n            this.htmlInjector();\n          } // Update according to controlled data\n\n\n          if (controlled) {\n            if (!_isEqual(data, prevProps.data)) {\n              var newModel = initObject.initModel(this.getPassingProps());\n              this.updateModel(newModel);\n            }\n          }\n        }\n      }, {\n        key: \"handleForward\",\n        value: function handleForward() {\n          // Treat each action as a transformation function which take a linkedListModel\n          // and return a new one. Consuming multiple actions is merely chaining those\n          // transformations together\n          // linkedListModel ---- action1 ----> linkedListModel1 ---- action2 ----> linkedListMode2 ---- action3 ----> linkedListModel3\n          var model = this.state.model;\n          var _this$props2 = this.props,\n              currentStep = _this$props2.currentStep,\n              instructions = _this$props2.instructions;\n          var actionsToMakeAtThisStep = instructions[currentStep];\n          if (!actionsToMakeAtThisStep || !actionsToMakeAtThisStep.length) return; // This consume pipeline have many side effect in each step. Each\n          // method handle each action has their own side effect\n\n          var newArrayModel = this.consumeMultipleActions(actionsToMakeAtThisStep, model);\n          this.setState({\n            model: newArrayModel\n          });\n        }\n      }, {\n        key: \"consumeMultipleActions\",\n        value: function consumeMultipleActions(actionList, currentModel, onlyTranformData) {\n          var _this2 = this;\n\n          // Treat each action as a transformation function which take a linkedListModel\n          // and return a new one. Consuming multiple actions is merely chaining those\n          // transformations together\n          // linkedListModel ---- action1 ----> linkedListModel1 ---- action2 ----> linkedListMode2 ---- action3 ----> linkedListModel3\n          return actionList.reduce(function (finalModel, action) {\n            // the main function of a handler is doing side effect before transform model\n            // a handler must also return a new model\n            // if no handler is specify, just transform model right away\n            var name = action.name,\n                params = action.params; //@ts-ignore\n\n            var customHandler = _this2.customTransformers[name];\n\n            if (typeof customHandler === 'function') {\n              return customHandler(finalModel, params, onlyTranformData);\n            } else {\n              //@ts-ignore\n              return initObject.dataTransformer(finalModel, name, params);\n            }\n          }, currentModel);\n        }\n      }, {\n        key: \"handleFastForward\",\n        value: function handleFastForward() {\n          var _this3 = this;\n\n          var model = this.state.model;\n          var instructions = this.props.instructions;\n\n          var allActions = _flatMap(instructions); //@ts-ignore\n\n\n          var actionsGroupedByStep = _groupBy(allActions, function (item) {\n            return item.step;\n          }); // Loop through all the action one by one and keep updating the final model\n\n\n          var finalArrayModel = _Object$entries(actionsGroupedByStep).reduce(function (currentModel, _ref2) {\n            var _ref3 = _slicedToArray(_ref2, 2),\n                step = _ref3[0],\n                actionsToMakeAtThisStep = _ref3[1];\n\n            _this3.saveStepSnapshots(currentModel, +step);\n\n            return _this3.consumeMultipleActions(actionsToMakeAtThisStep, currentModel, true);\n          }, model);\n\n          this.updateWithoutAnimation(finalArrayModel);\n        }\n      }, {\n        key: \"handleFastBackward\",\n        value: function handleFastBackward() {\n          this.updateWithoutAnimation(this.initialModel);\n        }\n      }, {\n        key: \"updateWithoutAnimation\",\n        value: function updateWithoutAnimation(newLinkedListModel) {\n          var _this4 = this;\n\n          this.setState({\n            model: newLinkedListModel,\n            isVisible: false\n          }, function () {\n            return _this4.setState({\n              isVisible: true\n            });\n          });\n        }\n      }, {\n        key: \"handleSwitchApi\",\n        value: function handleSwitchApi() {\n          var keepStateWhenSwitchingApi = this.props.keepStateWhenSwitchingApi;\n\n          if (!keepStateWhenSwitchingApi) {\n            this.handleFastBackward();\n          }\n        }\n      }, {\n        key: \"getLastStepToReverse\",\n        value: function getLastStepToReverse() {\n          var length = this.reverseLogs.length;\n          return length ? this.reverseLogs[length - 1] : null;\n        }\n      }, {\n        key: \"getRef\",\n        value: function getRef() {\n          var component = this.ref.current;\n          return component || {};\n        }\n      }, {\n        key: \"getPassingProps\",\n        value: function getPassingProps() {\n          return _objectSpread({}, this.props, {}, this.state, {\n            registerCustomTransformer: this.registerCustomTransformer,\n            registerHTMLInjector: this.registerHTMLInjector,\n            updateModel: this.updateModel\n          });\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var isVisible = this.state.isVisible; //@ts-ignore\n\n          return isVisible && __jsx(Page, _extends({}, this.getPassingProps(), {\n            ref: this.ref\n          }));\n        }\n      }]);\n\n      return WrapperComponent;\n    }(Component);\n\n    return WrapperComponent; // return React.forwardRef((props: P, ref) => (\n    //   //@ts-ignore\n    //   <WrapperComponent innerRef={ref} {...props} />\n    // ));\n  };\n}\n\nexport default withDSCore;","map":null,"metadata":{},"sourceType":"module"}