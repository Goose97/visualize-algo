{"ast":null,"code":"import _Set from \"@babel/runtime-corejs2/core-js/set\";\nimport _last from \"lodash/last\";\nimport { Instructions } from 'instructions';\nexport var graphInstruction = function graphInstruction(data, operation, parameters) {\n  switch (operation) {\n    case 'dfs':\n      return dfsInstruction(data, parameters);\n\n    case 'bfs':\n      return bfsInstruction(data, parameters);\n\n    default:\n      return [];\n  }\n};\n\nvar dfsInstruction = function dfsInstruction(data, _ref) {\n  var startAt = _ref.startAt;\n  var instructions = new Instructions(); // const codeLines = getCodeLine('dfs');\n  // Start make instruction\n\n  var stack = [];\n  var visited = new _Set([]);\n  stack.push(startAt);\n  instructions.pushActionsAndEndStep('stack', [{\n    name: 'push',\n    params: [startAt]\n  }]);\n\n  var _loop = function _loop() {\n    // Check the node on top of the stack\n    var lastNodeKey = _last(stack);\n\n    instructions.pushActions('graph', [{\n      name: 'resetHighlight',\n      params: []\n    }]);\n    instructions.pushActions('graph', [{\n      name: 'focus',\n      params: [lastNodeKey]\n    }]); // Highlight all adjacent nodes\n\n    var adjacentNodes = data.find(function (_ref2) {\n      var key = _ref2.key;\n      return key === lastNodeKey;\n    }).adjacentNodes;\n    adjacentNodes.forEach(function (nodeKey) {\n      instructions.pushActions('graph', [{\n        name: 'highlightEdge',\n        params: [lastNodeKey, nodeKey]\n      }]);\n      instructions.pushActions('graph', [{\n        name: 'highlight',\n        params: [nodeKey]\n      }]);\n    });\n    instructions.endStep(); // Filter out nodes which are already in stack or visited\n\n    var adjacentNodesWhichNotVisited = adjacentNodes.filter(function (key) {\n      return !visited.has(key) && !stack.includes(key);\n    });\n\n    if (adjacentNodesWhichNotVisited.length) {\n      // Still has node to push to stack\n      adjacentNodesWhichNotVisited.forEach(function (key) {\n        stack.push(key);\n        instructions.pushActions('stack', [{\n          name: 'push',\n          params: [key]\n        }]);\n      });\n      instructions.endStep();\n    } else {\n      // Reach leaf node, pop it out\n      var nodeKeyToPop = stack.pop();\n      visited.add(nodeKeyToPop);\n      instructions.pushActions('stack', [{\n        name: 'pop',\n        params: []\n      }]);\n      instructions.pushActions('array', [{\n        name: 'push',\n        params: [nodeKeyToPop]\n      }]);\n      instructions.pushActionsAndEndStep('graph', [{\n        name: 'visited',\n        params: [nodeKeyToPop]\n      }]);\n    }\n  };\n\n  while (stack.length) {\n    _loop();\n  }\n\n  instructions.pushActionsAndEndStep('graph', [{\n    name: 'resetAll',\n    params: []\n  }]);\n  return instructions.get();\n};\n\nvar bfsInstruction = function bfsInstruction(data, _ref3) {\n  var startAt = _ref3.startAt;\n  var instructions = new Instructions(); // const codeLines = getCodeLine('bfs');\n  // Start make instruction\n\n  var queue = [];\n  var visited = new _Set([]);\n  queue.push(startAt);\n  instructions.pushActionsAndEndStep('queue', [{\n    name: 'enqueue',\n    params: [startAt]\n  }]);\n\n  var _loop2 = function _loop2() {\n    // Highlight all adjacent nodes\n    var currentNodeKey = queue[0];\n    var currentNode = data.find(function (_ref4) {\n      var key = _ref4.key;\n      return key === currentNodeKey;\n    });\n    var adjacentNodes = currentNode ? currentNode.adjacentNodes : [];\n    instructions.pushActions('graph', [{\n      name: 'focus',\n      params: [currentNodeKey]\n    }]);\n    instructions.pushActions('graph', [{\n      name: 'resetHighlight',\n      params: []\n    }]);\n    adjacentNodes.forEach(function (nodeKey) {\n      instructions.pushActions('graph', [{\n        name: 'highlight',\n        params: [nodeKey]\n      }]);\n      instructions.pushActions('graph', [{\n        name: 'highlightEdge',\n        params: [currentNodeKey, nodeKey]\n      }]);\n    });\n    instructions.endStep(); // Push all adjacent nodes which are not visited or in queue to queue\n\n    var adjacentNodesWhichNotVisited = adjacentNodes.filter(function (key) {\n      return !visited.has(key) && !queue.includes(key);\n    });\n    adjacentNodesWhichNotVisited.forEach(function (key) {\n      queue.push(key);\n      instructions.pushActions('queue', [{\n        name: 'enqueue',\n        params: [key]\n      }]);\n    });\n    if (adjacentNodesWhichNotVisited.length) instructions.endStep(); // Dequeue and mark the current node as visited, push current node to result array\n\n    queue.shift();\n    visited.add(currentNodeKey);\n    instructions.pushActions('queue', [{\n      name: 'dequeue',\n      params: []\n    }]);\n    instructions.pushActions('array', [{\n      name: 'push',\n      params: [currentNodeKey]\n    }]);\n    instructions.pushActionsAndEndStep('graph', [{\n      name: 'visited',\n      params: [currentNodeKey]\n    }]);\n  };\n\n  while (queue.length) {\n    _loop2();\n  }\n\n  instructions.pushActionsAndEndStep('graph', [{\n    name: 'resetAll',\n    params: []\n  }]);\n  return instructions.get();\n}; // const getCodeLine = (operation: Graph.Api): ObjectType<string> => {\n//   switch (operation) {\n//     default:\n//       return {};\n//   }\n// };","map":null,"metadata":{},"sourceType":"module"}