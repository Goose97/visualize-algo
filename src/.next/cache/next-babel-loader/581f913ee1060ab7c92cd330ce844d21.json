{"ast":null,"code":"import _pick from \"lodash/pick\";\nimport _flatMap from \"lodash/flatMap\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { Component } from 'react';\nimport { GraphMemoryBlock, GraphLikeEdges } from 'components';\nimport BinarySearchTreeHTML from \"./BinarySearchTreeHTML\";\nimport withDSCore from 'hocs/withDSCore';\nimport transformBSTModel from 'transformers/BST';\nimport { caculateTreeHeight, caculateChildCoordinate, isNodeCoordinateCollideWithOtherNode, produceInitialBSTData } from \"./helper\";\nexport class BinarySearchTreeDS extends Component {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"wrapperRef\", void 0);\n\n    _defineProperty(this, \"visit\", (currentModel, params) => {\n      const [nodeKeyToStart, nodeKeyToVisit] = params;\n      this.addNodeToVisitingList(nodeKeyToVisit);\n      setTimeout(() => {\n        this.handleAfterVisitAnimationFinish(currentModel, nodeKeyToStart, nodeKeyToVisit);\n      }, 800);\n      return currentModel;\n    });\n\n    _defineProperty(this, \"insert\", (currentModel, params) => {\n      const [parentKey, valueToInsert] = params;\n      const parentNode = currentModel.find(({\n        key\n      }) => key === parentKey);\n      if (parentNode == null) return currentModel;\n\n      const parentCoordinate = _pick(parentNode, ['x', 'y']);\n\n      const treeHeight = caculateTreeHeight(currentModel);\n      const childOrientation = //@ts-ignore\n      valueToInsert > parentNode.value ? 'right' : 'left';\n      const childCoordinate = caculateChildCoordinate(parentCoordinate, treeHeight, treeHeight, childOrientation); // If the new child coordinate collide with existing node in key\n      // we must recaculate all coordinate of the tree\n\n      if (isNodeCoordinateCollideWithOtherNode(childCoordinate, currentModel)) {\n        const allocatedBSTModel = this.reallocateAllTreeNode(currentModel);\n        return this.insert(allocatedBSTModel, params);\n      }\n\n      const newChildNode = this.constructNewChildNode(valueToInsert, this.getBiggestKey(currentModel) + 1, childCoordinate);\n      const modelAfterInsert = transformBSTModel(currentModel, 'insert', [parentKey, newChildNode]);\n      if (this.isTreeOutOfView(modelAfterInsert)) return this.shiftTreeToView(modelAfterInsert);\n      return modelAfterInsert;\n    });\n\n    _defineProperty(this, \"injectHTMLIntoCanvas\", () => {\n      const {\n        handleExecuteApi,\n        dropdownDisabled,\n        model\n      } = this.props;\n      setTimeout(() => {\n        BinarySearchTreeHTML.renderToView({\n          model,\n          wrapperElement: this.wrapperRef.current,\n          coordinate: _pick(this.props, ['x', 'y']),\n          apiHandler: handleExecuteApi,\n          disabled: dropdownDisabled\n        });\n      }, 0);\n    });\n\n    this.state = {\n      nodeAboutToVisit: new Set([])\n    };\n    this.wrapperRef = React.createRef(); // Register custom transformer\n\n    props.registerCustomTransformer({\n      visit: this.visit,\n      insert: this.insert\n    }); // Register HTML injector\n\n    props.registerHTMLInjector(this.injectHTMLIntoCanvas);\n  }\n\n  static initBSTModel(props) {\n    const {\n      controlled,\n      data,\n      initialData\n    } = props;\n    const dataToInitBST = controlled ? data : initialData;\n    const bstModelWithoutCoordinate = produceInitialBSTData(dataToInitBST);\n    const nodeCoordinateByKey = BinarySearchTreeDS.getCoordinationsOfTreeNodes(bstModelWithoutCoordinate, props);\n    return bstModelWithoutCoordinate.map(item => _objectSpread({}, item, {}, nodeCoordinateByKey[item.key], {\n      visible: true\n    }));\n  }\n\n  static getCoordinationsOfTreeNodes(bstModelWithoutCoordinate, props) {\n    // Level order traversal tree and caculate\n    const treeHeight = caculateTreeHeight(bstModelWithoutCoordinate);\n    let result = {};\n\n    let root = _objectSpread({}, bstModelWithoutCoordinate[0], {}, _pick(props, ['x', 'y']), {\n      x: 0,\n      y: 0,\n      level: 1\n    });\n\n    let queue = [root];\n\n    while (queue.length) {\n      const {\n        key,\n        x,\n        y,\n        left,\n        right,\n        level\n      } = queue.shift();\n      result[key] = {\n        x,\n        y\n      };\n\n      if (left !== null) {\n        const leftChild = BinarySearchTreeDS.findNodeInTreeByKey(bstModelWithoutCoordinate, left);\n        queue.push(_objectSpread({}, leftChild, {}, caculateChildCoordinate({\n          x,\n          y\n        }, level + 1, treeHeight, 'left'), {\n          level: level + 1\n        }));\n      }\n\n      if (right !== null) {\n        const rightChild = BinarySearchTreeDS.findNodeInTreeByKey(bstModelWithoutCoordinate, right);\n        queue.push(_objectSpread({}, rightChild, {}, caculateChildCoordinate({\n          x,\n          y\n        }, level + 1, treeHeight, 'right'), {\n          level: level + 1\n        }));\n      }\n    } // Some coordination will have negative x value\n    // we have to shift all coordination to right to make sure they start at 0\n\n\n    const allXValue = Object.values(result).map(({\n      x\n    }) => x);\n    let amountToShiftToRight = -Math.min(...allXValue, 0);\n    Object.values(result).forEach(coordinate => {\n      coordinate.x += amountToShiftToRight;\n    });\n    return result;\n  }\n\n  static findNodeInTreeByKey(currentModel, nodeKey) {\n    return currentModel.find(({\n      key\n    }) => key === nodeKey);\n  }\n\n  consumeMultipleActions(actionList, currentModel, onlyTranformData) {\n    // Treat each action as a transformation function which take a linkedListModel\n    // and return a new one. Consuming multiple actions is merely chaining those\n    // transformations together\n    // linkedListModel ---- action1 ----> linkedListModel1 ---- action2 ----> linkedListMode2 ---- action3 ----> linkedListModel3\n    return actionList.reduce((finalModel, action) => {\n      // the main function of a handler is doing side effect before transform model\n      // a handler must also return a new model\n      // if no handler is specify, just transform model right away\n      const {\n        name,\n        params\n      } = action; //@ts-ignore\n\n      const customHandler = this[name];\n\n      if (typeof customHandler === 'function') {\n        return customHandler(finalModel, params, onlyTranformData);\n      } else {\n        return transformBSTModel(finalModel, name, params);\n      }\n    }, currentModel);\n  }\n\n  addNodeToVisitingList(nodeKey) {\n    const {\n      nodeAboutToVisit\n    } = this.state;\n    let clonedState = new Set(nodeAboutToVisit);\n    clonedState.add(nodeKey);\n    this.setState({\n      nodeAboutToVisit: clonedState\n    });\n  }\n\n  handleAfterVisitAnimationFinish(currentModel, startNodeKey, nodeKeyToVisit) {\n    const {\n      nodeAboutToVisit\n    } = this.state;\n    const {\n      updateModel\n    } = this.props;\n    const clonedState = new Set(nodeAboutToVisit);\n    clonedState.delete(nodeKeyToVisit); // Mark the start node as visited and focus to the node which is just visited\n\n    const visitAction = {\n      name: 'visited',\n      params: [startNodeKey]\n    };\n    const focusAction = {\n      name: 'focus',\n      params: [nodeKeyToVisit]\n    };\n    const newModel = this.consumeMultipleActions([visitAction, focusAction], currentModel, true);\n    this.setState({\n      nodeAboutToVisit: clonedState\n    });\n    updateModel(newModel);\n  } // params: [parentKey, valueToInsert]\n\n\n  isTreeOutOfView(bstModel) {\n    return bstModel.some(({\n      x\n    }) => x < 0);\n  } // Sometimes node in bst will have negative x value\n  // so we have to shift the whole tree to right some amount to make\n  // the whole tree visible\n\n\n  shiftTreeToView(bstModel) {\n    let amountToShiftRight = Math.min(...bstModel.map(({\n      x\n    }) => x));\n    if (amountToShiftRight > 0) return bstModel;\n    return bstModel.map(item => _objectSpread({}, item, {\n      x: item.x - amountToShiftRight\n    }));\n  }\n\n  reallocateAllTreeNode(currentModel) {\n    const nodeCoordinateByKey = BinarySearchTreeDS.getCoordinationsOfTreeNodes(currentModel, this.props);\n    return currentModel.map(node => _objectSpread({}, node, {}, nodeCoordinateByKey[node.key]));\n  }\n\n  getBiggestKey(currentModel) {\n    return Math.max(...currentModel.map(({\n      key\n    }) => key));\n  }\n\n  constructNewChildNode(value, key, coordinate) {\n    return _objectSpread({\n      value,\n      left: null,\n      right: null,\n      key,\n      visible: true,\n      isNew: true\n    }, coordinate);\n  } // handleFastForward() {\n  //   const { bstModel } = this.state;\n  //   const { instructions, saveStepSnapshots } = this.props;\n  //   if (!instructions) return;\n  //   let allActions: ActionWithStep<BST.Method>[] = [];\n  //   for (let i = 0; i < instructions.length; i++) {\n  //     // Replace visit action with vist + focus\n  //     // also add step attribute to each action\n  //     const replacedActions: ActionWithStep<BST.Method>[] = flatMap(\n  //       instructions[i],\n  //       action => {\n  //         const { name, params } = action;\n  //         return name === 'visit'\n  //           ? [\n  //               { name: 'visited', params: params.slice(0, 1), step: i },\n  //               { name: 'focus', params: params.slice(1), step: i },\n  //             ]\n  //           : { ...action, step: i };\n  //       },\n  //     );\n  //     allActions.push(...replacedActions);\n  //   }\n  //   const actionsGroupedByStep = groupBy(allActions, item => item.step);\n  //   // Loop through all the action one by one and keep updating the final model\n  //   let finalLinkedListModel = Object.entries(actionsGroupedByStep).reduce<\n  //     BST.Model\n  //   >((currentModel, [step, actionsToMakeAtThisStep]) => {\n  //     saveStepSnapshots(currentModel, +step);\n  //     return this.consumeMultipleActions(\n  //       actionsToMakeAtThisStep,\n  //       currentModel,\n  //       true,\n  //     );\n  //   }, bstModel);\n  //   this.updateWithoutAnimation(finalLinkedListModel);\n  // }\n\n\n  renderNodes() {\n    const {\n      model\n    } = this.props;\n    return model.map(node => __jsx(GraphMemoryBlock, node));\n  }\n\n  renderPointerLinks() {\n    const {\n      model\n    } = this.props;\n    const {\n      nodeAboutToVisit\n    } = this.state;\n    return _flatMap(model, node => {\n      const {\n        left,\n        right,\n        key,\n        visited\n      } = node;\n      const fromNode = this.findNodeCoordinateByKey(model, key);\n      return [left, right].map(child => {\n        if (!child) return null;\n        const {\n          visited: childVisited\n        } = BinarySearchTreeDS.findNodeInTreeByKey(model, child);\n        const toNode = this.findNodeCoordinateByKey(model, child);\n        return __jsx(GraphLikeEdges // {...pathAndRotation}\n        , {\n          from: _pick(fromNode, ['x', 'y']),\n          to: _pick(toNode, ['x', 'y']),\n          key: child,\n          visible: !!this.isNodeVisible(model, child),\n          visited: visited && childVisited,\n          following: nodeAboutToVisit.has(child),\n          arrowDirection: \"right\"\n        });\n      });\n    });\n  }\n\n  findNodeCoordinateByKey(currentModel, nodeKey) {\n    const treeNode = currentModel.find(({\n      key\n    }) => key === nodeKey);\n    return {\n      x: treeNode.x,\n      y: treeNode.y\n    };\n  }\n\n  isNodeVisible(currentModel, nodeKey) {\n    var _currentModel$find;\n\n    return !!((_currentModel$find = currentModel.find(({\n      key\n    }) => key === nodeKey)) === null || _currentModel$find === void 0 ? void 0 : _currentModel$find.visible);\n  }\n\n  render() {\n    return __jsx(React.Fragment, null, __jsx(\"use\", _extends({\n      href: \"#binary-search-tree\"\n    }, _pick(this.props, ['x', 'y']), {\n      ref: this.wrapperRef\n    })), __jsx(\"defs\", null, __jsx(\"g\", {\n      id: \"binary-search-tree\",\n      x: \"0\",\n      y: \"0\"\n    }, this.renderPointerLinks(), this.renderNodes())));\n  }\n\n}\nexport default withDSCore({\n  initModel: BinarySearchTreeDS.initBSTModel,\n  dataTransformer: transformBSTModel //@ts-ignore\n\n})(BinarySearchTreeDS);","map":null,"metadata":{},"sourceType":"module"}