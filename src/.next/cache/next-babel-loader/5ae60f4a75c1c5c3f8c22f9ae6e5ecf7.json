{"ast":null,"code":"import { initBinaryTree, BinaryTreeNode } from \"./helper\";\nimport { Instructions } from 'instructions';\nexport const bstInstruction = (data, operation, parameters) => {\n  switch (operation) {\n    case 'search':\n      return searchInstruction(data, parameters);\n\n    case 'insert':\n      return insertInstruction(data, parameters);\n\n    case 'delete':\n      return deleteInstruction(data, parameters);\n\n    case 'preorder':\n      return preorderTraversalInstruction(data);\n\n    case 'inorder':\n      return inorderTraversalInstruction(data);\n\n    case 'postorder':\n      return postorderTraversalInstruction(data);\n\n    default:\n      return [];\n  }\n};\n\nconst searchInstruction = (data, {\n  value\n}) => {\n  var _current;\n\n  const bst = initBinaryTree(data);\n  let instructions = new Instructions();\n  const codeLines = getCodeLine('search');\n  let current = bst;\n  let found = false;\n  instructions.setCodeLine(codeLines.init);\n  instructions.pushActionsAndEndStep('bst', [{\n    name: 'focus',\n    params: [(_current = current) === null || _current === void 0 ? void 0 : _current.key]\n  }]);\n\n  while (current !== null && !found) {\n    instructions.setCodeLine(codeLines.compare);\n    instructions.pushActionsAndEndStep('bst', []);\n\n    if (current.val === value) {\n      // Found the element!\n      instructions.setCodeLine(codeLines.compareEqual);\n      instructions.pushActionsAndEndStep('bst', [{\n        name: 'visited',\n        params: [current.key]\n      }]);\n      found = true;\n    } else if (value < current.val) {\n      // Go Left as data is smaller than parent\n      instructions.setCodeLine(codeLines.compareSmaller);\n      instructions.pushActionsAndEndStep('bst', [{\n        name: 'resetFocus',\n        params: []\n      }, {\n        name: 'visit',\n        params: [current.key, current.left && current.left.key]\n      }]);\n      current = current.left;\n    } else {\n      // Go right as data is greater than parent\n      instructions.setCodeLine(codeLines.compareGreater);\n      instructions.pushActionsAndEndStep('bst', [{\n        name: 'resetFocus',\n        params: []\n      }, {\n        name: 'visit',\n        params: [current.key, current.right && current.right.key]\n      }]);\n      current = current.right;\n    }\n  } // Not found the element\n\n\n  if (!found) {\n    instructions.setCodeLine(codeLines.notFound);\n  }\n\n  instructions.pushActionsAndEndStep('bst', [{\n    name: 'resetAll',\n    params: []\n  }]);\n  return instructions.get();\n};\n\nconst insertInstruction = (data, {\n  value\n}) => {\n  const bst = initBinaryTree(data);\n  let instructions = new Instructions();\n  const codeLines = getCodeLine('insert');\n  let newNode = new BinaryTreeNode(value, data.length);\n  instructions.setCodeLine(codeLines.init);\n  instructions.pushActionsAndEndStep('bst', []);\n\n  if (bst === null) {\n    instructions.setCodeLine(codeLines.rootNotFound);\n    instructions.pushActionsAndEndStep('bst', []);\n  } else {\n    instructions.setCodeLine(codeLines.startRecursion);\n    instructions.pushActionsAndEndStep('bst', [{\n      name: 'focus',\n      params: [bst.key]\n    }]);\n    insertHelper(bst, newNode);\n  }\n\n  function insertHelper(currentNode, newNode) {\n    if (newNode.val < currentNode.val) {\n      if (currentNode.left === null) {\n        instructions.setCodeLine(codeLines.recursionLeft);\n        instructions.pushActionsAndEndStep('bst', [{\n          name: 'insert',\n          params: [currentNode.key, newNode.val]\n        }]);\n        currentNode.left = newNode;\n      } else {\n        instructions.setCodeLine(codeLines.recursionLeft);\n        instructions.pushActionsAndEndStep('bst', [{\n          name: 'visit',\n          params: [currentNode.key, currentNode.left.key]\n        }]);\n        insertHelper(currentNode.left, newNode);\n      }\n    } else {\n      if (currentNode.right === null) {\n        instructions.setCodeLine(codeLines.recursionRight);\n        instructions.pushActionsAndEndStep('bst', [{\n          name: 'insert',\n          params: [currentNode.key, newNode.val]\n        }]);\n        currentNode.right = newNode;\n      } else {\n        instructions.setCodeLine(codeLines.recursionRight);\n        instructions.pushActionsAndEndStep('bst', [{\n          name: 'visit',\n          params: [currentNode.key, currentNode.right.key]\n        }]);\n        insertHelper(currentNode.right, newNode);\n      }\n    }\n  }\n\n  instructions.pushActionsAndEndStep('bst', [{\n    name: 'resetAll',\n    params: []\n  }]);\n  return instructions.get();\n};\n\nconst deleteInstruction = (data, {\n  value\n}) => {\n  var _current2;\n\n  const bst = initBinaryTree(data);\n  let instructions = new Instructions();\n  const codeLines = getCodeLine('delete');\n  console.log('bst', bst);\n  let current = bst;\n  let found = false;\n  instructions.setCodeLine(codeLines.find);\n  instructions.pushActionsAndEndStep('bst', [{\n    name: 'focus',\n    params: [(_current2 = current) === null || _current2 === void 0 ? void 0 : _current2.key]\n  }]);\n\n  while (current !== null && !found) {\n    if (current.val === value) {\n      // Found the element!\n      instructions.setCodeLine(codeLines.find);\n      instructions.pushActionsAndEndStep('bst', [{\n        name: 'label',\n        params: ['Node to delete', current ? current.key : null]\n      }]);\n      found = true;\n    } else if (value < current.val) {\n      // Go Left as data is smaller than parent\n      instructions.setCodeLine(codeLines.find);\n      instructions.pushActionsAndEndStep('bst', [{\n        name: 'resetFocus',\n        params: []\n      }, {\n        name: 'visit',\n        params: [current.key, current.left && current.left.key]\n      }]);\n      current = current.left;\n    } else {\n      // Go right as data is greater than parent\n      instructions.setCodeLine(codeLines.find);\n      instructions.pushActionsAndEndStep('bst', [{\n        name: 'resetFocus',\n        params: []\n      }, {\n        name: 'visit',\n        params: [current.key, current.right && current.right.key]\n      }]);\n      current = current.right;\n    }\n  }\n\n  if (found && current) {\n    if (current.left === null && current.right === null) {\n      // No child situation\n      // Delete the node just found\n      instructions.setCodeLine(codeLines.noChild);\n      instructions.pushActionsAndEndStep('bst', [{\n        name: 'delete',\n        params: [current ? current.key : null]\n      }]);\n    } else if (current.left !== null && current.right !== null) {\n      // Two child situation\n      // Find the biggest node in the left sub-tree\n      let predecessor = current.left;\n      instructions.setCodeLine(codeLines.bothChild);\n      instructions.pushActionsAndEndStep('bst', [{\n        name: 'focus',\n        params: [predecessor.key]\n      }]);\n\n      while (predecessor.right) {\n        instructions.setCodeLine(codeLines.bothChild);\n        instructions.pushActionsAndEndStep('bst', [{\n          name: 'resetFocus',\n          params: []\n        }, {\n          name: 'focus',\n          params: [current.key]\n        }, {\n          name: 'visit',\n          params: [predecessor.key, predecessor.right.key]\n        }]);\n        predecessor = predecessor.right;\n      }\n\n      const {\n        key,\n        val\n      } = predecessor;\n      instructions.setCodeLine(codeLines.bothChild);\n      instructions.pushActionsAndEndStep('bst', [{\n        name: 'setValue',\n        params: [val, current.key]\n      }]);\n      instructions.setCodeLine(codeLines.bothChild);\n      instructions.pushActionsAndEndStep('bst', [{\n        name: 'delete',\n        params: [key]\n      }]);\n    } else {\n      console.log('1111', current); // One child situation\n      // Copy value and delete child\n\n      const onlyChildNode = current.left || current.right;\n      const {\n        key,\n        val\n      } = onlyChildNode;\n      instructions.setCodeLine(codeLines.onlyChild);\n      instructions.pushActionsAndEndStep('bst', [{\n        name: 'setValue',\n        params: [val, current.key]\n      }]);\n      instructions.setCodeLine(codeLines.onlyChild);\n      instructions.pushActionsAndEndStep('bst', [{\n        name: 'delete',\n        params: [key]\n      }]);\n    }\n\n    instructions.pushActionsAndEndStep('bst', [{\n      name: 'resetAll',\n      params: []\n    }]);\n    return instructions.get();\n  } else {\n    // Can not find the node to delete\n    instructions.setCodeLine(codeLines.notFound);\n    instructions.pushActionsAndEndStep('bst', [{\n      name: 'resetAll',\n      params: []\n    }]);\n    return instructions.get();\n  }\n};\n\nconst preorderTraversalInstruction = data => {\n  const bst = initBinaryTree(data);\n  let instructions = new Instructions();\n  let currentFocusKey = null;\n\n  function preorderHelper(tree) {\n    const {\n      key,\n      left,\n      right,\n      val\n    } = tree;\n    instructions.pushActions('array', [{\n      name: 'push',\n      params: [val]\n    }]);\n    instructions.pushActions('bst', [{\n      name: 'resetFocus',\n      params: []\n    }, {\n      name: 'focus',\n      params: [key]\n    }, {\n      name: 'visited',\n      params: [currentFocusKey]\n    }]);\n    instructions.endStep();\n    currentFocusKey = key;\n    if (left) preorderHelper(left);\n    if (right) preorderHelper(right);\n  }\n\n  preorderHelper(bst);\n  instructions.pushActionsAndEndStep('bst', [{\n    name: 'resetFocus',\n    params: []\n  }, {\n    name: 'visited',\n    params: [currentFocusKey]\n  }]);\n  instructions.pushActionsAndEndStep('bst', [{\n    name: 'resetAll',\n    params: []\n  }]);\n  return instructions.get();\n};\n\nconst inorderTraversalInstruction = data => {\n  const bst = initBinaryTree(data);\n  let instructions = new Instructions();\n  let currentFocusKey = null;\n\n  function inorderHelper(tree) {\n    const {\n      key,\n      left,\n      right,\n      val\n    } = tree;\n    if (left) inorderHelper(left);\n    instructions.pushActions('array', [{\n      name: 'push',\n      params: [val]\n    }]);\n    instructions.pushActionsAndEndStep('bst', [{\n      name: 'resetFocus',\n      params: []\n    }, {\n      name: 'focus',\n      params: [key]\n    }, {\n      name: 'visited',\n      params: [currentFocusKey]\n    }]);\n    currentFocusKey = key;\n    if (right) inorderHelper(right);\n  }\n\n  inorderHelper(bst);\n  instructions.pushActionsAndEndStep('bst', [{\n    name: 'resetFocus',\n    params: []\n  }, {\n    name: 'visited',\n    params: [currentFocusKey]\n  }]);\n  instructions.pushActionsAndEndStep('bst', [{\n    name: 'resetAll',\n    params: []\n  }]);\n  return instructions.get();\n};\n\nconst postorderTraversalInstruction = data => {\n  const bst = initBinaryTree(data);\n  let instructions = new Instructions();\n  let currentFocusKey = null;\n\n  function postorderHelper(tree) {\n    const {\n      key,\n      left,\n      right,\n      val\n    } = tree;\n    if (left) postorderHelper(left);\n    if (right) postorderHelper(right);\n    instructions.pushActions('array', [{\n      name: 'push',\n      params: [val]\n    }]);\n    instructions.pushActionsAndEndStep('bst', [{\n      name: 'resetFocus',\n      params: []\n    }, {\n      name: 'focus',\n      params: [key]\n    }, {\n      name: 'visited',\n      params: [currentFocusKey]\n    }]);\n    currentFocusKey = key;\n  }\n\n  postorderHelper(bst);\n  instructions.pushActionsAndEndStep('bst', [{\n    name: 'resetFocus',\n    params: []\n  }, {\n    name: 'visited',\n    params: [currentFocusKey]\n  }]);\n  instructions.pushActionsAndEndStep('bst', [{\n    name: 'resetAll',\n    params: []\n  }]);\n  return instructions.get();\n};\n\nconst getCodeLine = operation => {\n  switch (operation) {\n    case 'search':\n      return {\n        init: '2',\n        compare: '3',\n        compareEqual: '4-6',\n        compareSmaller: '7-9',\n        compareGreater: '11-12',\n        notFound: '16-17'\n      };\n\n    case 'insert':\n      return {\n        init: '2',\n        rootNotExist: '3-4',\n        startRecursion: '6',\n        recursionLeft: '12-16',\n        recursionRight: '18-23'\n      };\n\n    case 'delete':\n      return {\n        find: '2-3',\n        noChild: '8-9',\n        onlyChild: '11-15',\n        bothChild: '17-21',\n        notFound: '5-6'\n      };\n\n    default:\n      return {};\n  }\n};","map":null,"metadata":{},"sourceType":"module"}