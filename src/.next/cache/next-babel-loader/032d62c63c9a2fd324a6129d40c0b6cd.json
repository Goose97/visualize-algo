{"ast":null,"code":"import _Reflect$construct from \"@babel/runtime-corejs2/core-js/reflect/construct\";\nimport _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime-corejs2/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime-corejs2/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport _pick from \"lodash/pick\";\nvar __jsx = React.createElement;\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(_Reflect$construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from 'react';\nimport QueueItem from \"./QueueItem\";\nimport { QUEUE_BLOCK_WIDTH, QUEUE_BLOCK_HEIGHT, QUEUE_BLOCK_GAP } from \"../../constants\";\nimport withReverseStep from 'hocs/withReverseStep';\nimport transformQueueModel from 'transformers/Queue';\nimport { getProgressDirection } from 'utils';\nexport var QueueDS = /*#__PURE__*/function (_Component) {\n  _inherits(QueueDS, _Component);\n\n  var _super = _createSuper(QueueDS);\n\n  function QueueDS(props) {\n    var _this;\n\n    _classCallCheck(this, QueueDS);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"handleReverse\", function (stateOfPreviousStep) {\n      _this.setState({\n        queueModel: stateOfPreviousStep\n      });\n    });\n\n    _this.state = {\n      queueModel: _this.initQueueModel()\n    };\n    return _this;\n  }\n\n  _createClass(QueueDS, [{\n    key: \"initQueueModel\",\n    value: function initQueueModel() {\n      var initialData = this.props.initialData;\n      return initialData.map(function (value, index) {\n        return {\n          value: value,\n          visible: true,\n          key: initialData.length - 1 - index,\n          offsetFromFront: initialData.length - 1 - index\n        };\n      });\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var _this$props = this.props,\n          currentStep = _this$props.currentStep,\n          reverseToStep = _this$props.reverseToStep,\n          totalStep = _this$props.totalStep;\n      if (!currentStep || !prevProps.currentStep || !totalStep) return;\n\n      switch (getProgressDirection(currentStep, prevProps.currentStep, totalStep)) {\n        case 'forward':\n          this.saveModelSnapshotAtCurrentStep();\n          this.handleForward();\n          break;\n\n        case 'backward':\n          reverseToStep(currentStep);\n          break;\n        // case 'fastForward':\n        //   console.log('fastForward');\n        //   this.handleFastForward();\n        //   break;\n        // case 'fastBackward':\n        //   console.log('fastBackward');\n        //   this.handleFastBackward();\n        //   break;\n      }\n    }\n  }, {\n    key: \"saveModelSnapshotAtCurrentStep\",\n    value: function saveModelSnapshotAtCurrentStep() {\n      var _this$props2 = this.props,\n          currentStep = _this$props2.currentStep,\n          saveStepSnapshots = _this$props2.saveStepSnapshots;\n      var queueModel = this.state.queueModel;\n      if (typeof currentStep === 'number') saveStepSnapshots(queueModel, currentStep);\n    }\n  }, {\n    key: \"handleForward\",\n    value: function handleForward() {\n      // Treat each action as a transformation function which take a linkedListModel\n      // and return a new one. Consuming multiple actions is merely chaining those\n      // transformations together\n      // linkedListModel ---- action1 ----> linkedListModel1 ---- action2 ----> linkedListMode2 ---- action3 ----> linkedListModel3\n      var queueModel = this.state.queueModel;\n      var _this$props3 = this.props,\n          currentStep = _this$props3.currentStep,\n          instructions = _this$props3.instructions;\n      var actionsToMakeAtThisStep = instructions[currentStep];\n      if (!actionsToMakeAtThisStep || !actionsToMakeAtThisStep.length) return; // This consume pipeline have many side effect in each step. Each\n      // method handle each action has their own side effect\n\n      var newQueueModel = this.consumeMultipleActions(actionsToMakeAtThisStep, queueModel);\n      this.setState({\n        queueModel: newQueueModel\n      });\n    }\n  }, {\n    key: \"consumeMultipleActions\",\n    value: function consumeMultipleActions(actionList, currentModel, onlyTranformData) {\n      var _this2 = this;\n\n      // Treat each action as a transformation function which take a linkedListModel\n      // and return a new one. Consuming multiple actions is merely chaining those\n      // transformations together\n      // linkedListModel ---- action1 ----> linkedListModel1 ---- action2 ----> linkedListMode2 ---- action3 ----> linkedListModel3\n      return actionList.reduce(function (finalModel, action) {\n        // the main function of a handler is doing side effect before transform model\n        // a handler must also return a new model\n        // if no handler is specify, just transform model right away\n        var name = action.name,\n            params = action.params; //@ts-ignore\n\n        var customHandler = _this2[name];\n\n        if (typeof customHandler === 'function') {\n          return customHandler(finalModel, params, onlyTranformData);\n        } else {\n          return transformQueueModel(finalModel, name, params);\n        }\n      }, currentModel);\n    }\n  }, {\n    key: \"enqueue\",\n    value: function enqueue(currentModel, params) {\n      var firstItem = currentModel[0];\n      var firstVisibleItem = currentModel.filter(function (_ref) {\n        var visible = _ref.visible;\n        return !!visible;\n      })[0];\n      var queueItemToEnqueue = {\n        value: params[0],\n        visible: true,\n        offsetFromFront: firstVisibleItem ? firstVisibleItem.offsetFromFront + 1 : 0,\n        key: firstItem ? firstItem.key + 1 : 0,\n        isNew: true\n      };\n      var newModel = transformQueueModel(currentModel, 'enqueue', [queueItemToEnqueue]);\n      return newModel;\n    }\n  }, {\n    key: \"renderQueueBoundary\",\n    value: function renderQueueBoundary() {\n      var queueWidth = this.caculateWidthOfQueue();\n\n      var upperBound = __jsx(\"path\", {\n        className: \"default-stroke has-transition\",\n        d: \"M \".concat(QUEUE_BLOCK_WIDTH, \" \").concat(-20, \" l -2 2 l 8 -2 l -8 -2 l 2 2 h \").concat(-queueWidth)\n      });\n\n      var lowerBound = __jsx(\"path\", {\n        className: \"default-stroke has-transition\",\n        d: \"M \".concat(QUEUE_BLOCK_WIDTH, \" \").concat(QUEUE_BLOCK_HEIGHT + 20, \" l -2 2 l 8 -2 l -8 -2 l 2 2 h \").concat(-queueWidth)\n      });\n\n      return __jsx(React.Fragment, null, upperBound, lowerBound);\n    }\n  }, {\n    key: \"caculateWidthOfQueue\",\n    value: function caculateWidthOfQueue() {\n      var queueModel = this.state.queueModel;\n      var numberOfQueueItem = queueModel.filter(function (_ref2) {\n        var visible = _ref2.visible;\n        return !!visible;\n      }).length;\n      return numberOfQueueItem * (QUEUE_BLOCK_WIDTH + QUEUE_BLOCK_GAP) - QUEUE_BLOCK_GAP;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var queueModel = this.state.queueModel;\n      var listQueueItem = queueModel.map(function (item) {\n        return __jsx(QueueItem, item);\n      });\n      return __jsx(React.Fragment, null, __jsx(\"use\", _extends({\n        href: \"#queue\"\n      }, _pick(this.props, ['x', 'y']))), __jsx(\"defs\", null, __jsx(\"g\", {\n        id: \"queue\",\n        className: \"queue__wrapper\"\n      }, listQueueItem, this.renderQueueBoundary())));\n    }\n  }]);\n\n  return QueueDS;\n}(Component);\nexport default withReverseStep(QueueDS);","map":null,"metadata":{},"sourceType":"module"}