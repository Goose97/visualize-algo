{"ast":null,"code":"import _pick from \"lodash/pick\";\nimport { TREE_LIKE_LEVEL_GAP, BST_CHILD_DISTANCE_FROM_PARENT, GRAPH_NODE_RADIUS } from \"../../constants\";\nimport { BinaryTreeNode } from 'instructions/BST/helper';\n// Also included null node\nexport var caculateTreeHeight = function caculateTreeHeight(bstModel) {\n  if (!bstModel.length) return 0;\n  var biggestLevel = 0;\n\n  var findNodeByKey = function findNodeByKey(nodeKey) {\n    return bstModel.find(function (_ref) {\n      var key = _ref.key;\n      return key === nodeKey;\n    });\n  };\n\n  var stack = [{\n    node: bstModel[0],\n    level: 1\n  }]; // Do DFS to find tree height\n\n  while (stack.length) {\n    var _stack$pop = stack.pop(),\n        _stack$pop$node = _stack$pop.node,\n        left = _stack$pop$node.left,\n        right = _stack$pop$node.right,\n        level = _stack$pop.level;\n\n    biggestLevel = Math.max(biggestLevel, level);\n    var leftChild = findNodeByKey(left);\n    var rightChild = findNodeByKey(right);\n    if (leftChild) stack.push({\n      node: leftChild,\n      level: level + 1\n    });\n    if (rightChild) stack.push({\n      node: rightChild,\n      level: level + 1\n    });\n  }\n\n  return biggestLevel;\n};\nexport var isNodeCoordinateCollideWithOtherNode = function isNodeCoordinateCollideWithOtherNode(nodeCoordinate, currentModel) {\n  var isIntersect = function isIntersect(nodeCoordinateA, nodeCoordinateB) {\n    // If distance from A to B smaller than 2 * node radius then they are intersect\n    var distance = Math.sqrt(Math.pow(nodeCoordinateA.x - nodeCoordinateB.x, 2) + Math.pow(nodeCoordinateA.y - nodeCoordinateB.y, 2));\n    return distance < 2 * GRAPH_NODE_RADIUS;\n  };\n\n  return currentModel.some(function (node) {\n    return isIntersect(nodeCoordinate, _pick(node, ['x', 'y']));\n  });\n};\n\nvar caculateTreeWidthBasedOnHeight = function caculateTreeWidthBasedOnHeight(treeHeight) {\n  if (treeHeight === 2) return BST_CHILD_DISTANCE_FROM_PARENT * 2;\n  return caculateTreeWidthBasedOnHeight(treeHeight - 1) * 2 + 100;\n};\n\nvar caculateChildDistanceFromParentBasedOnLevel = function caculateChildDistanceFromParentBasedOnLevel(level, treeHeight) {\n  if (level === treeHeight) {\n    var subTreeWidth = caculateTreeWidthBasedOnHeight(2);\n    return subTreeWidth / 2;\n  } else {\n    var _subTreeWidth = caculateTreeWidthBasedOnHeight(treeHeight - level + 1);\n\n    return _subTreeWidth / 2 + 40;\n  }\n};\n\nexport var caculateChildCoordinate = function caculateChildCoordinate(parentCoordinate, level, treeHeight, leftOrRight) {\n  var x = parentCoordinate.x,\n      y = parentCoordinate.y;\n  var distanceFromParentBasedOnLevel = caculateChildDistanceFromParentBasedOnLevel(level, treeHeight);\n  return {\n    x: x + (leftOrRight === 'left' ? -1 : 1) * distanceFromParentBasedOnLevel,\n    y: y + TREE_LIKE_LEVEL_GAP\n  };\n};\nexport var produceInitialBSTData = function produceInitialBSTData(array) {\n  if (!array.length) return [];\n  var queue = [];\n  var result = [];\n  var counter = 0;\n  var key = 0;\n\n  for (var i = 0; i < array.length; i++) {\n    var val = array[i];\n    var parentNode = queue[0];\n    var newNode = val !== null ? new BinaryTreeNode(val, key++) : null;\n\n    if (newNode) {\n      queue.push({\n        key: newNode.key,\n        value: newNode.val,\n        left: null,\n        right: null\n      });\n    } else {\n      queue.push(null);\n    }\n\n    if (parentNode === undefined) continue;\n\n    if (counter === 0) {\n      // this node is left of parent node\n      if (parentNode) parentNode.left = newNode ? newNode.key : null;\n      counter++;\n    } else {\n      // this node is right of parent node\n      if (parentNode) parentNode.right = newNode ? newNode.key : null;\n      counter = 0;\n      result.push(queue.shift());\n    }\n  } //@ts-ignore\n\n\n  result.push.apply(result, queue);\n  return result.filter(function (item) {\n    return !!item;\n  });\n};","map":null,"metadata":{},"sourceType":"module"}