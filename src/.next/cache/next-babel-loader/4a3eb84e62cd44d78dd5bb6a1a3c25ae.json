{"ast":null,"code":"import { Instructions } from 'instructions';\nimport { initLinkedList } from \"./helper\";\nimport { LinkedListNode } from \"./helper\";\nexport const linkedListInstruction = (data, operation, parameters) => {\n  switch (operation) {\n    case 'search':\n      return searchInstruction(data, parameters);\n\n    case 'insert':\n      return insertInstruction(data, parameters);\n\n    case 'delete':\n      return deleteInstruction(data, parameters);\n\n    case 'reverse':\n      return reverseInstruction(data);\n\n    case 'detectCycle':\n      return detectCycleInstruction(data);\n\n    default:\n      return [];\n  }\n};\n\nconst searchInstruction = (data, {\n  value\n}) => {\n  const linkedList = initLinkedList(data);\n  let instructions = new Instructions();\n  const codeLines = getCodeLine('search'); // Start make instruction\n\n  let current = linkedList;\n  let found = false;\n  instructions.setCodeLine(codeLines.init);\n  instructions.pushActionsAndEndStep('linkedList', [{\n    name: 'focus',\n    params: [0]\n  }]);\n\n  do {\n    instructions.setCodeLine(codeLines.compare);\n    instructions.endStep();\n\n    if (current.val === value) {\n      found = true;\n      instructions.setCodeLine(codeLines.compareSuccess);\n    } else {\n      let previousKey = current.key;\n      current = current.next;\n\n      if (current) {\n        instructions.setCodeLine(codeLines.moveNext);\n        instructions.pushActionsAndEndStep('linkedList', [{\n          name: 'visit',\n          params: [previousKey, current.key]\n        }, {\n          name: 'label',\n          params: ['current', current.key, true]\n        }]);\n        instructions.setCodeLine(codeLines.repeat);\n        instructions.endStep();\n      }\n    }\n  } while (current && !found);\n\n  if (!found) {\n    instructions.setCodeLine(codeLines.outOfLoop);\n    instructions.endStep();\n  }\n\n  instructions.pushActionsAndEndStep('linkedList', [{\n    name: 'resetAll',\n    params: []\n  }]);\n  return instructions.get();\n};\n\nconst insertInstruction = (data, {\n  value,\n  index\n}) => {\n  const linkedList = initLinkedList(data);\n  let instructions = new Instructions();\n  const codeLines = getCodeLine('insert'); // Start make instruction\n\n  let previousNode;\n  let currentNode = linkedList;\n  let currentIndex = 0;\n  instructions.setCodeLine(codeLines.init);\n  instructions.pushActionsAndEndStep('linkedList', [{\n    name: 'focus',\n    params: [0]\n  }, {\n    name: 'label',\n    params: ['current', currentNode.key, true]\n  }]);\n\n  while (currentIndex !== index && currentNode !== null) {\n    previousNode = currentNode;\n    currentNode = currentNode.next;\n    currentIndex++;\n\n    if (currentNode) {\n      instructions.setCodeLine(codeLines.findPosition);\n      instructions.pushActionsAndEndStep('linkedList', [{\n        name: 'visit',\n        params: [previousNode.key, currentNode.key, true]\n      }, {\n        name: 'label',\n        params: ['previous', previousNode.key, true]\n      }, {\n        name: 'label',\n        params: ['current', currentNode.key, true]\n      }]);\n    }\n  }\n\n  if (index === currentIndex) {\n    var _currentNode;\n\n    let newNode = new LinkedListNode(value, data.length);\n    previousNode.next = newNode;\n    newNode.next = currentNode;\n    instructions.setCodeLine(codeLines.insert);\n    instructions.pushActionsAndEndStep('linkedList', [{\n      name: 'insert',\n      params: [value, previousNode.key, newNode.key]\n    }, {\n      name: 'changePointer',\n      params: [previousNode.key, newNode.key]\n    }, {\n      name: 'changePointer',\n      params: [newNode.key, (_currentNode = currentNode) === null || _currentNode === void 0 ? void 0 : _currentNode.key]\n    }]);\n  }\n\n  instructions.setCodeLine(codeLines.complete);\n  instructions.pushActionsAndEndStep('linkedList', [{\n    name: 'resetAll',\n    params: []\n  }]);\n  return instructions.get();\n};\n\nconst deleteInstruction = (data, {\n  index\n}) => {\n  const linkedList = initLinkedList(data);\n  let instructions = new Instructions();\n  const codeLines = getCodeLine('insert'); // Start make instruction\n\n  let previousNode = null;\n  let currentNode = linkedList;\n  instructions.setCodeLine(codeLines.init);\n  instructions.pushActionsAndEndStep('linkedList', [{\n    name: 'focus',\n    params: [0]\n  }]);\n\n  for (let i = 0; i < index; i++) {\n    var _previousNode, _currentNode2;\n\n    previousNode = currentNode;\n    currentNode = currentNode.next;\n    instructions.setCodeLine(codeLines.findPosition);\n    instructions.pushActionsAndEndStep('linkedList', [{\n      name: 'visit',\n      params: [(_previousNode = previousNode) === null || _previousNode === void 0 ? void 0 : _previousNode.key, (_currentNode2 = currentNode) === null || _currentNode2 === void 0 ? void 0 : _currentNode2.key]\n    }]);\n  }\n\n  previousNode.next = currentNode.next;\n  instructions.setCodeLine(codeLines.delete);\n  instructions.pushActionsAndEndStep('linkedList', [{\n    name: 'remove',\n    params: [currentNode.key]\n  }, {\n    name: 'changePointer',\n    params: [previousNode.key, currentNode.next && currentNode.next.key]\n  }]);\n  instructions.setCodeLine(codeLines.complete);\n  instructions.pushActionsAndEndStep('linkedList', [{\n    name: 'resetAll',\n    params: []\n  }]);\n  return instructions.get();\n};\n\nconst reverseInstruction = data => {\n  const linkedList = initLinkedList(data);\n  let instructions = new Instructions();\n  const codeLines = getCodeLine('reverse'); // Start make instruction\n\n  let previousNode = null;\n  let currentNode = linkedList;\n  let tmp;\n  instructions.setCodeLine(codeLines.init);\n  instructions.pushActionsAndEndStep('linkedList', [{\n    name: 'focus',\n    params: [0]\n  }, {\n    name: 'label',\n    params: ['current', 0, true]\n  }]);\n\n  while (currentNode) {\n    tmp = currentNode.next;\n    instructions.setCodeLine(codeLines.reversePointer);\n    instructions.pushActionsAndEndStep('linkedList', [{\n      name: 'label',\n      params: ['temp', tmp && tmp.key, true]\n    }, {\n      name: 'changePointer',\n      params: [currentNode.key, previousNode && previousNode.key]\n    }]);\n    currentNode.next;\n    previousNode = currentNode;\n    currentNode = tmp;\n    const currentNodeKey = currentNode && currentNode.key;\n    instructions.setCodeLine(codeLines.moveNext);\n    instructions.pushActionsAndEndStep('linkedList', [{\n      name: 'focus',\n      params: [currentNodeKey]\n    }, {\n      name: 'label',\n      params: ['current', currentNodeKey, true]\n    }, {\n      name: 'label',\n      params: ['previous', previousNode.key, true]\n    }]);\n  }\n\n  instructions.setCodeLine(codeLines.complete);\n  instructions.endStep();\n  instructions.pushActionsAndEndStep('linkedList', [{\n    name: 'resetAll',\n    params: []\n  }]);\n  return instructions.get();\n};\n\nconst detectCycleInstruction = data => {\n  var _fast, _fast2;\n\n  const linkedList = initLinkedList(data);\n  let instructions = new Instructions();\n  const codeLines = getCodeLine('detectCycle'); // Start make instruction\n\n  let slow = linkedList;\n  let fast = linkedList.next;\n  let isLoop = false;\n  instructions.setCodeLine(codeLines.init);\n  instructions.pushActionsAndEndStep('linkedList', [{\n    name: 'focus',\n    params: [slow.key]\n  }, {\n    name: 'focus',\n    params: [(_fast = fast) === null || _fast === void 0 ? void 0 : _fast.key, true]\n  }, {\n    name: 'label',\n    params: ['slow', slow.key, true]\n  }, {\n    name: 'label',\n    params: ['fast', (_fast2 = fast) === null || _fast2 === void 0 ? void 0 : _fast2.key, true]\n  }]);\n\n  while (slow !== null && fast !== null) {\n    var _slow, _slow$next, _fast3, _fast3$next, _slow2, _slow2$next, _fast4, _fast4$next;\n\n    instructions.setCodeLine(codeLines.checkMeet);\n    instructions.endStep();\n\n    if (slow === fast) {\n      isLoop = true;\n      break;\n    }\n\n    slow = slow.next;\n    fast = fast.next ? fast.next.next : null;\n    instructions.setCodeLine(codeLines.moveNext);\n    instructions.pushActionsAndEndStep('linkedList', [{\n      name: 'focus',\n      params: [(_slow = slow) === null || _slow === void 0 ? void 0 : (_slow$next = _slow.next) === null || _slow$next === void 0 ? void 0 : _slow$next.key]\n    }, {\n      name: 'focus',\n      params: [(_fast3 = fast) === null || _fast3 === void 0 ? void 0 : (_fast3$next = _fast3.next) === null || _fast3$next === void 0 ? void 0 : _fast3$next.key, true]\n    }, {\n      name: 'label',\n      params: ['slow', (_slow2 = slow) === null || _slow2 === void 0 ? void 0 : (_slow2$next = _slow2.next) === null || _slow2$next === void 0 ? void 0 : _slow2$next.key, true]\n    }, {\n      name: 'label',\n      params: ['fast', (_fast4 = fast) === null || _fast4 === void 0 ? void 0 : (_fast4$next = _fast4.next) === null || _fast4$next === void 0 ? void 0 : _fast4$next.key, true]\n    }]);\n  }\n\n  if (!isLoop) {\n    instructions.setCodeLine(codeLines.complete);\n    instructions.endStep();\n  }\n\n  instructions.pushActionsAndEndStep('linkedList', [{\n    name: 'resetAll',\n    params: []\n  }]);\n  return instructions.get();\n};\n\nconst getCodeLine = operation => {\n  switch (operation) {\n    case 'search':\n      return {\n        init: '2-3',\n        compare: '6',\n        compareSuccess: '6',\n        moveNext: '7-8',\n        outOfLoop: '11'\n      };\n\n    case 'insert':\n      return {\n        init: '2-4',\n        findPosition: '5-9',\n        insert: '11-17',\n        complete: '19'\n      };\n\n    case 'delete':\n      return {\n        init: '2-3',\n        findPosition: '4-7',\n        delete: '9',\n        complete: '10'\n      };\n\n    case 'reverse':\n      return {\n        init: '2-4',\n        reversePointer: '7-11',\n        moveNext: '13-15',\n        complete: '18'\n      };\n\n    case 'detectCycle':\n      return {\n        init: '2-3',\n        checkMeet: '6-7',\n        moveNext: '9-11',\n        outOfLoop: '14-15'\n      };\n\n    default:\n      return {};\n  }\n};","map":null,"metadata":{},"sourceType":"module"}