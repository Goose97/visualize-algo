{"ast":null,"code":"import _Reflect$construct from \"@babel/runtime-corejs2/core-js/reflect/construct\";\nimport _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime-corejs2/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime-corejs2/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport _last from \"lodash/last\";\nimport _pick from \"lodash/pick\";\nvar __jsx = React.createElement;\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(_Reflect$construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from 'react';\nimport StackItem from \"./StackItem\";\nimport { STACK_BLOCK_WIDTH, STACK_BLOCK_HEIGHT, STACK_BLOCK_GAP, STACK_BOUNDARY_GAP } from \"../../constants\";\nimport withReverseStep from 'hocs/withReverseStep';\nimport transformStackModel from 'transformers/Stack';\nimport { getProgressDirection, keyExist } from 'utils';\nexport var StackDS = /*#__PURE__*/function (_Component) {\n  _inherits(StackDS, _Component);\n\n  var _super = _createSuper(StackDS);\n\n  function StackDS(props) {\n    var _this;\n\n    _classCallCheck(this, StackDS);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"handleReverse\", function (stateOfPreviousStep) {\n      _this.setState({\n        stackModel: stateOfPreviousStep\n      });\n    });\n\n    _this.state = {\n      stackModel: _this.initStackModel()\n    };\n    return _this;\n  }\n\n  _createClass(StackDS, [{\n    key: \"initStackModel\",\n    value: function initStackModel() {\n      var initialData = this.props.initialData;\n      return initialData.map(function (value, index) {\n        return {\n          value: value,\n          visible: true,\n          key: index,\n          offsetFromFront: index\n        };\n      });\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var _this$props = this.props,\n          currentStep = _this$props.currentStep,\n          reverseToStep = _this$props.reverseToStep,\n          totalStep = _this$props.totalStep; // Update according to algorithm progression\n\n      if (keyExist(this.props, ['currentStep', 'totalStep', 'instructions'])) {\n        switch (getProgressDirection(currentStep, prevProps.currentStep, totalStep)) {\n          case 'forward':\n            this.saveModelSnapshotAtCurrentStep();\n            this.handleForward();\n            break;\n\n          case 'backward':\n            reverseToStep(currentStep);\n            break;\n          // case 'fastForward':\n          //   console.log('fastForward');\n          //   this.handleFastForward();\n          //   break;\n          // case 'fastBackward':\n          //   console.log('fastBackward');\n          //   this.handleFastBackward();\n          //   break;\n        }\n      }\n    }\n  }, {\n    key: \"saveModelSnapshotAtCurrentStep\",\n    value: function saveModelSnapshotAtCurrentStep() {\n      var _this$props2 = this.props,\n          currentStep = _this$props2.currentStep,\n          saveStepSnapshots = _this$props2.saveStepSnapshots;\n      var stackModel = this.state.stackModel;\n      if (typeof currentStep === 'number') saveStepSnapshots(stackModel, currentStep);\n    }\n  }, {\n    key: \"handleForward\",\n    value: function handleForward() {\n      // Treat each action as a transformation function which take a linkedListModel\n      // and return a new one. Consuming multiple actions is merely chaining those\n      // transformations together\n      // linkedListModel ---- action1 ----> linkedListModel1 ---- action2 ----> linkedListMode2 ---- action3 ----> linkedListModel3\n      var stackModel = this.state.stackModel;\n      var _this$props3 = this.props,\n          currentStep = _this$props3.currentStep,\n          instructions = _this$props3.instructions;\n      var actionsToMakeAtThisStep = instructions[currentStep];\n      if (!actionsToMakeAtThisStep || !actionsToMakeAtThisStep.length) return; // This consume pipeline have many side effect in each step. Each\n      // method handle each action has their own side effect\n\n      var newStackModel = this.consumeMultipleActions(actionsToMakeAtThisStep, stackModel);\n      this.setState({\n        stackModel: newStackModel\n      });\n    }\n  }, {\n    key: \"consumeMultipleActions\",\n    value: function consumeMultipleActions(actionList, currentModel, onlyTranformData) {\n      var _this2 = this;\n\n      // Treat each action as a transformation function which take a linkedListModel\n      // and return a new one. Consuming multiple actions is merely chaining those\n      // transformations together\n      // linkedListModel ---- action1 ----> linkedListModel1 ---- action2 ----> linkedListMode2 ---- action3 ----> linkedListModel3\n      return actionList.reduce(function (finalModel, action) {\n        // the main function of a handler is doing side effect before transform model\n        // a handler must also return a new model\n        // if no handler is specify, just transform model right away\n        var name = action.name,\n            params = action.params; //@ts-ignore\n\n        var customHandler = _this2[name];\n\n        if (typeof customHandler === 'function') {\n          return customHandler(finalModel, params, onlyTranformData);\n        } else {\n          return transformStackModel(finalModel, name, params);\n        }\n      }, currentModel);\n    }\n  }, {\n    key: \"push\",\n    value: function push(currentModel, params) {\n      var itemOnTop = _last(currentModel.filter(function (_ref) {\n        var visible = _ref.visible;\n        return !!visible;\n      }));\n\n      var newKey = currentModel.length ? _last(currentModel).key + 1 : 0;\n      var stackItemToPush = {\n        value: params[0],\n        visible: true,\n        offsetFromFront: itemOnTop ? itemOnTop.offsetFromFront + 1 : 0,\n        key: newKey,\n        isNew: true\n      };\n      return transformStackModel(currentModel, 'push', [stackItemToPush]);\n    }\n  }, {\n    key: \"renderBoundary\",\n    value: function renderBoundary() {\n      var moveToCenterPoint = \"M \".concat(STACK_BLOCK_WIDTH / 2, \" \").concat(STACK_BLOCK_HEIGHT + 10);\n      var goUpToTop = \"v \".concat(-this.caculateStackHeight() - 20);\n      return __jsx(\"path\", {\n        className: \"default-stroke no-fill stroke-1\",\n        d: \"\".concat(moveToCenterPoint, \" h \").concat(STACK_BLOCK_WIDTH / 2 + STACK_BOUNDARY_GAP, \" \").concat(goUpToTop, \" \").concat(moveToCenterPoint, \" h \").concat(-STACK_BLOCK_WIDTH / 2 - STACK_BOUNDARY_GAP, \" \").concat(goUpToTop)\n      });\n    }\n  }, {\n    key: \"caculateStackHeight\",\n    value: function caculateStackHeight() {\n      var stackModel = this.state.stackModel;\n      var itemCount = stackModel.filter(function (_ref2) {\n        var visible = _ref2.visible;\n        return !!visible;\n      }).length;\n      return itemCount * (STACK_BLOCK_HEIGHT + STACK_BLOCK_GAP);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var stackModel = this.state.stackModel;\n      var listStackItem = stackModel.map(function (item) {\n        return __jsx(StackItem, item);\n      });\n      return __jsx(React.Fragment, null, __jsx(\"use\", _extends({\n        href: \"#stack\"\n      }, _pick(this.props, ['x', 'y']))), __jsx(\"defs\", null, __jsx(\"g\", {\n        id: \"stack\",\n        className: \"queue__wrapper\"\n      }, listStackItem, this.renderBoundary())));\n    }\n  }]);\n\n  return StackDS;\n}(Component);\nexport default withReverseStep(StackDS);","map":null,"metadata":{},"sourceType":"module"}