{"ast":null,"code":"import _uniqBy from \"lodash/uniqBy\";\nimport _isFunction from \"lodash/isFunction\";\nimport _pick from \"lodash/pick\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { Component } from 'react';\nimport { GraphMemoryBlock, GraphLikeEdges } from 'components';\nimport { GraphHTML } from 'components/Graph/GraphHTML';\nimport withDSCore from 'hocs/withDSCore';\nimport transformGraphModel from 'transformers/Graph';\nexport class GraphDS extends Component {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"wrapperRef\", void 0);\n\n    _defineProperty(this, \"injectHTMLIntoCanvas\", () => {\n      const {\n        model\n      } = this.props;\n      const {\n        handleExecuteApi,\n        dropdownDisabled\n      } = this.props;\n      setTimeout(() => {\n        GraphHTML.renderToView({\n          model,\n          wrapperElement: this.wrapperRef.current,\n          coordinate: _pick(this.props, ['x', 'y']),\n          apiHandler: (apiName, params) => {\n            if (!_isFunction(handleExecuteApi)) return;\n            handleExecuteApi(apiName, params);\n          },\n          disabled: dropdownDisabled\n        });\n      }, 0);\n    });\n\n    this.wrapperRef = React.createRef(); // Register HTML injector\n\n    props.registerHTMLInjector(this.injectHTMLIntoCanvas);\n  }\n\n  static initGraphModel(props) {\n    return props.initialData || [];\n  }\n\n  getGraphModel() {\n    const {\n      data,\n      controlled,\n      model\n    } = this.props;\n    return controlled ? data : model;\n  }\n\n  renderVertices() {\n    return this.getGraphModel().map(node => __jsx(GraphMemoryBlock, node));\n  }\n\n  renderEdges() {\n    let allEdgesToRender = this.getAllEdgesToRender();\n    return allEdgesToRender.map(({\n      key: vertexPair,\n      highlight\n    }) => {\n      const [from, to] = vertexPair.split('-').map(key => this.findNodeByKey(this.getGraphModel(), +key));\n\n      if (from && to) {\n        return __jsx(GraphLikeEdges, {\n          from: _pick(from, ['x', 'y']),\n          to: _pick(to, ['x', 'y']),\n          key: vertexPair,\n          highlight: highlight,\n          visible: true\n        });\n      } else {\n        return null;\n      }\n    });\n  }\n\n  getAllEdgesToRender() {\n    let allEdgesToRender = [];\n    this.getGraphModel().forEach(({\n      key,\n      adjacentNodes,\n      highlightEdges\n    }) => {\n      adjacentNodes.forEach(adjacentKey => {\n        const edgeKey = [key, adjacentKey].sort().join('-');\n        const isEdgeNeedFocus = !!(highlightEdges === null || highlightEdges === void 0 ? void 0 : highlightEdges.includes(adjacentKey));\n        allEdgesToRender.push({\n          key: edgeKey,\n          highlight: isEdgeNeedFocus\n        });\n      });\n    });\n    return _uniqBy([...allEdgesToRender.values()], ({\n      key\n    }) => key);\n  }\n\n  findNodeByKey(model, nodeKey) {\n    return model.find(({\n      key\n    }) => key === nodeKey);\n  }\n\n  render() {\n    return __jsx(React.Fragment, null, __jsx(\"use\", _extends({\n      href: \"#graph\"\n    }, _pick(this.props, ['x', 'y']), {\n      ref: this.wrapperRef\n    })), __jsx(\"defs\", null, __jsx(\"g\", {\n      id: \"graph\"\n    }, this.renderEdges(), this.renderVertices())));\n  }\n\n}\nexport default withDSCore({\n  initModel: GraphDS.initGraphModel,\n  dataTransformer: transformGraphModel //@ts-ignore\n\n})(GraphDS);","map":null,"metadata":{},"sourceType":"module"}