{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { Instructions } from 'instructions';\nimport { caculateKeyHash } from 'components/HashTable/helper';\nimport { HASH_TABLE_UNIVERSAL_KEY_SIZE } from \"../../constants\";\nimport { initLinearProbeHashTableData } from 'components/HashTable/helper';\nexport var hashTableInstruction = function hashTableInstruction(data, operation, parameters) {\n  switch (operation) {\n    case 'insert':\n      return insertInstruction(data, parameters);\n\n    case 'delete':\n      return deleteInstruction(data, parameters);\n\n    default:\n      return [];\n  }\n};\n\nvar insertInstruction = function insertInstruction(data, _ref) {\n  var key = _ref.key,\n      value = _ref.value,\n      collisionResolution = _ref.collisionResolution;\n  var instructions = new Instructions();\n\n  switch (collisionResolution) {\n    case 'chaining':\n      {\n        var hashedAddress = caculateKeyHash(key, HASH_TABLE_UNIVERSAL_KEY_SIZE);\n        instructions.pushActionsAndEndStep('hashTable', [{\n          name: 'insertKey',\n          params: [key, value, hashedAddress]\n        }, {\n          name: 'highlightKey',\n          params: [key]\n        }]);\n        instructions.pushActionsAndEndStep('hashTable', [{\n          name: 'insertValue',\n          params: [value, hashedAddress]\n        }, {\n          name: 'highlightAddress',\n          params: [hashedAddress]\n        }]);\n        instructions.pushActionsAndEndStep('hashTable', [{\n          name: 'resetAll',\n          params: []\n        }]);\n        return instructions.get();\n      }\n\n    case 'linearProbe':\n      {\n        var _initLinearProbeHashT = initLinearProbeHashTableData(data),\n            memoryAddresses = _initLinearProbeHashT.memoryAddresses;\n\n        var addressValuesMap = memoryAddresses.reduce(function (acc, _ref2) {\n          var key = _ref2.key,\n              values = _ref2.values;\n          return _objectSpread({}, acc, _defineProperty({}, key, values));\n        }, {});\n\n        var _hashedAddress = caculateKeyHash(key, HASH_TABLE_UNIVERSAL_KEY_SIZE);\n\n        var displacement = 0;\n        instructions.pushActionsAndEndStep('hashTable', [{\n          name: 'insertKey',\n          params: [key, value, _hashedAddress]\n        }, {\n          name: 'highlightKey',\n          params: [key]\n        }]); // Try to store in initital hash address, if already occupied, advance one address.\n        // Keep repeat till we find the empty slot or out of slot to try\n\n        var addressAttemptToFillValue;\n\n        while (true) {\n          // We only have to perform at most key size attempt\n          if (displacement >= HASH_TABLE_UNIVERSAL_KEY_SIZE) break;\n          addressAttemptToFillValue = (_hashedAddress + displacement) % HASH_TABLE_UNIVERSAL_KEY_SIZE;\n          instructions.pushActionsAndEndStep('hashTable', [{\n            name: 'updateKeyAddress',\n            params: [key, addressAttemptToFillValue]\n          }, {\n            name: 'highlightAddress',\n            params: [addressAttemptToFillValue]\n          }]);\n\n          if (addressValuesMap[addressAttemptToFillValue]) {\n            instructions.pushActions('hashTable', [{\n              name: 'dehighlightAddress',\n              params: [addressAttemptToFillValue]\n            }]);\n            displacement++;\n          } else break;\n        }\n\n        instructions.pushActionsAndEndStep('hashTable', [{\n          name: 'insertValue',\n          params: [value, addressAttemptToFillValue]\n        }, {\n          name: 'updateKeyAddress',\n          params: [key, addressAttemptToFillValue]\n        }]);\n        instructions.pushActionsAndEndStep('hashTable', [{\n          name: 'resetAll',\n          params: []\n        }]);\n      }\n  }\n\n  return instructions.get();\n};\n\nvar deleteInstruction = function deleteInstruction(data, _ref3) {\n  var keyToDelete = _ref3.key,\n      collisionResolution = _ref3.collisionResolution;\n  var instructions = new Instructions();\n\n  switch (collisionResolution) {\n    case 'chaining':\n      {\n        var hashedAddress = caculateKeyHash(keyToDelete, HASH_TABLE_UNIVERSAL_KEY_SIZE);\n        instructions.pushActionsAndEndStep('hashTable', [{\n          name: 'highlightKey',\n          params: [keyToDelete]\n        }, {\n          name: 'highlightAddress',\n          params: [hashedAddress]\n        }]);\n        instructions.pushActionsAndEndStep('hashTable', [{\n          name: 'deleteValue',\n          params: [data[keyToDelete], hashedAddress]\n        }]);\n        instructions.pushActionsAndEndStep('hashTable', [{\n          name: 'deleteKey',\n          params: [keyToDelete]\n        }]);\n        instructions.pushActionsAndEndStep('hashTable', [{\n          name: 'resetAll',\n          params: []\n        }]);\n        break;\n      }\n\n    case 'linearProbe':\n      {\n        var _initLinearProbeHashT2 = initLinearProbeHashTableData(data),\n            keys = _initLinearProbeHashT2.keys,\n            memoryAddresses = _initLinearProbeHashT2.memoryAddresses;\n\n        var initialHashedAddress = caculateKeyHash(keyToDelete, HASH_TABLE_UNIVERSAL_KEY_SIZE);\n        var keyToDeleteObject = keys.find(function (_ref4) {\n          var key = _ref4.key;\n          return key === keyToDelete;\n        });\n        var realHashedAddress = keyToDeleteObject === null || keyToDeleteObject === void 0 ? void 0 : keyToDeleteObject.address; // We will try to find from the initial position, move one down if we can't find\n        // at current position. Do at most HASH_TABLE_UNIVERSAL_KEY_SIZE attempt\n\n        var displacement = 0;\n        var found = false;\n\n        var _loop = function _loop() {\n          if (displacement >= HASH_TABLE_UNIVERSAL_KEY_SIZE) return \"break\";\n          var currentCheckingAddress = (initialHashedAddress + displacement) % HASH_TABLE_UNIVERSAL_KEY_SIZE;\n          instructions.pushActionsAndEndStep('hashTable', [{\n            name: 'highlightKey',\n            params: [keyToDelete]\n          }, {\n            name: 'highlightAddress',\n            params: [currentCheckingAddress]\n          }, {\n            name: 'updateKeyAddress',\n            params: [keyToDelete, currentCheckingAddress]\n          }]); // Reach a empty memory address\n\n          var currentAddressInfo = memoryAddresses.find(function (_ref5) {\n            var key = _ref5.key;\n            return key === currentCheckingAddress;\n          });\n          if (!currentAddressInfo || !currentAddressInfo.values.length) return \"break\";\n\n          if (currentCheckingAddress === realHashedAddress) {\n            found = true;\n            return \"break\";\n          } // Move to next one\n\n\n          displacement++;\n          instructions.pushActions('hashTable', [{\n            name: 'dehighlightAddress',\n            params: [currentCheckingAddress]\n          }]);\n        };\n\n        while (true) {\n          var _ret = _loop();\n\n          if (_ret === \"break\") break;\n        }\n\n        if (found) {\n          var valueToDelete = keyToDeleteObject === null || keyToDeleteObject === void 0 ? void 0 : keyToDeleteObject.value;\n          instructions.pushActionsAndEndStep('hashTable', [{\n            name: 'deleteValue',\n            params: [valueToDelete, realHashedAddress]\n          }, {\n            name: 'deleteKey',\n            params: [keyToDelete]\n          }]);\n        }\n\n        instructions.pushActionsAndEndStep('hashTable', [{\n          name: 'resetAll',\n          params: []\n        }]);\n        break;\n      }\n  }\n\n  return instructions.get();\n}; // const getCodeLine = (operation: HashTable.Api): ObjectType<string> => {\n//   switch (operation) {\n//     // case 'bubbleSort':\n//     //   return {\n//     //     init: '12-18',\n//     //     compare: '14',\n//     //     swap: '15',\n//     //     iteration: '12',\n//     //     step: '13',\n//     //   };\n//     // case 'selectionSort':\n//     //   return {\n//     //     init: '1',\n//     //     swap: '10-14',\n//     //     iteration: '3',\n//     //     findMin: '5',\n//     //     updateMin: '6-7',\n//     //     compare: '6',\n//     //   };\n//     // case 'insertionSort':\n//     //   return {\n//     //     init: '1',\n//     //     swap: '10-14',\n//     //     iteration: '3',\n//     //     findMin: '5',\n//     //     updateMin: '6-7',\n//     //     compare: '6',\n//     //   };\n//     default:\n//       return {};\n//   }\n// };","map":null,"metadata":{},"sourceType":"module"}