{"ast":null,"code":"import _parseFloat from \"@babel/runtime-corejs2/core-js/parse-float\";\nimport _parseInt from \"@babel/runtime-corejs2/core-js/parse-int\";\n\nfunction $$(expr, con) {\n  return Array.prototype.slice.call((con || document).querySelectorAll(expr));\n}\n\nfunction hasClass(element, className) {\n  className = ' ' + className + ' ';\n  return (' ' + element.className + ' ').replace(/[\\n\\t]/g, ' ').indexOf(className) > -1;\n}\n\nfunction callFunction(func) {\n  func();\n} // Some browsers round the line-height, others don't.\n// We need to test for it to position the elements properly.\n\n\nvar isLineHeightRounded = function () {\n  var res;\n  return function () {\n    if (typeof res === 'undefined') {\n      var d = document.createElement('div');\n      d.style.fontSize = '13px';\n      d.style.lineHeight = '1.5';\n      d.style.padding = 0;\n      d.style.border = 0;\n      d.innerHTML = '&nbsp;<br />&nbsp;';\n      document.body.appendChild(d); // Browsers that round the line-height should have offsetHeight === 38\n      // The others should have 39.\n\n      res = d.offsetHeight === 38;\n      document.body.removeChild(d);\n    }\n\n    return res;\n  };\n}();\n/**\n * Highlights the lines of the given pre.\n *\n * This function is split into a DOM measuring and mutate phase to improve performance.\n * The returned function mutates the DOM when called.\n *\n * @param {HTMLElement} pre\n * @param {string} [lines]\n * @param {string} [classes='']\n * @returns {() => void}\n */\n\n\nfunction highlightLines(pre, lines, classes) {\n  lines = typeof lines === 'string' ? lines : pre.getAttribute('data-line');\n  var ranges = lines.replace(/\\s+/g, '').split(',');\n  var offset = +pre.getAttribute('data-line-offset') || 0;\n  var parseMethod = isLineHeightRounded() ? _parseInt : _parseFloat;\n  var lineHeight = parseMethod(getComputedStyle(pre).lineHeight);\n  var hasLineNumbers = hasClass(pre, 'line-numbers');\n  var parentElement = hasLineNumbers ? pre : pre.querySelector('code') || pre;\n  var mutateActions =\n  /** @type {(() => void)[]} */\n  [];\n  ranges.forEach(function (currentRange) {\n    var range = currentRange.split('-');\n    var start = +range[0];\n    var end = +range[1] || start;\n    var line = pre.querySelector('.line-highlight[data-range=\"' + currentRange + '\"]') || document.createElement('div');\n    mutateActions.push(function () {\n      line.setAttribute('aria-hidden', 'true');\n      line.setAttribute('data-range', currentRange);\n      line.className = (classes || '') + ' line-highlight';\n    }); // if the line-numbers plugin is enabled, then there is no reason for this plugin to display the line numbers\n\n    if (hasLineNumbers && Prism.plugins.lineNumbers) {\n      var startNode = Prism.plugins.lineNumbers.getLine(pre, start);\n      var endNode = Prism.plugins.lineNumbers.getLine(pre, end);\n\n      if (startNode) {\n        var top = startNode.offsetTop + 'px';\n        mutateActions.push(function () {\n          line.style.top = top;\n        });\n      }\n\n      if (endNode) {\n        var height = endNode.offsetTop - startNode.offsetTop + endNode.offsetHeight + 'px';\n        mutateActions.push(function () {\n          line.style.height = height;\n        });\n      }\n    } else {\n      mutateActions.push(function () {\n        line.setAttribute('data-start', start);\n\n        if (end > start) {\n          line.setAttribute('data-end', end);\n        }\n\n        line.style.top = (start - offset - 1) * lineHeight + 'px';\n        line.textContent = new Array(end - start + 2).join(' \\n');\n      });\n    }\n\n    mutateActions.push(function () {\n      // allow this to play nicely with the line-numbers plugin\n      // need to attack to pre as when line-numbers is enabled, the code tag is relatively which screws up the positioning\n      parentElement.appendChild(line);\n    });\n  });\n  return function () {\n    mutateActions.forEach(callFunction);\n  };\n}\n\nfunction applyHash() {\n  var hash = location.hash.slice(1); // Remove pre-existing temporary lines\n\n  $$('.temporary.line-highlight').forEach(function (line) {\n    line.parentNode.removeChild(line);\n  });\n  var range = (hash.match(/\\.([\\d,-]+)$/) || [, ''])[1];\n\n  if (!range || document.getElementById(hash)) {\n    return;\n  }\n\n  var id = hash.slice(0, hash.lastIndexOf('.')),\n      pre = document.getElementById(id);\n\n  if (!pre) {\n    return;\n  }\n\n  if (!pre.hasAttribute('data-line')) {\n    pre.setAttribute('data-line', '');\n  }\n\n  var mutateDom = highlightLines(pre, range, 'temporary ');\n  mutateDom();\n  document.querySelector('.temporary.line-highlight').scrollIntoView();\n}\n\nfunction cleanUpAllHighlights(pre) {\n  $$('.line-highlight', pre).forEach(function (highlightLine) {\n    highlightLine.parentNode.removeChild(highlightLine);\n  });\n}\n\nfunction reApplyHighlight() {\n  var actions = [];\n  $$('pre[data-line]').forEach(function (pre) {\n    actions.push(highlightLines(pre));\n  });\n  actions.forEach(callFunction);\n}\n\nfunction reset(pre) {\n  cleanUpAllHighlights(pre);\n  reApplyHighlight();\n}\n\nfunction init() {\n  if (typeof self === 'undefined' || !self.Prism || !self.document || !document.querySelector) {\n    return;\n  }\n\n  var fakeTimer = 0; // Hack to limit the number of times applyHash() runs\n\n  Prism.hooks.add('before-sanity-check', function (env) {\n    var pre = env.element.parentNode;\n    var lines = pre && pre.getAttribute('data-line');\n\n    if (!pre || !lines || !/pre/i.test(pre.nodeName)) {\n      return;\n    }\n    /*\n     * Cleanup for other plugins (e.g. autoloader).\n     *\n     * Sometimes <code> blocks are highlighted multiple times. It is necessary\n     * to cleanup any left-over tags, because the whitespace inside of the <div>\n     * tags change the content of the <code> tag.\n     */\n\n\n    var num = 0;\n    $$('.line-highlight', pre).forEach(function (line) {\n      num += line.textContent.length;\n      line.parentNode.removeChild(line);\n    }); // Remove extra whitespace\n\n    if (num && /^( \\n)+$/.test(env.code.slice(-num))) {\n      env.code = env.code.slice(0, -num);\n    }\n  });\n  Prism.hooks.add('complete', function completeHook(env) {\n    var pre = env.element.parentNode;\n    var lines = pre && pre.getAttribute('data-line');\n\n    if (!pre || !lines || !/pre/i.test(pre.nodeName)) {\n      return;\n    }\n\n    clearTimeout(fakeTimer);\n    var hasLineNumbers = Prism.plugins.lineNumbers;\n    var isLineNumbersLoaded = env.plugins && env.plugins.lineNumbers;\n\n    if (hasClass(pre, 'line-numbers') && hasLineNumbers && !isLineNumbersLoaded) {\n      Prism.hooks.add('line-numbers', completeHook);\n    } else {\n      var mutateDom = highlightLines(pre, lines);\n      mutateDom();\n      fakeTimer = setTimeout(applyHash, 1);\n    }\n  });\n  window.addEventListener('hashchange', applyHash);\n  window.addEventListener('resize', reApplyHighlight);\n}\n\nexport default {\n  init: init,\n  reset: reset\n};","map":null,"metadata":{},"sourceType":"module"}