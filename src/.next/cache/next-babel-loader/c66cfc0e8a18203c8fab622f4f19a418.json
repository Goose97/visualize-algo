{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { Component } from 'react';\nimport ReactDOM from 'react-dom';\nimport { Button, CustomModal, GraphDS } from 'components';\nimport withExtendClassName from 'hocs/withExtendClassName';\nimport { caculatePointerPathFromTwoNodeCenter, caculateDistanceToALine } from 'utils';\nimport transformGraphModel from 'transformers/Graph';\nimport { GRAPH_NODE_RADIUS } from \"../../constants\";\nexport class InitGraphInput extends Component {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"inputRef\", void 0);\n\n    _defineProperty(this, \"svgWrapper\", void 0);\n\n    _defineProperty(this, \"currentlyHoverOnEdges\", void 0);\n\n    _defineProperty(this, \"handleChange\", e => {\n      const stateChanges = this.getBSTRepresentationFromInputText(e.target.value); //@ts-ignore\n\n      this.setState(_objectSpread({}, stateChanges, {\n        textInput: e.target.value\n      }));\n    });\n\n    _defineProperty(this, \"focusToInput\", () => {\n      const inputElement = this.inputRef.current;\n      const htmlInput = ReactDOM.findDOMNode(inputElement);\n      htmlInput === null || htmlInput === void 0 ? void 0 : htmlInput.focus();\n    });\n\n    _defineProperty(this, \"handleMouseEnter\", e => {\n      const svgElement = e.currentTarget;\n\n      if (svgElement) {\n        this.svgWrapper = svgElement; //@ts-ignore\n\n        svgElement.addEventListener('mousemove', e => this.handleMouseMove(e));\n        svgElement.addEventListener('mouseleave', () => this.handleMouseLeave());\n      }\n    });\n\n    _defineProperty(this, \"handleMouseMove\", e => {\n      const ghostNode = this.svgWrapper.querySelector('.init-graph-canvas__ghost-node');\n      if (!ghostNode) return;\n      const mousePosition = this.getRelativeMousePositionWithSvg(e); // Make ghost node follow mouse position\n\n      const transformString = `translate(${mousePosition.x}, ${mousePosition.y})`;\n      ghostNode.setAttribute('transform', transformString); // Hide ghost node if currently hover on ghost edge\n\n      const ghostEdgesMouseCurrentlyHover = this.getGhostEdgesMouseCurrentlyHover(e);\n      ghostNode.setAttribute('opacity', ghostEdgesMouseCurrentlyHover.length ? '0' : '1'); // Hide ghost edges which are not currently hover on\n      // Show those got hovered\n\n      this.showAndHideGhostEdges(ghostEdgesMouseCurrentlyHover); // Save current hovered edges\n\n      this.currentlyHoverOnEdges = ghostEdgesMouseCurrentlyHover;\n    });\n\n    _defineProperty(this, \"handleMouseLeave\", () => {\n      const ghostNode = this.svgWrapper.querySelector('.init-graph-canvas__ghost-node');\n      const transformString = `translate(-100, -100)`;\n      ghostNode && ghostNode.setAttribute('transform', transformString);\n    });\n\n    _defineProperty(this, \"handleClickOnSvg\", e => {\n      try {\n        const svgElement = e.currentTarget;\n        const ghostNode = svgElement.querySelector('.init-graph-canvas__ghost-node'); //@ts-ignore\n\n        const transform = ghostNode.getAttribute('transform');\n        const regex = /(?<=translate\\()(\\d+).*?(\\d+)(?=\\))/;\n        const match = transform === null || transform === void 0 ? void 0 : transform.match(regex);\n        const currentMouseCoordinate = {\n          //@ts-ignore\n          x: +match[1],\n          //@ts-ignore\n          y: +match[2]\n        };\n\n        if (this.currentlyHoverOnEdges.length) {\n          this.addNewEdges(this.currentlyHoverOnEdges);\n        } else {\n          this.addNewNode(currentMouseCoordinate);\n        }\n      } catch (error) {}\n    });\n\n    _defineProperty(this, \"handleOk\", () => {\n      const {\n        onSubmit\n      } = this.props;\n      const {\n        graphData\n      } = this.state; // Shift all node to left and top some amount so the whole DS start at 0 and 0\n\n      const amountToShiftLeft = Math.min(...graphData.map(({\n        x\n      }) => x));\n      const amountToShiftTop = Math.min(...graphData.map(({\n        y\n      }) => y));\n      const shiftedGraphData = graphData.map(node => _objectSpread({}, node, {\n        x: node.x - amountToShiftLeft,\n        y: node.y - amountToShiftTop\n      }));\n      onSubmit(shiftedGraphData);\n    });\n\n    this.state = {\n      input: [],\n      error: null,\n      isModalVisible: false,\n      graphData: []\n    };\n    this.inputRef = React.createRef();\n    this.currentlyHoverOnEdges = [];\n  }\n\n  getBSTRepresentationFromInputText(inputText) {\n    const regex = /^\\[([(\\d|null),\\s]+)\\]$/;\n    const match = inputText.match(regex);\n    if (!match) return {\n      error: 'Sai cú pháp'\n    };\n    return {\n      input: match[1].split(',').map(string => string.includes('null') ? null : parseInt(string)).filter(item => item === null || typeof item === 'number'),\n      error: null\n    };\n  }\n\n  renderGhostNode() {\n    return __jsx(\"g\", {\n      className: \"init-graph-canvas__ghost-node\",\n      transform: \"translate(-100, -100)\"\n    }, __jsx(\"circle\", {\n      cx: 0,\n      cy: 0,\n      r: GRAPH_NODE_RADIUS\n    }), __jsx(\"text\", {\n      x: 0,\n      y: 0,\n      dominantBaseline: \"middle\",\n      textAnchor: \"middle\"\n    }, \"+\"));\n  }\n\n  showAndHideGhostEdges(currentHoverOnEdges) {\n    currentHoverOnEdges.forEach(edge => {\n      edge.parentNode.classList.add('show');\n    });\n    const allGhostEdges = this.svgWrapper.querySelectorAll('.init-graph-canvas__ghost-edge-hover-area');\n    Array.from(allGhostEdges).forEach(edge => {\n      if (!currentHoverOnEdges.includes(edge)) edge.parentNode.classList.remove('show');\n    });\n  }\n\n  getRelativeMousePositionWithSvg(e) {\n    const {\n      left,\n      top\n    } = this.svgWrapper.getBoundingClientRect();\n    const offsetLeft = e.clientX - left;\n    const offsetTop = e.clientY - top;\n    return {\n      x: offsetLeft,\n      y: offsetTop\n    };\n  }\n\n  getGhostEdgesMouseCurrentlyHover(mouseEvent) {\n    const allGhostEdges = this.svgWrapper.querySelectorAll('.init-graph-canvas__ghost-edge > .init-graph-canvas__ghost-edge-hover-area');\n    const {\n      x: mouseX,\n      y: mouseY\n    } = this.getRelativeMousePositionWithSvg(mouseEvent);\n    if (!allGhostEdges) return [];\n    return Array.from(allGhostEdges).filter(item => {\n      // We consider point which stay in range of the line\n      // and also have distance to the line smaller than 10\n      const [startX, startY, endX, endY] = ['start-x', 'start-y', 'end-x', 'end-y'].map(attrs => {\n        const value = item.getAttribute(attrs);\n        return value != null ? parseInt(value) : 0;\n      });\n      const inRangeOfLine = (mouseY - startY) * (mouseY - endY) < 0 || (mouseX - startX) * (mouseX - endX) < 0;\n      const distance = caculateDistanceToALine({\n        x: mouseX,\n        y: mouseY\n      }, {\n        x: startX,\n        y: startY\n      }, {\n        x: endX,\n        y: endY\n      });\n      return inRangeOfLine && distance < 25;\n    });\n  }\n\n  addNewEdges(edgesPathElement) {\n    const {\n      graphData\n    } = this.state;\n\n    const addOneEdge = (data, edgeElement) => {\n      const edgeKey = edgeElement.parentNode.getAttribute('edgekey');\n      if (!edgeKey) return data;\n      const [nodeA, nodeB] = edgeKey.split('-').map(item => parseInt(item));\n      return transformGraphModel(data, 'addEdge', [nodeA, nodeB]);\n    };\n\n    const graphDataAfterAddEdges = edgesPathElement.reduce((finalState, edgeElement) => addOneEdge(finalState, edgeElement), graphData);\n    this.setState({\n      graphData: graphDataAfterAddEdges\n    });\n  }\n\n  addNewNode(coordinate) {\n    const {\n      graphData\n    } = this.state;\n    const biggestKey = Math.max(...graphData.map(({\n      key\n    }) => key));\n    const newNode = {\n      x: coordinate.x - GRAPH_NODE_RADIUS,\n      y: coordinate.y - GRAPH_NODE_RADIUS,\n      key: ~~biggestKey + 1,\n      adjacentNodes: [],\n      value: ~~biggestKey + 1,\n      visible: true\n    };\n    this.setState({\n      graphData: graphData.concat(newNode)\n    });\n  }\n\n  renderGhostEdges() {\n    const {\n      graphData\n    } = this.state;\n    if (graphData.length < 2) return null;\n    let result = [];\n\n    for (let i = 0; i < graphData.length; i++) {\n      for (let j = i + 1; j < graphData.length; j++) {\n        const ghoseEdge = this.renderOneGhostEdge(graphData[i], graphData[j]);\n        result.push(ghoseEdge);\n      }\n    }\n\n    return result;\n  }\n\n  renderOneGhostEdge(nodeA, nodeB) {\n    const nodeACenter = {\n      x: nodeA.x + GRAPH_NODE_RADIUS,\n      y: nodeA.y + GRAPH_NODE_RADIUS\n    };\n    const nodeBCenter = {\n      x: nodeB.x + GRAPH_NODE_RADIUS,\n      y: nodeB.y + GRAPH_NODE_RADIUS\n    };\n    const pathAndRotation = caculatePointerPathFromTwoNodeCenter(nodeACenter, nodeBCenter, GRAPH_NODE_RADIUS, true);\n    const key = `${nodeA.key}-${nodeB.key}`;\n    return (//@ts-ignore\n      __jsx(\"g\", {\n        className: \"init-graph-canvas__ghost-edge\",\n        key: key,\n        edgekey: key\n      }, __jsx(\"path\", {\n        transform: pathAndRotation.transform,\n        d: pathAndRotation.path,\n        \"start-x\": nodeACenter.x,\n        \"start-y\": nodeACenter.y,\n        \"end-x\": nodeBCenter.x,\n        \"end-y\": nodeBCenter.y,\n        className: \"init-graph-canvas__ghost-edge-hover-area stroke-1\"\n      }), __jsx(\"path\", _extends({}, pathAndRotation, {\n        d: pathAndRotation.path,\n        className: \"default-stroke stroke-2\"\n      })))\n    );\n  }\n\n  render() {\n    const {\n      isModalVisible,\n      graphData\n    } = this.state;\n    const {\n      className\n    } = this.props;\n\n    const previewWindow = __jsx(\"div\", {\n      className: \"init-bst-modal__preview fx-7\"\n    }, __jsx(\"svg\", {\n      className: \"init-graph-canvas__wrapper h-full w-full\",\n      onMouseEnter: this.handleMouseEnter,\n      onClick: this.handleClickOnSvg\n    }, this.renderGhostNode(), this.renderGhostEdges(), __jsx(GraphDS, {\n      data: graphData,\n      controlled: true,\n      x: 0,\n      y: 0,\n      instructions: []\n    })));\n\n    return __jsx(Button, {\n      type: \"primary\",\n      className: className,\n      onClick: () => this.setState({\n        isModalVisible: true\n      })\n    }, \"Create new graph\", __jsx(CustomModal, {\n      visible: isModalVisible,\n      title: \"Construct new graph\",\n      onCancel: () => this.setState({\n        isModalVisible: false\n      }),\n      onOk: this.handleOk\n    }, __jsx(\"div\", {\n      className: \"init-bst-modal__wrapper fx\"\n    }, previewWindow)));\n  }\n\n}\nexport default withExtendClassName('f-big-2 px-6 py-2')(InitGraphInput);","map":null,"metadata":{},"sourceType":"module"}