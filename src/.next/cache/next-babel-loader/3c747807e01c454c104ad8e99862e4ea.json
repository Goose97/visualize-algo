{"ast":null,"code":"import _Reflect$construct from \"@babel/runtime-corejs2/core-js/reflect/construct\";\nimport _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _toConsumableArray from \"@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime-corejs2/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime-corejs2/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport _pick from \"lodash/pick\";\nvar __jsx = React.createElement;\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(_Reflect$construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from 'react';\nimport withDSCore from 'hocs/withDSCore';\nimport ArrayMemoryBlock from \"./ArrayMemoryBlock\";\nimport SortSeperationLine from \"./SortSeperationLine\";\nimport ArrayHTML from \"./ArrayHTML\";\nimport transformArrayModel from 'transformers/Array';\nimport { ARRAY_BLOCK_WIDTH } from \"../../constants\";\n\nvar ArrayDS = /*#__PURE__*/function (_Component) {\n  _inherits(ArrayDS, _Component);\n\n  var _super = _createSuper(ArrayDS);\n\n  // save initial X so we can perform animation\n  function ArrayDS(props) {\n    var _this;\n\n    _classCallCheck(this, ArrayDS);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"wrapperRef\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"sortingLineInitialX\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"injectHTMLIntoCanvas\", function () {\n      var _this$props = _this.props,\n          handleExecuteApi = _this$props.handleExecuteApi,\n          dropdownDisabled = _this$props.dropdownDisabled,\n          model = _this$props.model;\n      setTimeout(function () {\n        ArrayHTML.renderToView({\n          model: model,\n          wrapperElement: _this.wrapperRef.current,\n          coordinate: _pick(_this.props, ['x', 'y']),\n          apiHandler: handleExecuteApi,\n          disabled: dropdownDisabled\n        });\n      }, 0);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"setUnsortedLine\", function (currentModel, _ref) {\n      var _ref2 = _slicedToArray(_ref, 1),\n          key = _ref2[0];\n\n      var sortingState = _this.state.sortingState;\n      var elementWithLine = currentModel.find(function (_ref3) {\n        var itemKey = _ref3.key;\n        return itemKey === key;\n      });\n      if (!elementWithLine) return currentModel;\n\n      _this.setState({\n        sortingState: _Object$assign({}, sortingState, {\n          currentSortingElementIndex: elementWithLine.index\n        })\n      });\n\n      return currentModel;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"setCurrentInsertionSortNode\", function (currentModel, _ref4) {\n      var _ref5 = _slicedToArray(_ref4, 1),\n          key = _ref5[0];\n\n      var sortingState = _this.state.sortingState;\n      var currentSortingElement = currentModel.find(function (_ref6) {\n        var itemKey = _ref6.key;\n        return key === itemKey;\n      });\n\n      _this.setState({\n        sortingState: _Object$assign({}, sortingState, {\n          currentSortingElementKey: currentSortingElement === null || currentSortingElement === void 0 ? void 0 : currentSortingElement.key\n        })\n      });\n\n      return currentModel;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"unsetCurrentInsertionSortNode\", function (currentModel) {\n      var sortingState = _this.state.sortingState;\n\n      _this.setState({\n        sortingState: _Object$assign({}, sortingState, {\n          currentSortingElementKey: null\n        })\n      });\n\n      return currentModel;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"resetAll\", function (currentModel) {\n      _this.setState({\n        sortingState: {}\n      });\n\n      return transformArrayModel(currentModel, 'resetAll', []);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"renderSeparationLine\", function () {\n      var currentSortingElementIndex = _this.state.sortingState.currentSortingElementIndex;\n      var currentApi = _this.props.currentApi;\n      if (currentSortingElementIndex == null) return null; // Because line could appear before or after the block, we need to plus one if needed\n\n      var getActualLineIndex = function getActualLineIndex() {\n        var currentSortingElementIndex = _this.state.sortingState.currentSortingElementIndex;\n        var currentApi = _this.props.currentApi;\n\n        switch (currentApi) {\n          case 'selectionSort':\n          case 'bubbleSort':\n            return currentSortingElementIndex;\n\n          case 'insertionSort':\n            return currentSortingElementIndex + 1;\n        }\n      };\n\n      var x = ARRAY_BLOCK_WIDTH * getActualLineIndex();\n      if (_this.sortingLineInitialX === undefined) _this.sortingLineInitialX = x;\n      return __jsx(SortSeperationLine, {\n        currentApi: currentApi,\n        initialX: _this.sortingLineInitialX,\n        currentX: x\n      });\n    });\n\n    _this.state = {\n      isVisible: true,\n      sortingState: {}\n    };\n    _this.wrapperRef = React.createRef(); // Register custom transformer\n\n    props.registerCustomTransformer({\n      push: _this.push,\n      setUnsortedLine: _this.setUnsortedLine,\n      setCurrentInsertionSortNode: _this.setCurrentInsertionSortNode,\n      unsetCurrentInsertionSortNode: _this.unsetCurrentInsertionSortNode,\n      resetAll: _this.resetAll\n    }); // Register HTML injector\n\n    props.registerHTMLInjector(_this.injectHTMLIntoCanvas);\n    return _this;\n  }\n\n  _createClass(ArrayDS, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var currentApi = this.props.currentApi;\n\n      if (currentApi !== prevProps.currentApi) {\n        this.setState({\n          sortingState: {}\n        });\n        this.sortingLineInitialX = undefined;\n      }\n    }\n  }, {\n    key: \"push\",\n    // Custom transformers\n    value: function push(currentModel, params) {\n      var biggestKey = currentModel.length ? Math.max.apply(Math, _toConsumableArray(currentModel.map(function (_ref7) {\n        var key = _ref7.key;\n        return key;\n      }))) : -1;\n      var newArrayNode = {\n        value: params[0],\n        key: biggestKey + 1,\n        index: currentModel.length,\n        visible: true\n      };\n      return transformArrayModel(currentModel, 'push', [newArrayNode]);\n    }\n  }, {\n    key: \"renderCurrentSortingItem\",\n    value: function renderCurrentSortingItem() {\n      var _this$state$sortingSt = this.state.sortingState,\n          currentSortingElementIndex = _this$state$sortingSt.currentSortingElementIndex,\n          currentSortingElementKey = _this$state$sortingSt.currentSortingElementKey;\n      var blockType = this.props.blockType;\n      if (currentSortingElementKey == undefined) return null;\n      var currentSortingNode = this.findArrayNodeByKey(currentSortingElementKey);\n      if (currentSortingElementIndex === undefined || currentSortingNode === undefined) return null;\n      return __jsx(ArrayMemoryBlock, {\n        visible: true,\n        value: null,\n        index: currentSortingElementIndex + 1,\n        blockType: blockType,\n        transform: \"translate(0, 100)\"\n      });\n    }\n  }, {\n    key: \"findArrayNodeByKey\",\n    value: function findArrayNodeByKey(key) {\n      var model = this.props.model;\n      return model.find(function (_ref8) {\n        var keyToFind = _ref8.key;\n        return key === keyToFind;\n      });\n    }\n  }, {\n    key: \"checkIndexState\",\n    value: function checkIndexState(index, stateProperty) {\n      var model = this.props.model;\n      var arrayItem = model.find(function (_ref9) {\n        var itemIndex = _ref9.index;\n        return index === itemIndex;\n      });\n      if (!arrayItem) return false;\n      return !!arrayItem[stateProperty];\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var currentSortingElementKey = this.state.sortingState.currentSortingElementKey;\n      var _this$props2 = this.props,\n          blockType = _this$props2.blockType,\n          model = _this$props2.model;\n      var hollowArrayMemoryBlock = model.map(function (_ref10, index) {\n        var key = _ref10.key;\n        return __jsx(ArrayMemoryBlock, {\n          key: key,\n          visible: true,\n          value: null,\n          index: index,\n          blockType: blockType,\n          blur: _this2.checkIndexState(index, 'blur'),\n          focus: _this2.checkIndexState(index, 'focus')\n        });\n      });\n      var arrayMemoryBlock = model.map(function (arrayNode) {\n        var key = arrayNode.key;\n        return __jsx(ArrayMemoryBlock, _extends({}, arrayNode, {\n          blockType: blockType,\n          className: \"array-memory-block--only-value\",\n          isInsertionSorting: currentSortingElementKey === key,\n          labelDirection: \"bottom\"\n        }));\n      });\n      return __jsx(React.Fragment, null, __jsx(\"use\", _extends({\n        href: \"#array\"\n      }, _pick(this.props, ['x', 'y']), {\n        ref: this.wrapperRef\n      })), __jsx(\"defs\", null, __jsx(\"g\", {\n        id: \"array\"\n      }, this.renderCurrentSortingItem(), hollowArrayMemoryBlock, arrayMemoryBlock, this.renderSeparationLine())));\n    }\n  }], [{\n    key: \"initArrayModel\",\n    value: function initArrayModel(props) {\n      return props.initialData.map(function (value, index) {\n        return {\n          value: value,\n          index: index,\n          visible: true,\n          visited: false,\n          key: index,\n          focus: false\n        };\n      });\n    }\n  }]);\n\n  return ArrayDS;\n}(Component);\n\nexport default withDSCore({\n  initModel: ArrayDS.initArrayModel,\n  dataTransformer: transformArrayModel\n})(ArrayDS);","map":null,"metadata":{},"sourceType":"module"}