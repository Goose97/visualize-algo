{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst DEFAULT_DURATION = 1500;\nexport class Instructions {\n  constructor() {\n    _defineProperty(this, \"instructions\", void 0);\n\n    this.instructions = [];\n  }\n\n  push(instruction) {\n    const newInstruction = Object.assign({\n      duration: DEFAULT_DURATION\n    }, instruction);\n    this.instructions.push(newInstruction);\n  }\n\n  get() {\n    return this.instructions;\n  }\n\n}\nexport class BinarySearchTree {\n  constructor() {\n    _defineProperty(this, \"root\", void 0);\n\n    _defineProperty(this, \"key\", void 0);\n\n    this.root = null;\n    this.key = 0;\n  } // Insert a value as a node in the BST\n\n\n  insert(value) {\n    let newNode = new BinaryTreeNode(value, this.key++); // If root empty, set new node as the root\n\n    if (!this.root) {\n      this.root = newNode;\n    } else {\n      this.insertNode(this.root, newNode);\n    }\n  } // helper function\n\n\n  insertNode(root, newNode) {\n    if (newNode.val < root.val) {\n      // If no left child, then just insesrt to the left\n      if (!root.left) {\n        root.left = newNode;\n      } else {\n        this.insertNode(root.left, newNode);\n      }\n    } else {\n      // If no right child, then just insesrt to the right\n      if (!root.right) {\n        root.right = newNode;\n      } else {\n        this.insertNode(root.right, newNode);\n      }\n    }\n  } // Remove a node with the value passed\n\n\n  remove(value) {\n    if (!this.root) {\n      return 'Tree is empty!';\n    } else {\n      this.removeNode(this.root, value);\n    }\n  } // helper function\n\n\n  removeNode(root, value) {\n    if (!root) {\n      return null;\n    } // If value is less than root value, go to the left subtree\n\n\n    if (value < root.val) {\n      root.left = this.removeNode(root.left, value);\n      return root; // If value is greater than root value, go to the right subtree\n    } else if (value > root.val) {\n      root.right = this.removeNode(root.right, value);\n      return root; // If we found the value, remove the node\n    } else {\n      // If no child nodes, just remove the node\n      if (!root.left && !root.right) {\n        root = null;\n        return root;\n      } // If one child (left)\n\n\n      if (root.left) {\n        root = root.left;\n        return root; // If one child (right)\n      } else if (root.right) {\n        root = root.right;\n        return root;\n      } // If two child nodes (both)\n      // Get the minimum of the right subtree to ensure we have valid replacement\n\n\n      let minRight = this.findMinNode(root.right);\n      root.val = minRight.val; // Make sure we remove the node that we replaced the deleted node\n\n      root.right = this.removeNode(root.right, minRight.val);\n      return root;\n    }\n  }\n\n  findMinNode(root) {\n    if (!root || !root.left) {\n      return root;\n    } else {\n      return this.findMinNode(root.left);\n    }\n  } // Return boolean value depending on the existence of the value in the tree\n\n\n  search(value) {\n    if (!this.root) {\n      return 'Tree is empty';\n    } else {\n      return Boolean(this.searchNode(this.root, value));\n    }\n  }\n\n  searchNode(root, value) {\n    if (!root) {\n      return null;\n    }\n\n    if (value < root.val) {\n      return this.searchNode(root.left, value);\n    } else if (value > root.val) {\n      return this.searchNode(root.right, value);\n    }\n\n    return root;\n  } //-----3----\n  //----------\n  //--1----4--  ------->>>> [3, 1, 4, 0, 2, null, 6]\n  //----------\n  //0--2-----6\n\n\n  getLayerRepresentation() {\n    // Do a level traversal\n    let queue = [this.root];\n    let result = [];\n\n    while (queue.length) {\n      let currentNode = queue.shift();\n      result.push(currentNode ? currentNode.val : currentNode);\n\n      if (currentNode) {\n        queue.push(currentNode.left);\n        queue.push(currentNode.right);\n      }\n    } // Trim the trailing nulls\n\n\n    let lastValueIndex;\n\n    for (let i = result.length - 1; i >= 0; i--) {\n      if (result[i] !== null) {\n        lastValueIndex = i;\n        break;\n      }\n    }\n\n    return lastValueIndex !== undefined ? result.slice(0, lastValueIndex + 1) : [];\n  }\n\n}\nexport class BinaryTreeNode {\n  constructor(val, key) {\n    _defineProperty(this, \"val\", void 0);\n\n    _defineProperty(this, \"key\", void 0);\n\n    _defineProperty(this, \"left\", void 0);\n\n    _defineProperty(this, \"right\", void 0);\n\n    this.val = val;\n    this.key = key;\n    this.left = null;\n    this.right = null;\n  }\n\n}\nexport function initBinaryTree(array) {\n  let head = null;\n  let queue = [];\n  let counter = 0;\n  let key = 0;\n  if (!array.length) return null;\n\n  for (let i = 0; i < array.length; i++) {\n    let val = array[i];\n    const newNode = val !== null ? new BinaryTreeNode(val, key++) : null;\n\n    if (head) {\n      let parentNode = queue[0];\n\n      if (counter === 0) {\n        // this node is left of parent node\n        parentNode.left = newNode;\n        counter++;\n      } else {\n        // this node is right of parent node\n        parentNode.right = newNode;\n        counter = 0;\n        queue.shift();\n      }\n    } else {\n      head = newNode;\n    }\n\n    queue.push(newNode);\n  }\n\n  return head;\n}\nexport const findPredecessorOfNode = node => {\n  // The biggest node in the left sub-tree\n  if (!node.left) return node;\n  let currentNode = node.left;\n\n  while (currentNode.right) {\n    currentNode = currentNode.right;\n  }\n\n  return currentNode;\n};\nexport const validateBinaryTree = input => {\n  function helper(bst) {\n    if (bst === null) return [null, null, true];\n    const [minLeft, maxLeft, isLeftValid] = helper(bst.left);\n    const [minRight, maxRight, isRightValid] = helper(bst.right);\n    if (!isLeftValid || !isRightValid) return [null, null, false];\n    const isBiggerThanLeftSubtree = maxLeft === null || bst.val > maxLeft;\n    const isSmallerThanRightSubtree = minRight === null || bst.val < minRight;\n    const isValid = isBiggerThanLeftSubtree && isSmallerThanRightSubtree;\n    const minOfThisSubTree = minLeft === null ? bst.val : minLeft;\n    const maxOfThisSubTree = maxRight === null ? bst.val : maxRight;\n    return [minOfThisSubTree, maxOfThisSubTree, isValid];\n  }\n\n  const bst = initBinaryTree(input);\n  return helper(bst)[2];\n}; // Insert one by one\n\nexport const initBSTbySequentiallyInsert = array => {\n  let bst = new BinarySearchTree();\n  array.filter(item => item).forEach(item => bst.insert(item));\n  return bst;\n};","map":null,"metadata":{},"sourceType":"module"}