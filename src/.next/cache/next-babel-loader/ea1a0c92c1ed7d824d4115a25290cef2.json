{"ast":null,"code":"import _last from \"lodash/last\";\nimport _pick from \"lodash/pick\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { Component } from 'react';\nimport StackItem from \"./StackItem\";\nimport { STACK_BLOCK_WIDTH, STACK_BLOCK_HEIGHT, STACK_BLOCK_GAP, STACK_BOUNDARY_GAP } from \"../../constants\";\nimport withReverseStep from 'hocs/withReverseStep';\nimport transformStackModel from 'transformers/Stack';\nimport { getProgressDirection, keyExist } from 'utils';\nexport class StackDS extends Component {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"handleReverse\", stateOfPreviousStep => {\n      this.setState({\n        stackModel: stateOfPreviousStep\n      });\n    });\n\n    this.state = {\n      stackModel: this.initStackModel()\n    };\n  }\n\n  initStackModel() {\n    const {\n      initialData\n    } = this.props;\n    return initialData.map((value, index) => ({\n      value,\n      visible: true,\n      key: index,\n      offsetFromFront: index\n    }));\n  }\n\n  componentDidUpdate(prevProps) {\n    const {\n      currentStep,\n      reverseToStep,\n      totalStep\n    } = this.props; // Update according to algorithm progression\n\n    if (keyExist(this.props, ['currentStep', 'totalStep', 'instructions'])) {\n      switch (getProgressDirection(currentStep, prevProps.currentStep, totalStep)) {\n        case 'forward':\n          this.saveModelSnapshotAtCurrentStep();\n          this.handleForward();\n          break;\n\n        case 'backward':\n          reverseToStep(currentStep);\n          break;\n        // case 'fastForward':\n        //   console.log('fastForward');\n        //   this.handleFastForward();\n        //   break;\n        // case 'fastBackward':\n        //   console.log('fastBackward');\n        //   this.handleFastBackward();\n        //   break;\n      }\n    }\n  }\n\n  saveModelSnapshotAtCurrentStep() {\n    const {\n      currentStep,\n      saveStepSnapshots\n    } = this.props;\n    const {\n      stackModel\n    } = this.state;\n    if (typeof currentStep === 'number') saveStepSnapshots(stackModel, currentStep);\n  }\n\n  handleForward() {\n    // Treat each action as a transformation function which take a linkedListModel\n    // and return a new one. Consuming multiple actions is merely chaining those\n    // transformations together\n    // linkedListModel ---- action1 ----> linkedListModel1 ---- action2 ----> linkedListMode2 ---- action3 ----> linkedListModel3\n    const {\n      stackModel\n    } = this.state;\n    const {\n      currentStep,\n      instructions\n    } = this.props;\n    const actionsToMakeAtThisStep = instructions[currentStep];\n    if (!actionsToMakeAtThisStep || !actionsToMakeAtThisStep.length) return; // This consume pipeline have many side effect in each step. Each\n    // method handle each action has their own side effect\n\n    const newStackModel = this.consumeMultipleActions(actionsToMakeAtThisStep, stackModel);\n    this.setState({\n      stackModel: newStackModel\n    });\n  }\n\n  consumeMultipleActions(actionList, currentModel, onlyTranformData) {\n    // Treat each action as a transformation function which take a linkedListModel\n    // and return a new one. Consuming multiple actions is merely chaining those\n    // transformations together\n    // linkedListModel ---- action1 ----> linkedListModel1 ---- action2 ----> linkedListMode2 ---- action3 ----> linkedListModel3\n    return actionList.reduce((finalModel, action) => {\n      // the main function of a handler is doing side effect before transform model\n      // a handler must also return a new model\n      // if no handler is specify, just transform model right away\n      const {\n        name,\n        params\n      } = action; //@ts-ignore\n\n      const customHandler = this[name];\n\n      if (typeof customHandler === 'function') {\n        return customHandler(finalModel, params, onlyTranformData);\n      } else {\n        return transformStackModel(finalModel, name, params);\n      }\n    }, currentModel);\n  }\n\n  push(currentModel, params) {\n    const itemOnTop = _last(currentModel.filter(({\n      visible\n    }) => !!visible));\n\n    const newKey = currentModel.length ? _last(currentModel).key + 1 : 0;\n    const stackItemToPush = {\n      value: params[0],\n      visible: true,\n      offsetFromFront: itemOnTop ? itemOnTop.offsetFromFront + 1 : 0,\n      key: newKey,\n      isNew: true\n    };\n    return transformStackModel(currentModel, 'push', [stackItemToPush]);\n  }\n\n  renderBoundary() {\n    const moveToCenterPoint = `M ${STACK_BLOCK_WIDTH / 2} ${STACK_BLOCK_HEIGHT + 10}`;\n    const goUpToTop = `v ${-this.caculateStackHeight() - 20}`;\n    return __jsx(\"path\", {\n      className: \"default-stroke no-fill stroke-1\",\n      d: `${moveToCenterPoint} h ${STACK_BLOCK_WIDTH / 2 + STACK_BOUNDARY_GAP} ${goUpToTop} ${moveToCenterPoint} h ${-STACK_BLOCK_WIDTH / 2 - STACK_BOUNDARY_GAP} ${goUpToTop}`\n    });\n  }\n\n  caculateStackHeight() {\n    const {\n      stackModel\n    } = this.state;\n    const itemCount = stackModel.filter(({\n      visible\n    }) => !!visible).length;\n    return itemCount * (STACK_BLOCK_HEIGHT + STACK_BLOCK_GAP);\n  }\n\n  render() {\n    const {\n      stackModel\n    } = this.state;\n    const listStackItem = stackModel.map(item => __jsx(StackItem, item));\n    return __jsx(React.Fragment, null, __jsx(\"use\", _extends({\n      href: \"#stack\"\n    }, _pick(this.props, ['x', 'y']))), __jsx(\"defs\", null, __jsx(\"g\", {\n      id: \"stack\",\n      className: \"queue__wrapper\"\n    }, listStackItem, this.renderBoundary())));\n  }\n\n}\nexport default withReverseStep(StackDS);","map":null,"metadata":{},"sourceType":"module"}