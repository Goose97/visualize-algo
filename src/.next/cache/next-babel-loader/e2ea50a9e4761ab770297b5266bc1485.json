{"ast":null,"code":"import _pick from \"lodash/pick\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { Component } from 'react';\nimport { HighlightCircle } from 'components';\nimport { classNameHelper } from 'utils';\nimport withExtendClassName from 'hocs/withExtendClassName';\nexport class MemoryBlock extends Component {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"labelText\", void 0);\n\n    this.state = {};\n    this.labelText = React.createRef();\n  }\n\n  componentDidUpdate(prevProps) {\n    const {\n      visible\n    } = this.props;\n\n    if (visible !== prevProps.visible) {\n      visible ? this.show() : this.hide();\n    }\n  }\n\n  hide() {\n    this.setState({\n      isHiding: true\n    });\n    setTimeout(() => {\n      this.setState({\n        isHiding: false\n      });\n    }, 500);\n  }\n\n  show() {\n    this.setState({\n      isShowing: true\n    });\n    setTimeout(() => {\n      this.setState({\n        isShowing: false\n      });\n    }, 500);\n  }\n\n  produceClassName() {\n    const {\n      visible,\n      visited,\n      focus,\n      className,\n      isNew,\n      blur\n    } = this.props;\n    const {\n      isHiding,\n      isShowing\n    } = this.state;\n    return classNameHelper({\n      base: className,\n      disappearing: !!isHiding,\n      appearing: !!(isShowing || isNew),\n      invisible: !visible,\n      visited: !!visited,\n      focus: !!focus,\n      blur: !!blur\n    });\n  }\n\n  renderMemoryBlockContainer() {\n    const {\n      type,\n      x,\n      y,\n      width,\n      height\n    } = this.props;\n\n    switch (type) {\n      case 'rectangle':\n        return __jsx(\"rect\", _extends({}, _pick(this.props, ['x', 'y', 'width', 'height']), {\n          className: \"memory-block__block\"\n        }));\n\n      case 'round':\n        const cx = x + width / 2;\n        const cy = y + height / 2;\n        return __jsx(\"circle\", {\n          cx: cx,\n          cy: cy,\n          r: width / 2,\n          className: \"memory-block__block\"\n        }) // <rect\n        //   {...pick(this.props, ['x', 'y', 'width', 'height'])}\n        //   className='memory-block__block'\n        // ></rect>\n        ;\n    }\n  }\n\n  renderLabelText() {\n    const {\n      label\n    } = this.props;\n    return label && label.length && __jsx(\"g\", null, this.renderBackgroundOverlayForText(), __jsx(\"text\", _extends({}, this.getLabelTextCoordinate(), {\n      dominantBaseline: \"middle\",\n      textAnchor: \"middle\",\n      className: \"memory-block__text italic\",\n      ref: this.labelText\n    }), label.join(' / ')));\n  }\n\n  renderBackgroundOverlayForText() {\n    const textElement = this.labelText.current;\n    if (!textElement) return null;\n    const {\n      width: textWidth,\n      height: textHeight\n    } = textElement.getBoundingClientRect();\n    return __jsx(\"rect\", _extends({}, this.getLabelTextCoordinate(), {\n      transform: `translate(-${textWidth / 2}, -${textHeight / 2})`,\n      width: textWidth,\n      height: textHeight,\n      className: \"fill-background\"\n    }));\n  }\n\n  getLabelTextCoordinate() {\n    const {\n      labelDirection,\n      width,\n      height,\n      x,\n      y\n    } = this.props;\n    const direction = labelDirection || 'top';\n\n    switch (direction) {\n      case 'top':\n        return {\n          x: x + width / 2,\n          y: y - 20\n        };\n\n      case 'bottom':\n        return {\n          x: x + width / 2,\n          y: y + height + 20\n        };\n\n      case 'left':\n        return {\n          x: x - 30,\n          y: y + height / 2\n        };\n\n      case 'right':\n        return {\n          x: x + 20,\n          y: y + height / 2\n        };\n    }\n  }\n\n  render() {\n    const {\n      value,\n      width,\n      height,\n      children,\n      textOffset,\n      circleAround,\n      transform,\n      x,\n      y\n    } = this.props;\n    const xOffsetText = textOffset ? textOffset.x : 0;\n\n    const valueText = __jsx(\"text\", {\n      x: x + (width - xOffsetText) / 2,\n      y: y + height / 2,\n      dominantBaseline: \"middle\",\n      textAnchor: \"middle\",\n      className: \"memory-block__text value-text\"\n    }, value);\n\n    const highlightCircle = circleAround && __jsx(HighlightCircle, {\n      x: x + width / 2,\n      y: y + height / 2,\n      radius: width / 2 + 15\n    });\n\n    return __jsx(\"g\", {\n      className: this.produceClassName(),\n      transform: transform\n    }, this.renderMemoryBlockContainer(), valueText, this.renderLabelText(), children, highlightCircle);\n  }\n\n}\nexport default withExtendClassName('memory-block__wrapper has-transition')(MemoryBlock);","map":null,"metadata":{},"sourceType":"module"}