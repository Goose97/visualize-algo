{"ast":null,"code":"import _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport _parseFloat from \"@babel/runtime-corejs2/core-js/parse-float\";\nimport _Promise from \"@babel/runtime-corejs2/core-js/promise\";\nimport _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _Object$entries from \"@babel/runtime-corejs2/core-js/object/entries\";\nimport _pick from \"lodash/pick\";\nimport BezierEasing from 'bezier-easing';\nimport { GRAPH_NODE_RADIUS } from \"../constants\";\nexport var classNameHelper = function classNameHelper(object) {\n  var baseClassName = object.base || '';\n\n  _Object$entries(object).forEach(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        value = _ref2[1];\n\n    if (key === 'base') return;\n    if (!!value) baseClassName += \" \".concat(key);\n  });\n\n  return baseClassName;\n};\nexport var produceFullState = function produceFullState(stepDescription, stateProperties) {\n  var result = [];\n\n  for (var i = 0; i < stepDescription.length; i++) {\n    var currentState = _pick(stepDescription[i], stateProperties);\n\n    if (i !== 0) currentState = _Object$assign({}, result[i - 1], currentState);\n    result.push(currentState);\n  }\n\n  return result;\n};\nexport function promiseSetState(newState) {\n  var _this = this;\n\n  //@ts-ignore\n  return new _Promise(function (resolve) {\n    return _this.setState(newState, function () {\n      return resolve();\n    });\n  });\n}\nexport var compactObject = function compactObject(object) {\n  for (var property in object) {\n    if (object.hasOwnProperty(property)) {\n      if (object[property] === undefined || object[property] === null) delete object[property];\n    }\n  }\n\n  return object;\n};\nexport var getProgressDirection = function getProgressDirection(currentStep, previousStep, totalStep, switchingApi) {\n  if (switchingApi) return 'switch';\n  if (previousStep === undefined) return 'forward';\n  if (currentStep === previousStep) return 'stay';\n\n  if (currentStep > previousStep) {\n    if (currentStep - previousStep === 1) return 'forward';else if (currentStep === totalStep) return 'fastForward';\n  } else {\n    if (previousStep - currentStep === 1) return 'backward';else if (currentStep === 0) return 'fastBackward';\n  }\n};\nexport var upcaseFirstLetterAndSplit = function upcaseFirstLetterAndSplit(string) {\n  var regex = /[A-Z]/g;\n  var result = string.replace(regex, function (value) {\n    return \" \".concat(value);\n  });\n  return result[0].toUpperCase() + result.slice(1);\n};\nexport var keyExist = function keyExist(object, keys) {\n  return keys.every(function (key) {\n    return key in object;\n  });\n};\nexport var extractInstructionFromDescription = function extractInstructionFromDescription(description, dsName) {\n  return description.map(function (_ref3) {\n    var actions = _ref3.actions;\n    if (!actions) return [];\n    if (!actions[dsName]) return [];\n    return actions[dsName];\n  });\n};\nexport var caculatePointerPathFromTwoNodeCenter = function caculatePointerPathFromTwoNodeCenter(nodeACenter, nodeBCenter, radius, noArrow) {\n  var angle = caculateAngleOfLine(nodeACenter, nodeBCenter);\n  var contactPointWithA = {\n    x: nodeACenter.x + Math.cos(angle) * radius,\n    y: nodeACenter.y + Math.sin(angle) * radius\n  };\n  var length = caculateLength(nodeACenter, nodeBCenter) - 2 * GRAPH_NODE_RADIUS;\n  var offsetForArrow = noArrow ? 0 : 6;\n  var path = \"M \".concat(contactPointWithA.x, \" \").concat(contactPointWithA.y, \" h \").concat(length - offsetForArrow);\n  var transform = \"rotate(\".concat(angle / Math.PI * 180, \" \").concat(contactPointWithA.x, \" \").concat(contactPointWithA.y, \")\");\n  return {\n    path: path,\n    transform: transform\n  };\n};\n\nvar caculateLength = function caculateLength(pointA, pointB) {\n  return Math.sqrt(Math.pow(pointA.x - pointB.x, 2) + Math.pow(pointA.y - pointB.y, 2));\n};\n\nvar caculateAngleOfLine = function caculateAngleOfLine(start, finish) {\n  var deltaX = finish.x - start.x;\n  var deltaY = finish.y - start.y;\n  var tan = deltaY / deltaX;\n\n  if (finish.x >= start.x) {\n    return Math.atan(tan);\n  } else {\n    return Math.atan(tan) > 0 ? Math.atan(tan) - Math.PI : Math.atan(tan) + Math.PI;\n  }\n};\n\nexport var caculateDistanceToALine = function caculateDistanceToALine(pointA, pointB, pointC) {\n  // Distance from A to BC\n  var ab = caculateLength(pointA, pointB);\n  var bc = caculateLength(pointB, pointC);\n  var ca = caculateLength(pointC, pointA); // Caculate triangle area use Heron's formula\n\n  var s = (ab + bc + ca) / 2;\n  var area = Math.sqrt(s * (s - ab) * (s - bc) * (s - ca));\n  return area * 2 / bc;\n};\nexport var performAnimation = function performAnimation(params) {\n  var duration = params.duration,\n      callback = params.callback,\n      endValue = params.endValue,\n      startValue = params.startValue;\n  var cubicBezierFunction = params.cubicBezierFunction || BezierEasing(0.25, 0.1, 0.25, 1);\n  var originTime = performance.now();\n\n  var updateValueThroughFrame = function updateValueThroughFrame() {\n    window.requestAnimationFrame(function (currentTime) {\n      var timeProgress = (currentTime - originTime) / duration;\n      var animationProgess = timeProgress > 1 ? 1 : cubicBezierFunction(timeProgress);\n      if (animationProgess >= 1) callback(endValue);else {\n        var currentValue = animationProgess * (endValue - startValue) + startValue;\n        callback(currentValue);\n        updateValueThroughFrame();\n      }\n    });\n  };\n\n  updateValueThroughFrame();\n};\nexport var getCanvasScaleFactor = function getCanvasScaleFactor() {\n  try {\n    var canvasContainer = document.querySelector('.canvas-container'); //@ts-ignore\n\n    return _parseFloat((canvasContainer === null || canvasContainer === void 0 ? void 0 : canvasContainer.getAttribute('scale-factor')) || 1);\n  } catch (e) {\n    console.log(e);\n    return 1;\n  }\n};\nexport var AnimationTaskQueue = /*#__PURE__*/function () {\n  function AnimationTaskQueue(initObject) {\n    _classCallCheck(this, AnimationTaskQueue);\n\n    _defineProperty(this, \"taskQueue\", void 0);\n\n    _defineProperty(this, \"isRunning\", void 0);\n\n    _defineProperty(this, \"callback\", void 0);\n\n    _defineProperty(this, \"isAdditive\", void 0);\n\n    _defineProperty(this, \"taskQueueMax\", void 0);\n\n    _defineProperty(this, \"combineTaskCallback\", void 0);\n\n    var callback = initObject.callback,\n        isAdditiveTask = initObject.isAdditiveTask,\n        combineTaskCallback = initObject.combineTaskCallback,\n        taskQueueMax = initObject.taskQueueMax;\n    this.taskQueue = [];\n    this.isRunning = false;\n    this.callback = callback;\n    this.isAdditive = isAdditiveTask;\n    this.combineTaskCallback = combineTaskCallback;\n    this.taskQueueMax = taskQueueMax || 2;\n  }\n\n  _createClass(AnimationTaskQueue, [{\n    key: \"enqueue\",\n    value: function enqueue(task) {\n      this.taskQueue.push(task);\n\n      if (!this.isRunning) {\n        this.isRunning = true;\n        this.dequeue();\n      }\n    } // Drop some tasks if tasks fill up too fast\n    // If task is additive (meaning drop task will alter result), we must combine many task into one\n\n  }, {\n    key: \"dequeue\",\n    value: function dequeue() {\n      var _this2 = this;\n\n      if (this.taskQueue.length > this.taskQueueMax) this.discardTasks();\n      var nextTask = this.taskQueue.shift();\n\n      if (!nextTask) {\n        this.isRunning = false;\n        return;\n      }\n\n      window.requestAnimationFrame(function () {\n        _this2.callback(nextTask);\n\n        _this2.dequeue();\n      });\n    }\n  }, {\n    key: \"discardTasks\",\n    value: function discardTasks() {\n      // if task is additive, must combine them\n      // otherwise just drop them\n      if (this.isAdditive) {\n        var discardTasks = this.taskQueue.splice(0, this.taskQueueMax);\n        var combinedTask = this.combineTaskCallback(discardTasks);\n        this.taskQueue.unshift(combinedTask);\n      } else {\n        this.taskQueue.splice(0, this.taskQueueMax);\n      }\n    }\n  }]);\n\n  return AnimationTaskQueue;\n}();","map":null,"metadata":{},"sourceType":"module"}