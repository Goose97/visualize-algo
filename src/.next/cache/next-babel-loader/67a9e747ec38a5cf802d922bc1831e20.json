{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _Reflect$construct from \"@babel/runtime-corejs2/core-js/reflect/construct\";\nimport _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _Set from \"@babel/runtime-corejs2/core-js/set\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime-corejs2/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime-corejs2/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport _isFunction from \"lodash/isFunction\";\nimport _pick from \"lodash/pick\";\nimport _omit from \"lodash/omit\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(_Reflect$construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from 'react';\nimport produce from 'immer';\nimport { CanvasObserver } from 'components';\nimport withDSCore from 'hocs/withDSCore';\nimport transformLinkedListModel from 'transformers/LinkedList';\nimport HeadPointer from \"./HeadPointer\";\nimport LinkedListHTML from \"./LinkedListHTML\";\nimport LinkedListMemoryBlock from \"./LinkedListMemoryBlock\";\nimport LinkedListPointer from \"./LinkedListPointer\";\nimport { LINKED_LIST_BLOCK_WIDTH } from \"../../constants\";\nexport var LinkedListDS = /*#__PURE__*/function (_Component) {\n  _inherits(LinkedListDS, _Component);\n\n  var _super = _createSuper(LinkedListDS);\n\n  // private initialLinkedListModel: LinkedList.Model;\n  function LinkedListDS(props) {\n    var _this;\n\n    _classCallCheck(this, LinkedListDS);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"wrapperRef\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"randomId\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"injectHTMLIntoCanvas\", function () {\n      var _this$props = _this.props,\n          handleExecuteApi = _this$props.handleExecuteApi,\n          dropdownDisabled = _this$props.dropdownDisabled,\n          model = _this$props.model;\n      setTimeout(function () {\n        LinkedListHTML.renderToView({\n          model: model,\n          wrapperElement: _this.wrapperRef.current,\n          coordinate: _pick(_this.props, ['x', 'y']),\n          apiHandler: function apiHandler(apiName, params) {\n            if (!_isFunction(handleExecuteApi)) return;\n\n            var paramsToInvoke = _this.produceParametersToExecuteApi(apiName, params);\n\n            handleExecuteApi(apiName, paramsToInvoke);\n          },\n          disabled: dropdownDisabled\n        });\n      }, 0);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"produceParametersToExecuteApi\", function (apiName, params) {\n      var model = _this.props.model;\n\n      switch (apiName) {\n        case 'search':\n          {\n            //@ts-ignore\n            var key = params.key,\n                value = params.value;\n            var valueToSearch = value;\n\n            if (valueToSearch == null) {\n              var nodeToSearch = model.find(function (_ref) {\n                var nodeKey = _ref.key;\n                return nodeKey === key;\n              });\n              valueToSearch = nodeToSearch && nodeToSearch.value;\n            }\n\n            return {\n              value: valueToSearch\n            };\n          }\n\n        case 'insert':\n          {\n            //@ts-ignore\n            var _key = params.key,\n                _value = params.value,\n                index = params.index;\n            var indexToInsert = index;\n\n            if (indexToInsert == null) {\n              indexToInsert = model.findIndex(function (_ref2) {\n                var nodeKey = _ref2.key;\n                return nodeKey === _key;\n              });\n            }\n\n            return {\n              index: indexToInsert,\n              value: _value\n            };\n          }\n\n        case 'delete':\n          {\n            //@ts-ignore\n            var _key2 = params.key,\n                _index = params.index;\n            var indexToDelete = _index;\n\n            if (indexToDelete == null) {\n              indexToDelete = model.findIndex(function (_ref3) {\n                var nodeKey = _ref3.key;\n                return nodeKey === _key2;\n              });\n            }\n\n            return {\n              index: indexToDelete\n            };\n          }\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"visit\", function (currentModel, params) {\n      // Nếu node không phải node đầu tiên thì ta sẽ thực thi hàm followLinkToNode\n      // Hàm này chịu trách nhiệm thực hiện animation, sau khi animation hoàn thành\n      // callback handleAfterVisitAnimationFinish sẽ được thực hiện\n      // Nếu node là node đầu tiên thì ta không có animation để thực hiện, focus luôn vào node\n      var _params = _slicedToArray(params, 2),\n          nodeKeyToStart = _params[0],\n          nodeKeyToVisit = _params[1];\n\n      if (nodeKeyToVisit !== 0) {\n        _this.followLinkToNode(nodeKeyToVisit);\n\n        setTimeout(function () {\n          _this.handleAfterVisitAnimationFinish(nodeKeyToStart, nodeKeyToVisit);\n        }, 400);\n        return currentModel;\n      } else {\n        return transformLinkedListModel(currentModel, 'focus', [nodeKeyToVisit, false]);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"followLinkToNode\", function (nodeIndex) {\n      var model = _this.props.model;\n\n      _this.setState({\n        nodeAboutToVisit: model[nodeIndex].key\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleAfterVisitAnimationFinish\", function (startNodeKey, destinationNodeKey) {\n      // mark the node who hold the link as visited\n      var _this$props2 = _this.props,\n          model = _this$props2.model,\n          updateModel = _this$props2.updateModel;\n      var newLinkedListModel = model;\n\n      if (typeof startNodeKey === 'number') {\n        newLinkedListModel = transformLinkedListModel(newLinkedListModel, 'visited', [startNodeKey]);\n      } // mark the node on the other end as current focus\n\n\n      newLinkedListModel = transformLinkedListModel(newLinkedListModel, 'focus', [destinationNodeKey, false]);\n\n      _this.setState({\n        nodeAboutToVisit: undefined\n      });\n\n      updateModel(newLinkedListModel);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"insert\", function (currentModel, params, onlyTranformData) {\n      var _params2 = _slicedToArray(params, 3),\n          value = _params2[0],\n          prevNodeKey = _params2[1],\n          newNodeKey = _params2[2];\n\n      var newNode = _this.produceNewNodeToInsert({\n        currentModel: currentModel,\n        value: value,\n        prevNodeKey: prevNodeKey,\n        newNodeKey: newNodeKey\n      });\n\n      var newLinkedListModel = transformLinkedListModel(currentModel, 'insert', [newNode, prevNodeKey]);\n\n      if (!onlyTranformData) {\n        // We have to turn off visibility for the new node\n        // For the purpose of doing animation\n        newLinkedListModel = produce(newLinkedListModel, function (draft) {\n          var newBlock = draft.find(function (_ref4) {\n            var key = _ref4.key;\n            return key === newNodeKey;\n          });\n          newBlock.visible = false;\n        });\n\n        _this.addOrRemoveNodeAboutToAppear(newNodeKey);\n\n        setTimeout(function () {\n          _this.toggleNodeVisibility(newNodeKey);\n\n          _this.addOrRemoveNodeAboutToAppear(newNodeKey);\n        }, 800);\n      }\n\n      return newLinkedListModel;\n    });\n\n    _this.state = {\n      nodeAboutToAppear: new _Set([])\n    };\n    _this.wrapperRef = React.createRef();\n    _this.randomId = Math.round(Math.random() * 100000); // Register custom transformer\n\n    props.registerCustomTransformer({\n      visit: _this.visit,\n      insert: _this.insert\n    }); // Register HTML injector\n\n    props.registerHTMLInjector(_this.injectHTMLIntoCanvas);\n    return _this;\n  }\n\n  _createClass(LinkedListDS, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var interactive = this.props.interactive;\n\n      if (interactive) {\n        this.injectHTMLIntoCanvas();\n        CanvasObserver.register(this.injectHTMLIntoCanvas);\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      this.checkIfHTMLNeedToRerender(prevProps.currentStep);\n    }\n  }, {\n    key: \"checkIfHTMLNeedToRerender\",\n    value: function checkIfHTMLNeedToRerender(previousStep) {\n      var instructions = this.props.instructions;\n      var actionMadeAtPreviousStep = instructions[previousStep] || [];\n      if (!actionMadeAtPreviousStep || !actionMadeAtPreviousStep.length) return; // Check if in those action we made, if exists any action that affect the position layout\n      // of the svg. Then we must rerender the html\n\n      if (actionMadeAtPreviousStep.some(function (_ref5) {\n        var name = _ref5.name;\n        return ['insert', 'remove'].includes(name);\n      })) {\n        this.injectHTMLIntoCanvas();\n      }\n    }\n  }, {\n    key: \"getCurrentFocusNode\",\n    value: function getCurrentFocusNode() {\n      var model = this.props.model;\n      var focusNode = model.find(function (_ref6) {\n        var focus = _ref6.focus;\n        return !!focus;\n      });\n      return focusNode ? focusNode.key : null;\n    }\n  }, {\n    key: \"produceNewNodeToInsert\",\n    value: function produceNewNodeToInsert(params) {\n      var value = params.value,\n          prevNodeKey = params.prevNodeKey,\n          newNodeKey = params.newNodeKey,\n          currentModel = params.currentModel;\n      var previousNodeIndex = currentModel.findIndex(function (_ref7) {\n        var key = _ref7.key;\n        return key === prevNodeKey;\n      });\n      return _objectSpread({}, LinkedListDS.caculateBlockCoordinate(previousNodeIndex + 1), {\n        value: value,\n        index: previousNodeIndex + 1,\n        key: newNodeKey,\n        visible: true\n      });\n    } // nodeAboutToAppear is a list of node which already in the state\n    // but about to get animated to appear\n\n  }, {\n    key: \"addOrRemoveNodeAboutToAppear\",\n    value: function addOrRemoveNodeAboutToAppear(nodeKey) {\n      var nodeAboutToAppear = this.state.nodeAboutToAppear;\n\n      if (nodeAboutToAppear.has(nodeKey)) {\n        var cloneState = new _Set(nodeAboutToAppear);\n        cloneState[\"delete\"](nodeKey);\n        this.setState({\n          nodeAboutToAppear: cloneState\n        });\n      } else {\n        this.setState({\n          nodeAboutToAppear: nodeAboutToAppear.add(nodeKey)\n        });\n      }\n    }\n  }, {\n    key: \"toggleNodeVisibility\",\n    value: function toggleNodeVisibility(nodeKey) {\n      var _this$props3 = this.props,\n          model = _this$props3.model,\n          updateModel = _this$props3.updateModel;\n      var newPosition = produce(model, function (draft) {\n        var targetBlock = draft.find(function (_ref8) {\n          var key = _ref8.key;\n          return key === nodeKey;\n        });\n        var oldVisibleState = targetBlock.visible;\n        targetBlock.visible = !oldVisibleState;\n      });\n      updateModel(newPosition);\n    }\n  }, {\n    key: \"renderPointerLinkForMemoryBlock\",\n    value: function renderPointerLinkForMemoryBlock(nodeIndex) {\n      var nodeAboutToAppear = this.state.nodeAboutToAppear;\n      var model = this.props.model;\n      var _model$nodeIndex = model[nodeIndex],\n          key = _model$nodeIndex.key,\n          pointer = _model$nodeIndex.pointer,\n          visible = _model$nodeIndex.visible,\n          visited = _model$nodeIndex.visited;\n      var pointToNode = this.findNodeByKey(pointer);\n      return __jsx(LinkedListPointer, {\n        nodeAboutToAppear: nodeAboutToAppear,\n        key: key,\n        from: key,\n        to: pointer,\n        linkedListModel: model,\n        following: this.isLinkNeedToBeFollowed(nodeIndex),\n        visited: visited,\n        visible: visible && (pointToNode === null || pointToNode === void 0 ? void 0 : pointToNode.visible)\n      });\n    }\n  }, {\n    key: \"findNodeByKey\",\n    value: function findNodeByKey(key) {\n      var model = this.props.model;\n      var nodeWithKey = model.find(function (_ref9) {\n        var nodeKey = _ref9.key;\n        return key === nodeKey;\n      });\n      return nodeWithKey || null;\n    } // Start block is the block which hold the link and point to another block\n\n  }, {\n    key: \"isLinkNeedToBeFollowed\",\n    value: function isLinkNeedToBeFollowed(startBlockIndex) {\n      var nodeAboutToVisit = this.state.nodeAboutToVisit;\n      var nextVisibleBlock = this.findNextBlock(startBlockIndex);\n      return nextVisibleBlock && nextVisibleBlock.key === nodeAboutToVisit;\n    } // Find block which is still visible or in about to appear state\n\n  }, {\n    key: \"findNextBlock\",\n    value: function findNextBlock(index) {\n      var getIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var nodeAboutToAppear = this.state.nodeAboutToAppear;\n      var model = this.props.model;\n\n      for (var i = index + 1; i < model.length; i++) {\n        var _model$i = model[i],\n            visible = _model$i.visible,\n            key = _model$i.key;\n\n        if (visible || nodeAboutToAppear.has(key)) {\n          return getIndex ? i : model[i];\n        }\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props4 = this.props,\n          headArrowVisible = _this$props4.headArrowVisible,\n          model = _this$props4.model;\n      var listMemoryBlock = model.map(function (linkedListNode) {\n        return __jsx(LinkedListMemoryBlock, _extends({}, _omit(linkedListNode, ['key']), {\n          key: linkedListNode.key\n        }));\n      });\n      var listPointerLink = model.map(function (_, index) {\n        return _this2.renderPointerLinkForMemoryBlock(index);\n      });\n      return __jsx(React.Fragment, null, __jsx(\"use\", _extends({\n        href: \"#linked-list-\".concat(this.randomId)\n      }, _pick(this.props, ['x', 'y']), {\n        ref: this.wrapperRef\n      })), __jsx(\"defs\", null, __jsx(\"g\", {\n        id: \"linked-list-\".concat(this.randomId)\n      }, headArrowVisible && __jsx(HeadPointer, {\n        headBlock: this.findNextBlock(-1)\n      }), listMemoryBlock, listPointerLink)));\n    }\n  }], [{\n    key: \"initLinkedListModel\",\n    value: function initLinkedListModel(props) {\n      var getInitialData = function getInitialData() {\n        var initialData = props.initialData,\n            data = props.data,\n            controlled = props.controlled;\n        var result;\n        if (controlled) result = data;else result = initialData;\n        return result || [];\n      };\n\n      var data = getInitialData();\n      return data.map(function (value, index) {\n        return _objectSpread({}, LinkedListDS.caculateBlockCoordinate(index), {\n          value: value,\n          index: index,\n          visible: true,\n          visited: false,\n          key: index,\n          focus: false,\n          pointer: index === data.length - 1 ? null : index + 1\n        });\n      });\n    }\n  }, {\n    key: \"caculateBlockCoordinate\",\n    value: function caculateBlockCoordinate(nodeIndex) {\n      return {\n        x: nodeIndex * (2 * LINKED_LIST_BLOCK_WIDTH),\n        y: 0\n      };\n    }\n  }]);\n\n  return LinkedListDS;\n}(Component);\nexport default withDSCore({\n  initModel: LinkedListDS.initLinkedListModel,\n  dataTransformer: transformLinkedListModel\n})(LinkedListDS);","map":null,"metadata":{},"sourceType":"module"}