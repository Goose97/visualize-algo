{"ast":null,"code":"import _isFunction from \"lodash/isFunction\";\nimport _pick from \"lodash/pick\";\nimport _omit from \"lodash/omit\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { Component } from 'react';\nimport produce from 'immer';\nimport { CanvasObserver } from 'components';\nimport withDSCore from 'hocs/withDSCore';\nimport transformLinkedListModel from 'transformers/LinkedList';\nimport HeadPointer from \"./HeadPointer\";\nimport LinkedListHTML from \"./LinkedListHTML\";\nimport LinkedListMemoryBlock from \"./LinkedListMemoryBlock\";\nimport LinkedListPointer from \"./LinkedListPointer\";\nimport { LINKED_LIST_BLOCK_WIDTH } from \"../../constants\";\nexport class LinkedListDS extends Component {\n  // private initialLinkedListModel: LinkedList.Model;\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"wrapperRef\", void 0);\n\n    _defineProperty(this, \"randomId\", void 0);\n\n    _defineProperty(this, \"injectHTMLIntoCanvas\", () => {\n      const {\n        handleExecuteApi,\n        dropdownDisabled,\n        model\n      } = this.props;\n      setTimeout(() => {\n        LinkedListHTML.renderToView({\n          model,\n          wrapperElement: this.wrapperRef.current,\n          coordinate: _pick(this.props, ['x', 'y']),\n          apiHandler: (apiName, params) => {\n            if (!_isFunction(handleExecuteApi)) return;\n            const paramsToInvoke = this.produceParametersToExecuteApi(apiName, params);\n            handleExecuteApi(apiName, paramsToInvoke);\n          },\n          disabled: dropdownDisabled\n        });\n      }, 0);\n    });\n\n    _defineProperty(this, \"produceParametersToExecuteApi\", (apiName, params) => {\n      const {\n        model\n      } = this.props;\n\n      switch (apiName) {\n        case 'search':\n          {\n            //@ts-ignore\n            const {\n              key,\n              value\n            } = params;\n            let valueToSearch = value;\n\n            if (valueToSearch == null) {\n              const nodeToSearch = model.find(({\n                key: nodeKey\n              }) => nodeKey === key);\n              valueToSearch = nodeToSearch && nodeToSearch.value;\n            }\n\n            return {\n              value: valueToSearch\n            };\n          }\n\n        case 'insert':\n          {\n            //@ts-ignore\n            const {\n              key,\n              value,\n              index\n            } = params;\n            let indexToInsert = index;\n\n            if (indexToInsert == null) {\n              indexToInsert = model.findIndex(({\n                key: nodeKey\n              }) => nodeKey === key);\n            }\n\n            return {\n              index: indexToInsert,\n              value\n            };\n          }\n\n        case 'delete':\n          {\n            //@ts-ignore\n            const {\n              key,\n              index\n            } = params;\n            let indexToDelete = index;\n\n            if (indexToDelete == null) {\n              indexToDelete = model.findIndex(({\n                key: nodeKey\n              }) => nodeKey === key);\n            }\n\n            return {\n              index: indexToDelete\n            };\n          }\n      }\n    });\n\n    _defineProperty(this, \"visit\", (currentModel, params) => {\n      // Nếu node không phải node đầu tiên thì ta sẽ thực thi hàm followLinkToNode\n      // Hàm này chịu trách nhiệm thực hiện animation, sau khi animation hoàn thành\n      // callback handleAfterVisitAnimationFinish sẽ được thực hiện\n      // Nếu node là node đầu tiên thì ta không có animation để thực hiện, focus luôn vào node\n      const [nodeKeyToStart, nodeKeyToVisit] = params;\n\n      if (nodeKeyToVisit !== 0) {\n        this.followLinkToNode(nodeKeyToVisit);\n        setTimeout(() => {\n          this.handleAfterVisitAnimationFinish(nodeKeyToStart, nodeKeyToVisit);\n        }, 400);\n        return currentModel;\n      } else {\n        return transformLinkedListModel(currentModel, 'focus', [nodeKeyToVisit, false]);\n      }\n    });\n\n    _defineProperty(this, \"followLinkToNode\", nodeIndex => {\n      const {\n        model\n      } = this.props;\n      this.setState({\n        nodeAboutToVisit: model[nodeIndex].key\n      });\n    });\n\n    _defineProperty(this, \"handleAfterVisitAnimationFinish\", (startNodeKey, destinationNodeKey) => {\n      // mark the node who hold the link as visited\n      const {\n        model,\n        updateModel\n      } = this.props;\n      let newLinkedListModel = model;\n\n      if (typeof startNodeKey === 'number') {\n        newLinkedListModel = transformLinkedListModel(newLinkedListModel, 'visited', [startNodeKey]);\n      } // mark the node on the other end as current focus\n\n\n      newLinkedListModel = transformLinkedListModel(newLinkedListModel, 'focus', [destinationNodeKey, false]);\n      this.setState({\n        nodeAboutToVisit: undefined\n      });\n      updateModel(newLinkedListModel);\n    });\n\n    _defineProperty(this, \"insert\", (currentModel, params, onlyTranformData) => {\n      const [value, prevNodeKey, newNodeKey] = params;\n      const newNode = this.produceNewNodeToInsert({\n        currentModel,\n        value,\n        prevNodeKey,\n        newNodeKey\n      });\n      let newLinkedListModel = transformLinkedListModel(currentModel, 'insert', [newNode, prevNodeKey]);\n\n      if (!onlyTranformData) {\n        // We have to turn off visibility for the new node\n        // For the purpose of doing animation\n        newLinkedListModel = produce(newLinkedListModel, draft => {\n          let newBlock = draft.find(({\n            key\n          }) => key === newNodeKey);\n          newBlock.visible = false;\n        });\n        this.addOrRemoveNodeAboutToAppear(newNodeKey);\n        setTimeout(() => {\n          this.toggleNodeVisibility(newNodeKey);\n          this.addOrRemoveNodeAboutToAppear(newNodeKey);\n        }, 800);\n      }\n\n      return newLinkedListModel;\n    });\n\n    this.state = {\n      nodeAboutToAppear: new Set([])\n    };\n    this.wrapperRef = React.createRef();\n    this.randomId = Math.round(Math.random() * 100000); // Register custom transformer\n\n    props.registerCustomTransformer({\n      visit: this.visit,\n      insert: this.insert\n    }); // Register HTML injector\n\n    props.registerHTMLInjector(this.injectHTMLIntoCanvas);\n  }\n\n  static initLinkedListModel(props) {\n    const getInitialData = () => {\n      const {\n        initialData,\n        data,\n        controlled\n      } = props;\n      let result;\n      if (controlled) result = data;else result = initialData;\n      return result || [];\n    };\n\n    const data = getInitialData();\n    return data.map((value, index) => _objectSpread({}, LinkedListDS.caculateBlockCoordinate(index), {\n      value,\n      index,\n      visible: true,\n      visited: false,\n      key: index,\n      focus: false,\n      pointer: index === data.length - 1 ? null : index + 1\n    }));\n  }\n\n  componentDidMount() {\n    const {\n      interactive\n    } = this.props;\n\n    if (interactive) {\n      this.injectHTMLIntoCanvas();\n      CanvasObserver.register(this.injectHTMLIntoCanvas);\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    this.checkIfHTMLNeedToRerender(prevProps.currentStep);\n  }\n\n  checkIfHTMLNeedToRerender(previousStep) {\n    const {\n      instructions\n    } = this.props;\n    const actionMadeAtPreviousStep = instructions[previousStep] || [];\n    if (!actionMadeAtPreviousStep || !actionMadeAtPreviousStep.length) return; // Check if in those action we made, if exists any action that affect the position layout\n    // of the svg. Then we must rerender the html\n\n    if (actionMadeAtPreviousStep.some(({\n      name\n    }) => ['insert', 'remove'].includes(name))) {\n      this.injectHTMLIntoCanvas();\n    }\n  }\n\n  getCurrentFocusNode() {\n    const {\n      model\n    } = this.props;\n    const focusNode = model.find(({\n      focus\n    }) => !!focus);\n    return focusNode ? focusNode.key : null;\n  }\n\n  static caculateBlockCoordinate(nodeIndex) {\n    return {\n      x: nodeIndex * (2 * LINKED_LIST_BLOCK_WIDTH),\n      y: 0\n    };\n  }\n\n  produceNewNodeToInsert(params) {\n    const {\n      value,\n      prevNodeKey,\n      newNodeKey,\n      currentModel\n    } = params;\n    const previousNodeIndex = currentModel.findIndex(({\n      key\n    }) => key === prevNodeKey);\n    return _objectSpread({}, LinkedListDS.caculateBlockCoordinate(previousNodeIndex + 1), {\n      value,\n      index: previousNodeIndex + 1,\n      key: newNodeKey,\n      visible: true\n    });\n  } // nodeAboutToAppear is a list of node which already in the state\n  // but about to get animated to appear\n\n\n  addOrRemoveNodeAboutToAppear(nodeKey) {\n    const {\n      nodeAboutToAppear\n    } = this.state;\n\n    if (nodeAboutToAppear.has(nodeKey)) {\n      const cloneState = new Set(nodeAboutToAppear);\n      cloneState.delete(nodeKey);\n      this.setState({\n        nodeAboutToAppear: cloneState\n      });\n    } else {\n      this.setState({\n        nodeAboutToAppear: nodeAboutToAppear.add(nodeKey)\n      });\n    }\n  }\n\n  toggleNodeVisibility(nodeKey) {\n    const {\n      model,\n      updateModel\n    } = this.props;\n    const newPosition = produce(model, draft => {\n      const targetBlock = draft.find(({\n        key\n      }) => key === nodeKey);\n      const oldVisibleState = targetBlock.visible;\n      targetBlock.visible = !oldVisibleState;\n    });\n    updateModel(newPosition);\n  }\n\n  renderPointerLinkForMemoryBlock(nodeIndex) {\n    const {\n      nodeAboutToAppear\n    } = this.state;\n    const {\n      model\n    } = this.props;\n    const {\n      key,\n      pointer,\n      visible,\n      visited\n    } = model[nodeIndex];\n    const pointToNode = this.findNodeByKey(pointer);\n    return __jsx(LinkedListPointer, {\n      nodeAboutToAppear: nodeAboutToAppear,\n      key: key,\n      from: key,\n      to: pointer,\n      linkedListModel: model,\n      following: this.isLinkNeedToBeFollowed(nodeIndex),\n      visited: visited,\n      visible: visible && (pointToNode === null || pointToNode === void 0 ? void 0 : pointToNode.visible)\n    });\n  }\n\n  findNodeByKey(key) {\n    const {\n      model\n    } = this.props;\n    const nodeWithKey = model.find(({\n      key: nodeKey\n    }) => key === nodeKey);\n    return nodeWithKey || null;\n  } // Start block is the block which hold the link and point to another block\n\n\n  isLinkNeedToBeFollowed(startBlockIndex) {\n    const {\n      nodeAboutToVisit\n    } = this.state;\n    const nextVisibleBlock = this.findNextBlock(startBlockIndex);\n    return nextVisibleBlock && nextVisibleBlock.key === nodeAboutToVisit;\n  } // Find block which is still visible or in about to appear state\n\n\n  findNextBlock(index, getIndex = false) {\n    const {\n      nodeAboutToAppear\n    } = this.state;\n    const {\n      model\n    } = this.props;\n\n    for (let i = index + 1; i < model.length; i++) {\n      const {\n        visible,\n        key\n      } = model[i];\n\n      if (visible || nodeAboutToAppear.has(key)) {\n        return getIndex ? i : model[i];\n      }\n    }\n  }\n\n  render() {\n    const {\n      headArrowVisible,\n      model\n    } = this.props;\n    const listMemoryBlock = model.map(linkedListNode => __jsx(LinkedListMemoryBlock, _extends({}, _omit(linkedListNode, ['key']), {\n      key: linkedListNode.key\n    })));\n    const listPointerLink = model.map((_, index) => this.renderPointerLinkForMemoryBlock(index));\n    return __jsx(React.Fragment, null, __jsx(\"use\", _extends({\n      href: `#linked-list-${this.randomId}`\n    }, _pick(this.props, ['x', 'y']), {\n      ref: this.wrapperRef\n    })), __jsx(\"defs\", null, __jsx(\"g\", {\n      id: `linked-list-${this.randomId}`\n    }, headArrowVisible && __jsx(HeadPointer, {\n      headBlock: this.findNextBlock(-1)\n    }), listMemoryBlock, listPointerLink)));\n  }\n\n}\nexport default withDSCore({\n  initModel: LinkedListDS.initLinkedListModel,\n  dataTransformer: transformLinkedListModel\n})(LinkedListDS);","map":null,"metadata":{},"sourceType":"module"}