{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _Reflect$construct from \"@babel/runtime-corejs2/core-js/reflect/construct\";\nimport _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime-corejs2/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _pick from \"lodash/pick\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(_Reflect$construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from 'react';\nimport { PointerLink } from 'components';\nimport { LINKED_LIST_BLOCK_WIDTH, LINKED_LIST_BLOCK_HEIGHT, LINKED_LIST_CORNER_RADIUS } from \"../../constants\";\nvar OFFSET_FOR_ARROW = 7;\n\nvar LinkedListPointer = /*#__PURE__*/function (_Component) {\n  _inherits(LinkedListPointer, _Component);\n\n  var _super = _createSuper(LinkedListPointer);\n\n  function LinkedListPointer(props) {\n    _classCallCheck(this, LinkedListPointer);\n\n    return _super.call(this, props);\n  }\n\n  _createClass(LinkedListPointer, [{\n    key: \"caculatePathOfPointer\",\n    value: function caculatePathOfPointer() {\n      var _this$props = this.props,\n          linkedListModel = _this$props.linkedListModel,\n          nodeAboutToAppear = _this$props.nodeAboutToAppear,\n          from = _this$props.from,\n          to = _this$props.to;\n\n      var _ref = linkedListModel.find(function (_ref2) {\n        var key = _ref2.key;\n        return key === from;\n      }),\n          x = _ref.x,\n          y = _ref.y,\n          visible = _ref.visible;\n\n      if (typeof to !== 'number' || !visible) return null;\n\n      var _ref3 = linkedListModel.find(function (_ref4) {\n        var key = _ref4.key;\n        return key === to;\n      }),\n          x1 = _ref3.x,\n          y1 = _ref3.y;\n\n      var indexDistance = this.fromAndToIndexDistance();\n      var startFromTailOfFromNode = {\n        x: x + LINKED_LIST_BLOCK_WIDTH - 10,\n        y: y + LINKED_LIST_BLOCK_HEIGHT / 2\n      };\n      var startFromHeadOfFromNode = {\n        x: x,\n        y: y + LINKED_LIST_BLOCK_HEIGHT / 2\n      }; // One node ahead\n\n      if (indexDistance === 1) {\n        var start = _objectSpread({}, startFromTailOfFromNode);\n\n        var finish;\n\n        if (nodeAboutToAppear.has(from)) {\n          finish = _objectSpread({}, start);\n        } else {\n          finish = {\n            x: x1,\n            y: y1 + LINKED_LIST_BLOCK_HEIGHT / 2\n          };\n        }\n\n        return \"M \".concat(start.x, \" \").concat(start.y, \" L \").concat(finish.x - OFFSET_FOR_ARROW, \" \").concat(finish.y);\n      } // One node behind\n\n\n      if (indexDistance === -1) {\n        var _start = _objectSpread({}, startFromHeadOfFromNode);\n\n        var _finish;\n\n        if (nodeAboutToAppear.has(from)) {\n          _finish = _objectSpread({}, _start);\n        } else {\n          _finish = {\n            x: x1 + LINKED_LIST_BLOCK_WIDTH,\n            y: y1 + LINKED_LIST_BLOCK_HEIGHT / 2\n          };\n        }\n\n        return \"M \".concat(_start.x, \" \").concat(_start.y, \" L \").concat(_finish.x + OFFSET_FOR_ARROW, \" \").concat(_finish.y);\n      } // Many node behind\n\n\n      if (indexDistance < -1) {\n        var _start2 = _objectSpread({}, startFromTailOfFromNode);\n\n        var _finish2;\n\n        if (nodeAboutToAppear.has(from)) {\n          _finish2 = _objectSpread({}, _start2);\n        } else {\n          _finish2 = {\n            x: x1 + LINKED_LIST_BLOCK_WIDTH / 2,\n            y: y1 + LINKED_LIST_BLOCK_HEIGHT\n          };\n        }\n\n        return \"M \".concat(_start2.x, \" \").concat(_start2.y, \" h 40 \").concat(this.caculateRoundCornerPath(2), \" v 92 \").concat(this.caculateRoundCornerPath(3), \" H \").concat(_finish2.x + LINKED_LIST_CORNER_RADIUS, \" \").concat(this.caculateRoundCornerPath(4), \" V \").concat(_finish2.y + OFFSET_FOR_ARROW);\n      }\n    } // 1 ------ 2\n    // ----------\n    // ----------\n    // 4 ------ 3\n\n  }, {\n    key: \"caculateRoundCornerPath\",\n    value: function caculateRoundCornerPath(cornerNumber) {\n      switch (cornerNumber) {\n        case 1:\n          return \"a \".concat(LINKED_LIST_CORNER_RADIUS, \" \").concat(LINKED_LIST_CORNER_RADIUS, \" 135 0 1 \").concat(LINKED_LIST_CORNER_RADIUS, \" \").concat(-LINKED_LIST_CORNER_RADIUS);\n\n        case 2:\n          return \"a \".concat(LINKED_LIST_CORNER_RADIUS, \" \").concat(LINKED_LIST_CORNER_RADIUS, \" 135 0 1 \").concat(LINKED_LIST_CORNER_RADIUS, \" \").concat(LINKED_LIST_CORNER_RADIUS);\n\n        case 3:\n          return \"a \".concat(LINKED_LIST_CORNER_RADIUS, \" \").concat(LINKED_LIST_CORNER_RADIUS, \" -135 0 1 \").concat(-LINKED_LIST_CORNER_RADIUS, \" \").concat(LINKED_LIST_CORNER_RADIUS);\n\n        case 4:\n          return \"a \".concat(LINKED_LIST_CORNER_RADIUS, \" \").concat(LINKED_LIST_CORNER_RADIUS, \" -135 0 1 \").concat(-LINKED_LIST_CORNER_RADIUS, \" \").concat(-LINKED_LIST_CORNER_RADIUS);\n      }\n    } // We ignore the node which is not visible anymore\n\n  }, {\n    key: \"fromAndToIndexDistance\",\n    value: function fromAndToIndexDistance() {\n      var _this$props2 = this.props,\n          from = _this$props2.from,\n          to = _this$props2.to,\n          linkedListModel = _this$props2.linkedListModel;\n      var fromNode = linkedListModel.findIndex(function (_ref5) {\n        var key = _ref5.key;\n        return key === from;\n      });\n      var toNode = linkedListModel.findIndex(function (_ref6) {\n        var key = _ref6.key;\n        return key === to;\n      });\n      var nodeInBetween;\n      if (fromNode < toNode) nodeInBetween = linkedListModel.slice(fromNode + 1, toNode);else nodeInBetween = linkedListModel.slice(toNode + 1, fromNode);\n      return (nodeInBetween.filter(function (_ref7) {\n        var visible = _ref7.visible;\n        return visible;\n      }).length + 1) * (fromNode < toNode ? 1 : -1);\n    }\n  }, {\n    key: \"getArrowDirection\",\n    value: function getArrowDirection() {\n      var distance = this.fromAndToIndexDistance();\n      if (distance === 1) return 'right';\n      if (distance === -1) return 'left';\n      if (distance > 1) return 'down';\n      if (distance < -1) return 'up';\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var path = this.caculatePathOfPointer();\n\n      var propsToPass = _pick(this.props, ['following', 'visited', 'visible']);\n\n      return path ? __jsx(PointerLink, _extends({}, propsToPass, {\n        path: path,\n        arrowDirection: this.getArrowDirection()\n      })) : null;\n    }\n  }]);\n\n  return LinkedListPointer;\n}(Component);\n\nexport default LinkedListPointer;","map":null,"metadata":{},"sourceType":"module"}