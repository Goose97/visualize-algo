{"ast":null,"code":"import _Reflect$construct from \"@babel/runtime-corejs2/core-js/reflect/construct\";\nimport _toConsumableArray from \"@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime-corejs2/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _isEqual from \"lodash/isEqual\";\nvar __jsx = React.createElement;\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(_Reflect$construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from 'react';\nimport { produce } from 'immer';\nimport { MemoryBlock, LinkedListDS, PointerLink } from 'components';\nimport { caculateKeyHash } from \"./helper\";\nimport { HASH_TABLE_UNIVERSAL_KEY_SIZE, ARRAY_BLOCK_WIDTH, ARRAY_BLOCK_HEIGHT, HASH_TABLE_ARRAY_X } from \"../../constants\";\nexport var MemoryArray = /*#__PURE__*/function (_Component) {\n  _inherits(MemoryArray, _Component);\n\n  var _super = _createSuper(MemoryArray);\n\n  function MemoryArray(props) {\n    var _this;\n\n    _classCallCheck(this, MemoryArray);\n\n    _this = _super.call(this, props);\n    _this.state = {\n      linkedListInstructionAndStep: {}\n    };\n    return _this;\n  }\n\n  _createClass(MemoryArray, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var keyAboutToBeDeleted = this.props.keyAboutToBeDeleted;\n\n      if (!_isEqual(keyAboutToBeDeleted, prevProps.keyAboutToBeDeleted)) {\n        this.checkKeyToDelete(prevProps.keyAboutToBeDeleted, keyAboutToBeDeleted);\n      }\n    }\n  }, {\n    key: \"checkKeyToDelete\",\n    value: function checkKeyToDelete(prevKeyToDelete, currentKeyToDelete) {\n      var _this2 = this;\n\n      var linkedListInstructionAndStep = this.state.linkedListInstructionAndStep;\n      var keyToDelete = currentKeyToDelete.find(function (key) {\n        return !prevKeyToDelete.includes(key);\n      });\n\n      if (keyToDelete !== undefined) {\n        var hashValue = caculateKeyHash(keyToDelete, HASH_TABLE_UNIVERSAL_KEY_SIZE);\n        var newState = produce(linkedListInstructionAndStep, function (draft) {\n          var oldInstructions = draft[hashValue] && draft[hashValue].instructions || [];\n          var newInstructions = [].concat(_toConsumableArray(oldInstructions), [[{\n            name: 'removeByValue',\n            params: [_this2.getValueOfKey(keyToDelete)]\n          }]]);\n          var oldCurrentStep = draft[hashValue] && draft[hashValue].currentStep;\n          var newCurrentStep = oldCurrentStep !== undefined ? oldCurrentStep + 1 : 0;\n          draft[hashValue] = {\n            instructions: newInstructions,\n            currentStep: newCurrentStep\n          };\n        });\n        this.setState({\n          linkedListInstructionAndStep: newState\n        });\n      }\n    }\n  }, {\n    key: \"getValueOfKey\",\n    value: function getValueOfKey(keyToFind) {\n      var hashTableModel = this.props.hashTableModel;\n      return hashTableModel.keys.find(function (_ref) {\n        var key = _ref.key;\n        return key === keyToFind;\n      }).value;\n    }\n  }, {\n    key: \"renderListMemoryBlock\",\n    value: function renderListMemoryBlock() {\n      var _this3 = this;\n\n      var collisionResolution = this.props.collisionResolution;\n      return __jsx(\"g\", {\n        className: \"hash-table__memory-blocks\"\n      }, Array(HASH_TABLE_UNIVERSAL_KEY_SIZE).fill(0).map(function (_, index) {\n        var blur = _this3.shouldThisAddressBlur(index);\n\n        return __jsx(\"g\", {\n          className: \"hash-table__memory-block\".concat(blur ? ' blur' : ''),\n          key: index\n        }, __jsx(MemoryBlock, {\n          width: ARRAY_BLOCK_WIDTH,\n          height: ARRAY_BLOCK_HEIGHT,\n          x: HASH_TABLE_ARRAY_X,\n          y: index * ARRAY_BLOCK_HEIGHT,\n          value: collisionResolution === 'linearProbe' ? _this3.getValueAtAddress(index) : null,\n          visible: true,\n          type: \"rectangle\",\n          labelDirection: \"left\",\n          label: [index.toString()]\n        }), collisionResolution === 'chaining' && _this3.renderLinkedListAtAddress(index));\n      }));\n    }\n  }, {\n    key: \"getValueAtAddress\",\n    value: function getValueAtAddress(address) {\n      var _hashTableModel$memor;\n\n      var hashTableModel = this.props.hashTableModel;\n      return ((_hashTableModel$memor = hashTableModel.memoryAddresses.find(function (_ref2) {\n        var key = _ref2.key;\n        return key === address;\n      })) === null || _hashTableModel$memor === void 0 ? void 0 : _hashTableModel$memor.values[0]) || null;\n    }\n  }, {\n    key: \"shouldThisAddressBlur\",\n    value: function shouldThisAddressBlur(address) {\n      var hashTableModel = this.props.hashTableModel;\n      var hasAddressNeedHighlight = hashTableModel.memoryAddresses.some(function (_ref3) {\n        var highlight = _ref3.highlight;\n        return highlight;\n      });\n      if (!hasAddressNeedHighlight) return false;\n      var currentAddress = hashTableModel.memoryAddresses.find(function (_ref4) {\n        var key = _ref4.key;\n        return key === address;\n      });\n      return !(currentAddress === null || currentAddress === void 0 ? void 0 : currentAddress.highlight);\n    }\n  }, {\n    key: \"getLabelAndValueProps\",\n    value: function getLabelAndValueProps(value, address) {\n      var collisionResolution = this.props.collisionResolution;\n\n      switch (collisionResolution) {\n        case 'chaining':\n          {\n            return {\n              labelDirection: 'left',\n              label: [address.toString()],\n              value: null\n            };\n          }\n\n        case 'linearProbe':\n          {\n            return {\n              label: [{\n                value: address.toString(),\n                direction: 'left'\n              }, {\n                value: address.toString(),\n                direction: 'right'\n              }],\n              value: value\n            };\n          }\n      }\n    }\n  }, {\n    key: \"renderLinkedListAtAddress\",\n    value: function renderLinkedListAtAddress(address) {\n      var hashTableModel = this.props.hashTableModel;\n      var memoryAddress = hashTableModel.memoryAddresses.find(function (_ref5) {\n        var key = _ref5.key;\n        return key == address;\n      });\n      if (!memoryAddress) return null;\n      if (!memoryAddress.values.length) return null;\n      return __jsx(React.Fragment, null, this.renderPointerLinkToLinkedList(+address), __jsx(LinkedListDS, {\n        key: address,\n        x: HASH_TABLE_ARRAY_X + ARRAY_BLOCK_WIDTH + 50,\n        y: +address * ARRAY_BLOCK_HEIGHT + 5,\n        instructions: [],\n        data: memoryAddress.values,\n        controlled: true // {...linkedListInstructionAndStep[address]}\n        ,\n        totalStep: 10\n      }));\n    }\n  }, {\n    key: \"renderPointerLinkToLinkedList\",\n    value: function renderPointerLinkToLinkedList(address) {\n      return __jsx(PointerLink, {\n        path: \"M \".concat(HASH_TABLE_ARRAY_X + ARRAY_BLOCK_WIDTH / 2, \" \").concat(+address * ARRAY_BLOCK_HEIGHT + ARRAY_BLOCK_HEIGHT / 2, \" H \").concat(HASH_TABLE_ARRAY_X + ARRAY_BLOCK_WIDTH + 50 - 6),\n        arrowDirection: \"right\"\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return this.renderListMemoryBlock();\n    }\n  }]);\n\n  return MemoryArray;\n}(Component);\nexport default MemoryArray;","map":null,"metadata":{},"sourceType":"module"}